/**
 * CSSmartDBConnection.java
 * Connection pooling and transaction management
 */
package com.cssmart.db;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartDBException;
import com.cssmart.logging.CSSmartLogger;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class CSSmartDBConnection {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartConfig config = CSSmartConfig.getInstance();
    private static final Map<String, HikariDataSource> dataSources = new HashMap<>();
    private static final ThreadLocal<Map<String, Connection>> threadConnections = ThreadLocal.withInitial(HashMap::new);
    
    /**
     * Get a database connection
     * @return the connection
     */
    public static Connection getConnection() {
        return getConnection("default");
    }
    
    /**
     * Get a database connection for a specific database
     * @param dbName the database name
     * @return the connection
     */
    public static Connection getConnection(String dbName) {
        // Check thread-local connections first
        Map<String, Connection> connections = threadConnections.get();
        Connection connection = connections.get(dbName);
        
        if (connection != null) {
            try {
                if (!connection.isClosed()) {
                    return connection;
                }
            } catch (SQLException e) {
                logger.error("Error checking connection state", e);
            }
        }
        
        // Create new connection
        try {
            HikariDataSource dataSource = getDataSource(dbName);
            connection = dataSource.getConnection();
            connections.put(dbName, connection);
            logger.debug("Obtained database connection for: " + dbName);
            return connection;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to get database connection for: " + dbName, e);
        }
    }
    
    /**
     * Get a data source
     * @param dbName the database name
     * @return the data source
     */
    private static synchronized HikariDataSource getDataSource(String dbName) {
        // Check if data source already exists
        HikariDataSource dataSource = dataSources.get(dbName);
        if (dataSource != null) {
            return dataSource;
        }
        
        // Create new data source
        String prefix = "db." + dbName + ".";
        
        String jdbcUrl = config.getProperty(prefix + "url");
        String username = config.getProperty(prefix + "username");
        String password = config.getProperty(prefix + "password");
        
        if (jdbcUrl == null) {
            throw new CSSmartDBException("Database URL not configured for: " + dbName);
        }
        
        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl(jdbcUrl);
        hikariConfig.setUsername(username);
        hikariConfig.setPassword(password);
        hikariConfig.setMaximumPoolSize(config.getIntProperty(prefix + "pool.size", 10));
        hikariConfig.setMinimumIdle(config.getIntProperty(prefix + "pool.idle", 5));
        hikariConfig.setIdleTimeout(config.getIntProperty(prefix + "pool.idleTimeout", 30000));
        hikariConfig.setPoolName("CSSmartPool-" + dbName);
        
        // Add additional properties
        for (Map.Entry<String, String> entry : config.getAllProperties().entrySet()) {
            if (entry.getKey().startsWith(prefix + "property.")) {
                String propertyName = entry.getKey().substring((prefix + "property.").length());
                hikariConfig.addDataSourceProperty(propertyName, entry.getValue());
            }
        }
        
        dataSource = new HikariDataSource(hikariConfig);
        dataSources.put(dbName, dataSource);
        
        logger.info("Created database connection pool for: " + dbName);
        return dataSource;
    }
    
    /**
     * Begin a transaction
     * @return the connection
     */
    public static Connection beginTransaction() {
        return beginTransaction("default");
    }
    
    /**
     * Begin a transaction for a specific database
     * @param dbName the database name
     * @return the connection
     */
    public static Connection beginTransaction(String dbName) {
        Connection connection = getConnection(dbName);
        
        try {
            connection.setAutoCommit(false);
            logger.debug("Started transaction for database: " + dbName);
            return connection;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to begin transaction for: " + dbName, e);
        }
    }
    
    /**
     * Commit a transaction
     * @param connection the connection
     */
    public static void commitTransaction(Connection connection) {
        if (connection == null) {
            return;
        }
        
        try {
            connection.commit();
            connection.setAutoCommit(true);
            logger.debug("Committed transaction");
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to commit transaction", e);
        }
    }
    
    /**
     * Rollback a transaction
     * @param connection the connection
     */
    public static void rollbackTransaction(Connection connection) {
        if (connection == null) {
            return;
        }
        
        try {
            connection.rollback();
            connection.setAutoCommit(true);
            logger.debug("Rolled back transaction");
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to rollback transaction", e);
        }
    }
    
    /**
     * Close a connection
     * @param connection the connection
     */
    public static void closeConnection(Connection connection) {
        if (connection == null) {
            return;
        }
        
        try {
            connection.close();
            
            // Remove from thread-local storage
            Map<String, Connection> connections = threadConnections.get();
            for (Map.Entry<String, Connection> entry : connections.entrySet()) {
                if (entry.getValue() == connection) {
                    connections.remove(entry.getKey());
                    break;
                }
            }
            
            logger.debug("Closed database connection");
        } catch (SQLException e) {
            logger.error("Failed to close database connection", e);
        }
    }
    
    /**
     * Close all connections for the current thread
     */
    public static void closeAllConnections() {
        Map<String, Connection> connections = threadConnections.get();
        
        for (Connection connection : connections.values()) {
            try {
                if (connection != null && !connection.isClosed()) {
                    connection.close();
                }
            } catch (SQLException e) {
                logger.error("Failed to close database connection", e);
            }
        }
        
        connections.clear();
        logger.debug("Closed all database connections for current thread");
    }
    
    /**
     * Shutdown all connection pools
     */
    public static void shutdown() {
        // Close all thread-local connections
        closeAllConnections();
        
        // Close all data sources
        for (HikariDataSource dataSource : dataSources.values()) {
            dataSource.close();
        }
        
        dataSources.clear();
        logger.info("Shut down all database connection pools");
    }
}

/**
 * CSSmartDBQuery.java
 * Fluent query builder
 */
package com.cssmart.db;

import com.cssmart.exceptions.CSSmartDBException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CSSmartDBQuery {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    
    private final Connection connection;
    private PreparedStatement statement;
    private String queryString;
    private final List<Object> parameters = new ArrayList<>();
    private boolean closeConnectionAfterExecution = false;
    
    /**
     * Constructor
     * @param connection the database connection
     */
    public CSSmartDBQuery(Connection connection) {
        this.connection = connection;
    }
    
    /**
     * Create a new query
     * @param connection the database connection
     * @return the query builder
     */
    public static CSSmartDBQuery create(Connection connection) {
        return new CSSmartDBQuery(connection);
    }
    
    /**
     * Create a new query with auto-connection
     * @return the query builder
     */
    public static CSSmartDBQuery create() {
        Connection connection = CSSmartDBConnection.getConnection();
        CSSmartDBQuery query = new CSSmartDBQuery(connection);
        query.closeConnectionAfterExecution = true;
        return query;
    }
    
    /**
     * Create a new query for a specific database
     * @param dbName the database name
     * @return the query builder
     */
    public static CSSmartDBQuery create(String dbName) {
        Connection connection = CSSmartDBConnection.getConnection(dbName);
        CSSmartDBQuery query = new CSSmartDBQuery(connection);
        query.closeConnectionAfterExecution = true;
        return query;
    }
    
    /**
     * Set the SQL query
     * @param queryString the SQL query
     * @return this query builder
     */
    public CSSmartDBQuery sql(String queryString) {
        this.queryString = queryString;
        return this;
    }
    
    /**
     * Add a parameter
     * @param value the parameter value
     * @return this query builder
     */
    public CSSmartDBQuery parameter(Object value) {
        parameters.add(value);
        return this;
    }
    
    /**
     * Add parameters
     * @param values the parameter values
     * @return this query builder
     */
    public CSSmartDBQuery parameters(Object... values) {
        for (Object value : values) {
            parameters.add(value);
        }
        return this;
    }
    
    /**
     * Execute a query and return a ResultSet
     * @return the ResultSet
     */
    public ResultSet executeQuery() {
        try {
            logger.info("Executing SQL query: " + queryString);
            report.logInfo("Executing SQL query: " + queryString);
            
            statement = connection.prepareStatement(queryString);
            setParameters(statement, parameters);
            
            return statement.executeQuery();
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to execute query: " + queryString, e);
        }
    }
    
    /**
     * Execute a query and return a list of maps
     * @return the list of maps
     */
    public List<Map<String, Object>> executeQueryAndReturnList() {
        try (ResultSet resultSet = executeQuery()) {
            List<Map<String, Object>> results = resultSetToList(resultSet);
            logger.info("Query returned " + results.size() + " rows");
            report.logInfo("Query returned " + results.size() + " rows");
            return results;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to process query results", e);
        } finally {
            closeIfNeeded();
        }
    }
    
    /**
     * Execute an update and return the number of affected rows
     * @return the number of affected rows
     */
    public int executeUpdate() {
        try {
            logger.info("Executing SQL update: " + queryString);
            report.logInfo("Executing SQL update: " + queryString);
            
            statement = connection.prepareStatement(queryString);
            setParameters(statement, parameters);
            
            int rowsAffected = statement.executeUpdate();
            logger.info("Update affected " + rowsAffected + " rows");
            report.logInfo("Update affected " + rowsAffected + " rows");
            
            return rowsAffected;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to execute update: " + queryString, e);
        } finally {
            closeIfNeeded();
        }
    }
    
    /**
     * Execute a query and return a single value
     * @param <T> the value type
     * @return the value
     */
    @SuppressWarnings("unchecked")
    public <T> T executeScalar() {
        try (ResultSet resultSet = executeQuery()) {
            if (resultSet.next()) {
                T value = (T) resultSet.getObject(1);
                logger.info("Query returned scalar value: " + value);
                report.logInfo("Query returned scalar value: " + value);
                return value;
            } else {
                return null;
            }
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to retrieve scalar value", e);
        } finally {
            closeIfNeeded();
        }
    }
    
    /**
     * Execute a batch update
     * @param batchParameters the batch parameters
     * @return the number of affected rows for each batch
     */
    public int[] executeBatch(List<List<Object>> batchParameters) {
        try {
            logger.info("Executing SQL batch update: " + queryString);
            report.logInfo("Executing SQL batch update: " + queryString);
            
            statement = connection.prepareStatement(queryString);
            
            for (List<Object> params : batchParameters) {
                setParameters(statement, params);
                statement.addBatch();
            }
            
            int[] results = statement.executeBatch();
            int totalAffected = 0;
            for (int result : results) {
                totalAffected += result;
            }
            
            logger.info("Batch update affected " + totalAffected + " rows in " + results.length + " batches");
            report.logInfo("Batch update affected " + totalAffected + " rows in " + results.length + " batches");
            
            return results;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to execute batch update: " + queryString, e);
        } finally {
            closeIfNeeded();
        }
    }
    
    /**
     * Set parameters on a prepared statement
     * @param statement the prepared statement
     * @param params the parameters
     * @throws SQLException if an error occurs
     */
    private void setParameters(PreparedStatement statement, List<Object> params) throws SQLException {
        for (int i = 0; i < params.size(); i++) {
            Object param = params.get(i);
            if (param == null) {
                statement.setNull(i + 1, java.sql.Types.NULL);
            } else {
                statement.setObject(i + 1, param);
            }
        }
    }
    
    /**
     * Convert a ResultSet to a list of maps
     * @param resultSet the ResultSet
     * @return the list of maps
     * @throws SQLException if an error occurs
     */
    private List<Map<String, Object>> resultSetToList(ResultSet resultSet) throws SQLException {
        List<Map<String, Object>> results = new ArrayList<>();
        ResultSetMetaData metaData = resultSet.getMetaData();
        int columnCount = metaData.getColumnCount();
        
        while (resultSet.next()) {
            Map<String, Object> row = new HashMap<>();
            
            for (int i = 1; i <= columnCount; i++) {
                String columnName = metaData.getColumnLabel(i);
                Object value = resultSet.getObject(i);
                row.put(columnName, value);
            }
            
            results.add(row);
        }
        
        return results;
    }
    
    /**
     * Close resources if needed
     */
    private void closeIfNeeded() {
        try {
            if (statement != null) {
                statement.close();
            }
            
            if (closeConnectionAfterExecution && connection != null) {
                CSSmartDBConnection.closeConnection(connection);
            }
        } catch (SQLException e) {
            logger.error("Failed to close database resources", e);
        }
    }
    
    /**
     * Get the connection
     * @return the connection
     */
    public Connection getConnection() {
        return connection;
    }
    
    /**
     * Close the statement
     */
    public void close() {
        closeIfNeeded();
    }
}

/**
 * CSSmartDBComparator.java
 * Data comparison and verification
 */
package com.cssmart.db;

import com.cssmart.exceptions.CSSmartDBException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

public class CSSmartDBComparator {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    
    /**
     * Compare two database query results
     * @param query1 the first query
     * @param query2 the second query
     * @return the comparison result
     */
    public static ComparisonResult compareQueries(String query1, String query2) {
        return compareQueries(query1, query2, "default", "default");
    }
    
    /**
     * Compare two database query results from different databases
     * @param query1 the first query
     * @param db1 the first database
     * @param query2 the second query
     * @param db2 the second database
     * @return the comparison result
     */
    public static ComparisonResult compareQueries(String query1, String db1, String query2, String db2) {
        logger.info("Comparing query results: [" + db1 + "] " + query1 + " vs [" + db2 + "] " + query2);
        report.logInfo("Comparing query results from two databases");
        
        Connection conn1 = null;
        Connection conn2 = null;
        
        try {
            conn1 = CSSmartDBConnection.getConnection(db1);
            conn2 = CSSmartDBConnection.getConnection(db2);
            
            List<Map<String, Object>> data1 = CSSmartDBQuery.create(conn1)
                .sql(query1)
                .executeQueryAndReturnList();
            
            List<Map<String, Object>> data2 = CSSmartDBQuery.create(conn2)
                .sql(query2)
                .executeQueryAndReturnList();
            
            return compareData(data1, data2);
        } finally {
            CSSmartDBConnection.closeConnection(conn1);
            CSSmartDBConnection.closeConnection(conn2);
        }
    }
    
    /**
     * Compare a query result with expected data
     * @param query the query
     * @param expectedData the expected data
     * @return the comparison result
     */
    public static ComparisonResult compareWithExpected(String query, List<Map<String, Object>> expectedData) {
        logger.info("Comparing query results with expected data: " + query);
        report.logInfo("Comparing query results with expected data");
        
        Connection conn = null;
        
        try {
            conn = CSSmartDBConnection.getConnection();
            
            List<Map<String, Object>> actualData = CSSmartDBQuery.create(conn)
                .sql(query)
                .executeQueryAndReturnList();
            
            return compareData(actualData, expectedData);
        } finally {
            CSSmartDBConnection.closeConnection(conn);
        }
    }
    
    /**
     * Compare two sets of data
     * @param data1 the first data set
     * @param data2 the second data set
     * @return the comparison result
     */
    public static ComparisonResult compareData(List<Map<String, Object>> data1, List<Map<String, Object>> data2) {
        return compareData(data1, data2, null);
    }
    
    /**
     * Compare two sets of data with a key extractor
     * @param data1 the first data set
     * @param data2 the second data set
     * @param keyExtractor the key extractor
     * @return the comparison result
     */
    public static ComparisonResult compareData(List<Map<String, Object>> data1, 
                                            List<Map<String, Object>> data2,
                                            Function<Map<String, Object>, Object> keyExtractor) {
        logger.debug("Comparing data sets: " + data1.size() + " rows vs " + data2.size() + " rows");
        
        // If no key extractor, compare by row index
        if (keyExtractor == null) {
            return compareByRowIndex(data1, data2);
        }
        
        // Compare by key
        List<RowDifference> differences = new ArrayList<>();
        Set<Object> keys1 = new HashSet<>();
        Set<Object> keys2 = new HashSet<>();
        
        // Extract keys
        for (Map<String, Object> row : data1) {
            keys1.add(keyExtractor.apply(row));
        }
        
        for (Map<String, Object> row : data2) {
            keys2.add(keyExtractor.apply(row));
        }
        
        // Find missing rows
        for (Object key : keys1) {
            if (!keys2.contains(key)) {
                Map<String, Object> row = findRowByKey(data1, keyExtractor, key);
                differences.add(new RowDifference(DifferenceType.MISSING_IN_SECOND, row, null));
            }
        }
        
        for (Object key : keys2) {
            if (!keys1.contains(key)) {
                Map<String, Object> row = findRowByKey(data2, keyExtractor, key);
                differences.add(new RowDifference(DifferenceType.MISSING_IN_FIRST, null, row));
            }
        }
        
        // Find common keys and compare values
        Set<Object> commonKeys = new HashSet<>(keys1);
        commonKeys.retainAll(keys2);
        
        for (Object key : commonKeys) {
            Map<String, Object> row1 = findRowByKey(data1, keyExtractor, key);
            Map<String, Object> row2 = findRowByKey(data2, keyExtractor, key);
            
            // Compare row values
            Map<String, ValueDifference> valueDiffs = compareRowValues(row1, row2);
            if (!valueDiffs.isEmpty()) {
                differences.add(new RowDifference(DifferenceType.VALUE_MISMATCH, row1, row2, valueDiffs));
            }
        }
        
        int matchCount = commonKeys.size() - (int) differences.stream()
            .filter(d -> d.getType() == DifferenceType.VALUE_MISMATCH)
            .count();
        
        // Create result
        ComparisonResult result = new ComparisonResult(
            data1.size(),
            data2.size(),
            matchCount,
            differences
        );
        
        logger.info("Comparison result: " + result.getMatchCount() + " matches, " + 
            result.getDifferences().size() + " differences");
        report.logInfo("Comparison result: " + result.getMatchCount() + " matches, " + 
            result.getDifferences().size() + " differences");
        
        return result;
    }
    
    /**
     * Compare by row index
     * @param data1 the first data set
     * @param data2 the second data set
     * @return the comparison result
     */
    private static ComparisonResult compareByRowIndex(List<Map<String, Object>> data1, 
                                                  List<Map<String, Object>> data2) {
        List<RowDifference> differences = new ArrayList<>();
        int commonRowCount = Math.min(data1.size(), data2.size());
        int matchCount = 0;
        
        // Compare common rows
        for (int i = 0; i < commonRowCount; i++) {
            Map<String, Object> row1 = data1.get(i);
            Map<String, Object> row2 = data2.get(i);
            
            Map<String, ValueDifference> valueDiffs = compareRowValues(row1, row2);
            if (valueDiffs.isEmpty()) {
                matchCount++;
            } else {
                differences.add(new RowDifference(DifferenceType.VALUE_MISMATCH, row1, row2, valueDiffs));
            }
        }
        
        // Add missing rows
        if (data1.size() > data2.size()) {
            for (int i = commonRowCount; i < data1.size(); i++) {
                differences.add(new RowDifference(DifferenceType.MISSING_IN_SECOND, data1.get(i), null));
            }
        } else if (data2.size() > data1.size()) {
            for (int i = commonRowCount; i < data2.size(); i++) {
                differences.add(new RowDifference(DifferenceType.MISSING_IN_FIRST, null, data2.get(i)));
            }
        }
        
        return new ComparisonResult(data1.size(), data2.size(), matchCount, differences);
    }
    
    /**
     * Find a row by key
     * @param data the data
     * @param keyExtractor the key extractor
     * @param key the key
     * @return the row
     */
    private static Map<String, Object> findRowByKey(List<Map<String, Object>> data,
                                               Function<Map<String, Object>, Object> keyExtractor,
                                               Object key) {
        for (Map<String, Object> row : data) {
            if (key.equals(keyExtractor.apply(row))) {
                return row;
            }
        }
        return null;
    }
    
    /**
     * Compare row values
     * @param row1 the first row
     * @param row2 the second row
     * @return the value differences
     */
    private static Map<String, ValueDifference> compareRowValues(Map<String, Object> row1, 
                                                           Map<String, Object> row2) {
        Map<String, ValueDifference> differences = new HashMap<>();
        
        // Get all column names
        Set<String> allColumns = new HashSet<>(row1.keySet());
        allColumns.addAll(row2.keySet());
        
        for (String column : allColumns) {
            Object value1 = row1.getOrDefault(column, null);
            Object value2 = row2.getOrDefault(column, null);
            
            if (!valuesEqual(value1, value2)) {
                differences.put(column, new ValueDifference(value1, value2));
            }
        }
        
        return differences;
    }
    
    /**
     * Check if two values are equal
     * @param value1 the first value
     * @param value2 the second value
     * @return true if the values are equal
     */
    private static boolean valuesEqual(Object value1, Object value2) {
        if (value1 == null && value2 == null) {
            return true;
        }
        
        if (value1 == null || value2 == null) {
            return false;
        }
        
        // Handle different numeric types
        if (value1 instanceof Number && value2 instanceof Number) {
            if (value1 instanceof Double || value1 instanceof Float || 
                value2 instanceof Double || value2 instanceof Float) {
                double dbl1 = ((Number) value1).doubleValue();
                double dbl2 = ((Number) value2).doubleValue();
                return Math.abs(dbl1 - dbl2) < 0.0000001;
            } else {
                long lng1 = ((Number) value1).longValue();
                long lng2 = ((Number) value2).longValue();
                return lng1 == lng2;
            }
        }
        
        return value1.equals(value2);
    }
    
    /**
     * Parse a query into a more structured format
     * @param query the query
     * @return the parsed query
     */
    public static ParsedQuery parseQuery(String query) {
        // This is a simple parser for demonstration purposes
        // A real implementation would be more robust
        
        String[] parts = query.trim().split("\\s+", 2);
        String queryType = parts[0].toUpperCase();
        
        if (queryType.equals("SELECT")) {
            // Extract FROM clause
            int fromIndex = query.toUpperCase().indexOf(" FROM ");
            if (fromIndex > 0) {
                String columns = query.substring(7, fromIndex).trim();
                String fromClause = query.substring(fromIndex + 6).trim();
                
                // Extract WHERE clause
                String tableName = fromClause;
                String whereClause = null;
                
                int whereIndex = fromClause.toUpperCase().indexOf(" WHERE ");
                if (whereIndex > 0) {
                    tableName = fromClause.substring(0, whereIndex).trim();
                    whereClause = fromClause.substring(whereIndex + 7).trim();
                }
                
                return new ParsedQuery(QueryType.SELECT, tableName, columns, whereClause);
            }
        } else if (queryType.equals("INSERT")) {
            // Extract table name
            int intoIndex = query.toUpperCase().indexOf(" INTO ");
            if (intoIndex > 0) {
                String afterInto = query.substring(intoIndex + 6).trim();
                int valuesIndex = afterInto.toUpperCase().indexOf(" VALUES ");
                
                if (valuesIndex > 0) {
                    String tableName = afterInto.substring(0, valuesIndex).trim();
                    String values = afterInto.substring(valuesIndex + 8).trim();
                    
                    return new ParsedQuery(QueryType.INSERT, tableName, null, values);
                }
            }
        } else if (queryType.equals("UPDATE")) {
            // Extract table name
            String afterUpdate = parts[1].trim();
            int setIndex = afterUpdate.toUpperCase().indexOf(" SET ");
            
            if (setIndex > 0) {
                String tableName = afterUpdate.substring(0, setIndex).trim();
                String afterSet = afterUpdate.substring(setIndex + 5).trim();
                
                // Extract WHERE clause
                String setClause = afterSet;
                String whereClause = null;
                
                int whereIndex = afterSet.toUpperCase().indexOf(" WHERE ");
                if (whereIndex > 0) {
                    setClause = afterSet.substring(0, whereIndex).trim();
                    whereClause = afterSet.substring(whereIndex + 7).trim();
                }
                
                return new ParsedQuery(QueryType.UPDATE, tableName, setClause, whereClause);
            }
        } else if (queryType.equals("DELETE")) {
            // Extract table name
            int fromIndex = query.toUpperCase().indexOf(" FROM ");
            if (fromIndex > 0) {
                String fromClause = query.substring(fromIndex + 6).trim();
                
                // Extract WHERE clause
                String tableName = fromClause;
                String whereClause = null;
                
                int whereIndex = fromClause.toUpperCase().indexOf(" WHERE ");
                if (whereIndex > 0) {
                    tableName = fromClause.substring(0, whereIndex).trim();
                    whereClause = fromClause.substring(whereIndex + 7).trim();
                }
                
                return new ParsedQuery(QueryType.DELETE, tableName, null, whereClause);
            }
        }
        
        // Default for unparseable queries
        return new ParsedQuery(QueryType.OTHER, null, null, query);
    }
    
    /**
     * Verify the structure of a ResultSet
     * @param resultSet the ResultSet
     * @param expectedColumns the expected columns
     * @return true if the structure matches
     */
    public static boolean verifyResultSetStructure(ResultSet resultSet, List<String> expectedColumns) {
        try {
            java.sql.ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            if (columnCount != expectedColumns.size()) {
                logger.error("Column count mismatch: expected " + expectedColumns.size() + 
                    ", got " + columnCount);
                return false;
            }
            
            for (int i = 1; i <= columnCount; i++) {
                String columnName = metaData.getColumnLabel(i);
                if (!columnName.equalsIgnoreCase(expectedColumns.get(i - 1))) {
                    logger.error("Column name mismatch at position " + i + ": expected " + 
                        expectedColumns.get(i - 1) + ", got " + columnName);
                    return false;
                }
            }
            
            return true;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to verify ResultSet structure", e);
        }
    }
    
    /**
     * Verify the row count of a ResultSet
     * @param resultSet the ResultSet
     * @param expectedCount the expected count
     * @return true if the count matches
     */
    public static boolean verifyResultSetRowCount(ResultSet resultSet, int expectedCount) {
        try {
            int actualCount = 0;
            resultSet.beforeFirst();
            while (resultSet.next()) {
                actualCount++;
            }
            resultSet.beforeFirst();
            
            boolean result = actualCount == expectedCount;
            if (!result) {
                logger.error("Row count mismatch: expected " + expectedCount + ", got " + actualCount);
            }
            
            return result;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to verify ResultSet row count", e);
        }
    }
    
    /**
     * Query type enum
     */
    public enum QueryType {
        SELECT,
        INSERT,
        UPDATE,
        DELETE,
        OTHER
    }
    
    /**
     * Difference type enum
     */
    public enum DifferenceType {
        MISSING_IN_FIRST,
        MISSING_IN_SECOND,
        VALUE_MISMATCH
    }
    
    /**
     * Parsed query class
     */
    public static class ParsedQuery {
        private final QueryType type;
        private final String tableName;
        private final String columnsOrSet;
        private final String whereOrValues;
        
        /**
         * Constructor
         * @param type the query type
         * @param tableName the table name
         * @param columnsOrSet the columns or SET clause
         * @param whereOrValues the WHERE clause or VALUES
         */
        public ParsedQuery(QueryType type, String tableName, String columnsOrSet, String whereOrValues) {
            this.type = type;
            this.tableName = tableName;
            this.columnsOrSet = columnsOrSet;
            this.whereOrValues = whereOrValues;
        }
        
        /**
         * Get the query type
         * @return the query type
         */
        public QueryType getType() {
            return type;
        }
        
        /**
         * Get the table name
         * @return the table name
         */
        public String getTableName() {
            return tableName;
        }
        
        /**
         * Get the columns or SET clause
         * @return the columns or SET clause
         */
        public String getColumnsOrSet() {
            return columnsOrSet;
        }
        
        /**
         * Get the WHERE clause or VALUES
         * @return the WHERE clause or VALUES
         */
        public String getWhereOrValues() {
            return whereOrValues;
        }
    }
    
    /**
     * Comparison result class
     */
    public static class ComparisonResult {
        private final int rowCount1;
        private final int rowCount2;
        private final int matchCount;
        private final List<RowDifference> differences;
        
        /**
         * Constructor
         * @param rowCount1 the row count of the first data set
         * @param rowCount2 the row count of the second data set
         * @param matchCount the match count
         * @param differences the differences
         */
        public ComparisonResult(int rowCount1, int rowCount2, int matchCount, List<RowDifference> differences) {
            this.rowCount1 = rowCount1;
            this.rowCount2 = rowCount2;
            this.matchCount = matchCount;
            this.differences = differences;
        }
        
        /**
         * Get the row count of the first data set
         * @return the row count
         */
        public int getRowCount1() {
            return rowCount1;
        }
        
        /**
         * Get the row count of the second data set
         * @return the row count
         */
        public int getRowCount2() {
            return rowCount2;
        }
        
        /**
         * Get the match count
         * @return the match count
         */
        public int getMatchCount() {
            return matchCount;
        }
        
        /**
         * Get the differences
         * @return the differences
         */
        public List<RowDifference> getDifferences() {
            return differences;
        }
        
        /**
         * Check if the comparison passed
         * @return true if there are no differences
         */
        public boolean isPassed() {
            return differences.isEmpty();
        }
        
        /**
         * Get the mismatch rate
         * @return the mismatch rate
         */
        public double getMismatchRate() {
            int totalRows = Math.max(rowCount1, rowCount2);
            return totalRows > 0 ? (double) differences.size() / totalRows : 0;
        }
        
        /**
         * Get a detailed report
         * @return the report
         */
        public String getDetailedReport() {
            StringBuilder report = new StringBuilder();
            report.append("Comparison Report:\n");
            report.append("- Data Set 1: ").append(rowCount1).append(" rows\n");
            report.append("- Data Set 2: ").append(rowCount2).append(" rows\n");
            report.append("- Matches: ").append(matchCount).append("\n");
            report.append("- Differences: ").append(differences.size()).append("\n");
            
            if (!differences.isEmpty()) {
                report.append("\nDifferences:\n");
                for (int i = 0; i < differences.size(); i++) {
                    RowDifference diff = differences.get(i);
                    report.append("  ").append(i + 1).append(": ");
                    
                    switch (diff.getType()) {
                        case MISSING_IN_FIRST:
                            report.append("Row missing in first data set: ").append(diff.getRow2()).append("\n");
                            break;
                        case MISSING_IN_SECOND:
                            report.append("Row missing in second data set: ").append(diff.getRow1()).append("\n");
                            break;
                        case VALUE_MISMATCH:
                            report.append("Value mismatch:\n");
                            for (Map.Entry<String, ValueDifference> entry : diff.getValueDifferences().entrySet()) {
                                report.append("    - ").append(entry.getKey()).append(": ")
                                    .append(entry.getValue().getValue1()).append(" vs ")
                                    .append(entry.getValue().getValue2()).append("\n");
                            }
                            break;
                    }
                }
            }
            
            return report.toString();
        }
    }
    
    /**
     * Row difference class
     */
    public static class RowDifference {
        private final DifferenceType type;
        private final Map<String, Object> row1;
        private final Map<String, Object> row2;
        private final Map<String, ValueDifference> valueDifferences;
        
        /**
         * Constructor for missing rows
         * @param type the difference type
         * @param row1 the first row
         * @param row2 the second row
         */
        public RowDifference(DifferenceType type, Map<String, Object> row1, Map<String, Object> row2) {
            this(type, row1, row2, new HashMap<>());
        }
        
        /**
         * Constructor for value mismatches
         * @param type the difference type
         * @param row1 the first row
         * @param row2 the second row
         * @param valueDifferences the value differences
         */
        public RowDifference(DifferenceType type, Map<String, Object> row1, Map<String, Object> row2,
                           Map<String, ValueDifference> valueDifferences) {
            this.type = type;
            this.row1 = row1;
            this.row2 = row2;
            this.valueDifferences = valueDifferences;
        }
        
        /**
         * Get the difference type
         * @return the difference type
         */
        public DifferenceType getType() {
            return type;
        }
        
        /**
         * Get the first row
         * @return the first row
         */
        public Map<String, Object> getRow1() {
            return row1;
        }
        
        /**
         * Get the second row
         * @return the second row
         */
        public Map<String, Object> getRow2() {
            return row2;
        }
        
        /**
         * Get the value differences
         * @return the value differences
         */
        public Map<String, ValueDifference> getValueDifferences() {
            return valueDifferences;
        }
    }
    
    /**
     * Value difference class
     */
    public static class ValueDifference {
        private final Object value1;
        private final Object value2;
        
        /**
         * Constructor
         * @param value1 the first value
         * @param value2 the second value
         */
        public ValueDifference(Object value1, Object value2) {
            this.value1 = value1;
            this.value2 = value2;
        }
        
        /**
         * Get the first value
         * @return the first value
         */
        public Object getValue1() {
            return value1;
        }
        
        /**
         * Get the second value
         * @return the second value
         */
        public Object getValue2() {
            return value2;
        }
    }
}

/**
 * CSSmartDBProcedure.java
 * Stored procedure testing capabilities
 */
package com.cssmart.db;

import com.cssmart.exceptions.CSSmartDBException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CSSmartDBProcedure {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    
    private final Connection connection;
    private CallableStatement statement;
    private final String procedureName;
    private final List<Parameter> parameters = new ArrayList<>();
    private boolean closeConnectionAfterExecution = false;
    
    /**
     * Constructor
     * @param connection the database connection
     * @param procedureName the procedure name
     */
    public CSSmartDBProcedure(Connection connection, String procedureName) {
        this.connection = connection;
        this.procedureName = procedureName;
    }
    
    /**
     * Create a new procedure call
     * @param connection the database connection
     * @param procedureName the procedure name
     * @return the procedure
     */
    public static CSSmartDBProcedure create(Connection connection, String procedureName) {
        return new CSSmartDBProcedure(connection, procedureName);
    }
    
    /**
     * Create a new procedure call with auto-connection
     * @param procedureName the procedure name
     * @return the procedure
     */
    public static CSSmartDBProcedure create(String procedureName) {
        Connection connection = CSSmartDBConnection.getConnection();
        CSSmartDBProcedure procedure = new CSSmartDBProcedure(connection, procedureName);
        procedure.closeConnectionAfterExecution = true;
        return procedure;
    }
    
    /**
     * Create a new procedure call for a specific database
     * @param procedureName the procedure name
     * @param dbName the database name
     * @return the procedure
     */
    public static CSSmartDBProcedure create(String procedureName, String dbName) {
        Connection connection = CSSmartDBConnection.getConnection(dbName);
        CSSmartDBProcedure procedure = new CSSmartDBProcedure(connection, procedureName);
        procedure.closeConnectionAfterExecution = true;
        return procedure;
    }
    
    /**
     * Add an input parameter
     * @param value the parameter value
     * @return this procedure
     */
    public CSSmartDBProcedure addInput(Object value) {
        parameters.add(new Parameter(ParameterType.IN, value, null));
        return this;
    }
    
    /**
     * Add an output parameter
     * @param sqlType the SQL type
     * @return this procedure
     */
    public CSSmartDBProcedure addOutput(int sqlType) {
        parameters.add(new Parameter(ParameterType.OUT, null, sqlType));
        return this;
    }
    
    /**
     * Add an input/output parameter
     * @param value the parameter value
     * @param sqlType the SQL type
     * @return this procedure
     */
    public CSSmartDBProcedure addInputOutput(Object value, int sqlType) {
        parameters.add(new Parameter(ParameterType.INOUT, value, sqlType));
        return this;
    }
    
    /**
     * Execute the procedure
     * @return the procedure result
     */
    public ProcedureResult execute() {
        try {
            logger.info("Executing stored procedure: " + procedureName);
            report.logInfo("Executing stored procedure: " + procedureName);
            
            // Build call string: {call procedure_name(?, ?, ...)}
            StringBuilder callString = new StringBuilder("{call ").append(procedureName).append("(");
            for (int i = 0; i < parameters.size(); i++) {
                if (i > 0) {
                    callString.append(", ");
                }
                callString.append("?");
            }
            callString.append(")}");
            
            // Prepare statement
            statement = connection.prepareCall(callString.toString());
            
            // Register parameters
            for (int i = 0; i < parameters.size(); i++) {
                Parameter param = parameters.get(i);
                
                switch (param.getType()) {
                    case IN:
                        statement.setObject(i + 1, param.getValue());
                        break;
                    case OUT:
                        statement.registerOutParameter(i + 1, param.getSqlType());
                        break;
                    case INOUT:
                        statement.setObject(i + 1, param.getValue());
                        statement.registerOutParameter(i + 1, param.getSqlType());
                        break;
                }
            }
            
            // Execute
            boolean hasResultSet = statement.execute();
            
            // Process results
            List<Map<String, Object>> resultSetData = new ArrayList<>();
            List<Object> outputValues = new ArrayList<>();
            int updateCount = 0;
            
            // Get the first ResultSet
            if (hasResultSet) {
                ResultSet rs = statement.getResultSet();
                resultSetData.add(resultSetToMap(rs));
                rs.close();
            } else {
                updateCount = statement.getUpdateCount();
            }
            
            // Get additional ResultSets
            while (statement.getMoreResults() || statement.getUpdateCount() != -1) {
                if (statement.getMoreResults()) {
                    ResultSet rs = statement.getResultSet();
                    resultSetData.add(resultSetToMap(rs));
                    rs.close();
                } else {
                    updateCount += statement.getUpdateCount();
                }
            }
            
            // Get output parameters
            for (int i = 0; i < parameters.size(); i++) {
                Parameter param = parameters.get(i);
                
                if (param.getType() == ParameterType.OUT || param.getType() == ParameterType.INOUT) {
                    outputValues.add(statement.getObject(i + 1));
                }
            }
            
            // Create result
            ProcedureResult result = new ProcedureResult(
                procedureName,
                resultSetData,
                outputValues,
                updateCount
            );
            
            logger.info("Procedure execution completed with " + resultSetData.size() + 
                " result sets and " + outputValues.size() + " output parameters");
            report.logInfo("Procedure execution completed");
            
            return result;
        } catch (SQLException e) {
            throw new CSSmartDBException("Failed to execute procedure: " + procedureName, e);
        } finally {
            closeIfNeeded();
        }
    }
    
    /**
     * Convert a ResultSet to a map
     * @param resultSet the ResultSet
     * @return the map
     * @throws SQLException if an error occurs
     */
    private List<Map<String, Object>> resultSetToMap(ResultSet resultSet) throws SQLException {
        List<Map<String, Object>> resultList = new ArrayList<>();
        java.sql.ResultSetMetaData metaData = resultSet.getMetaData();
        int columnCount = metaData.getColumnCount();
        
        while (resultSet.next()) {
            Map<String, Object> row = new HashMap<>();
            
            for (int i = 1; i <= columnCount; i++) {
                String columnName = metaData.getColumnLabel(i);
                Object value = resultSet.getObject(i);
                row.put(columnName, value);
            }
            
            resultList.add(row);
        }
        
        return resultList;
    }
    
    /**
     * Close resources if needed
     */
    private void closeIfNeeded() {
        try {
            if (statement != null) {
                statement.close();
            }
            
            if (closeConnectionAfterExecution && connection != null) {
                CSSmartDBConnection.closeConnection(connection);
            }
        } catch (SQLException e) {
            logger.error("Failed to close database resources", e);
        }
    }
    
    /**
     * Close the statement
     */
    public void close() {
        closeIfNeeded();
    }
    
    /**
     * Parameter type enum
     */
    public enum ParameterType {
        IN,
        OUT,
        INOUT
    }
    
    /**
     * Parameter class
     */
    private static class Parameter {
        private final ParameterType type;
        private final Object value;
        private final Integer sqlType;
        
        /**
         * Constructor
         * @param type the parameter type
         * @param value the parameter value
         * @param sqlType the SQL type
         */
        public Parameter(ParameterType type, Object value, Integer sqlType) {
            this.type = type;
            this.value = value;
            this.sqlType = sqlType;
        }
        
        /**
         * Get the parameter type
         * @return the parameter type
         */
        public ParameterType getType() {
            return type;
        }
        
        /**
         * Get the parameter value
         * @return the parameter value
         */
        public Object getValue() {
            return value;
        }
        
        /**
         * Get the SQL type
         * @return the SQL type
         */
        public int getSqlType() {
            return sqlType != null ? sqlType : Types.VARCHAR;
        }
    }
    
    /**
     * Procedure result class
     */
    public static class ProcedureResult {
        private final String procedureName;
        private final List<List<Map<String, Object>>> resultSets;
        private final List<Object> outputParameters;
        private final int updateCount;
        
        /**
         * Constructor
         * @param procedureName the procedure name
         * @param resultSets the result sets
         * @param outputParameters the output parameters
         * @param updateCount the update count
         */
        public ProcedureResult(String procedureName, List<Map<String, Object>> resultSets,
                            List<Object> outputParameters, int updateCount) {
            this.procedureName = procedureName;
            this.resultSets = new ArrayList<>();
            this.resultSets.add(resultSets);
            this.outputParameters = outputParameters;
            this.updateCount = updateCount;
        }
        
        /**
         * Get the procedure name
         * @return the procedure name
         */
        public String getProcedureName() {
            return procedureName;
        }
        
        /**
         * Get the result sets
         * @return the result sets
         */
        public List<List<Map<String, Object>>> getResultSets() {
            return resultSets;
        }
        
        /**
         * Get the first result set
         * @return the first result set
         */
        public List<Map<String, Object>> getFirstResultSet() {
            return resultSets.isEmpty() ? new ArrayList<>() : resultSets.get(0);
        }
        
        /**
         * Get the output parameters
         * @return the output parameters
         */
        public List<Object> getOutputParameters() {
            return outputParameters;
        }
        
        /**
         * Get an output parameter
         * @param index the parameter index
         * @return the parameter value
         */
        public Object getOutputParameter(int index) {
            return outputParameters.get(index);
        }
        
        /**
         * Get the update count
         * @return the update count
         */
        public int getUpdateCount() {
            return updateCount;
        }
        
        /**
         * Check if there are result sets
         * @return true if there are result sets/**
 * CSSmartTestNGExecutor.java
 * Custom TestNG execution engine
 */
package com.cssmart.testng;

import com.cssmart.bdd.CSSmartBDDScanner;
import com.cssmart.bdd.CSSmartBDDTestFactory;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.testng.ITestNGListener;
import org.testng.TestNG;
import org.testng.xml.Parser;
import org.testng.xml.XmlClass;
import org.testng.xml.XmlMethodSelector;
import org.testng.xml.XmlSuite;
import org.testng.xml.XmlTest;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class CSSmartTestNGExecutor {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartTestNGExecutor INSTANCE = new CSSmartTestNGExecutor();
    
    private TestNG testNG;
    
    /**
     * Private constructor
     */
    private CSSmartTestNGExecutor() {
        initialize();
    }
    
    /**
     * Get the singleton instance
     * @return the instance
     */
    public static CSSmartTestNGExecutor getInstance() {
        return INSTANCE;
    }
    
    /**
     * Initialize the executor
     */
    private void initialize() {
        testNG = new TestNG();
        testNG.setUseDefaultListeners(false);
        testNG.addListener(new CSSmartTestNGListener());
        testNG.setVerbose(0);
        logger.info("Initialized CSSmartTestNGExecutor");
    }
    
    /**
     * Add a listener
     * @param listener the listener
     */
    public void addListener(ITestNGListener listener) {
        testNG.addListener(listener);
        logger.debug("Added TestNG listener: " + listener.getClass().getName());
    }
    
    /**
     * Run tests by class
     * @param testClasses the test classes
     */
    public void runTestClasses(Class<?>... testClasses) {
        logger.info("Running tests for " + testClasses.length + " classes");
        report.logInfo("Running tests for " + testClasses.length + " classes");
        
        testNG.setTestClasses(testClasses);
        testNG.run();
        
        logger.info("Completed test execution");
    }
    
    /**
     * Run tests from an XML file
     * @param xmlFile the XML file
     */
    public void runTestXml(File xmlFile) {
        logger.info("Running tests from XML file: " + xmlFile.getAbsolutePath());
        report.logInfo("Running tests from XML file: " + xmlFile.getAbsolutePath());
        
        testNG.setTestSuites(Arrays.asList(xmlFile.getAbsolutePath()));
        testNG.run();
        
        logger.info("Completed test execution");
    }
    
    /**
     * Run BDD feature files
     * @param featureFiles the feature files
     * @param stepDefinitionPackages the step definition packages
     */
    public void runBDDFeatures(List<File> featureFiles, List<String> stepDefinitionPackages) {
        logger.info("Running BDD tests for " + featureFiles.size() + " feature files");
        report.logInfo("Running BDD tests for " + featureFiles.size() + " feature files");
        
        // Create TestNG XML for BDD features
        File xmlFile = createBDDXml(featureFiles, stepDefinitionPackages);
        
        // Run tests
        testNG.setTestSuites(Arrays.asList(xmlFile.getAbsolutePath()));
        testNG.run();
        
        logger.info("Completed BDD test execution");
    }
    
    /**
     * Create XML for BDD features
     * @param featureFiles the feature files
     * @param stepDefinitionPackages the step definition packages
     * @return the XML file
     */
    private File createBDDXml(List<File> featureFiles, List<String> stepDefinitionPackages) {
        try {
            // Create XML suite
            XmlSuite suite = new XmlSuite();
            suite.setName("BDD Test Suite");
            
            // Create test
            XmlTest test = new XmlTest(suite);
            test.setName("BDD Tests");
            
            // Add parameters
            suite.setParameters(Collections.singletonMap("featureFiles", 
                String.join(",", getFeatureFilePaths(featureFiles))));
            suite.setParameters(Collections.singletonMap("stepDefinitionPackages", 
                String.join(",", stepDefinitionPackages)));
            
            // Create method selector
            XmlMethodSelector selector = new XmlMethodSelector();
            selector.setName("CSSmartBDDSelector");
            selector.setLanguage("java");
            test.getMethodSelectors().add(selector);
            
            // Save XML file
            File xmlFile = File.createTempFile("cssmartbdd_", ".xml");
            try (FileWriter writer = new FileWriter(xmlFile)) {
                writer.write(suite.toXml());
            }
            
            return xmlFile;
        } catch (IOException e) {
            throw new CSSmartException("Failed to create BDD XML file", e);
        }
    }
    
    /**
     * Get feature file paths
     * @param featureFiles the feature files
     * @return the paths
     */
    private List<String> getFeatureFilePaths(List<File> featureFiles) {
        List<String> paths = new ArrayList<>();
        for (File file : featureFiles) {
            paths.add(file.getAbsolutePath());
        }
        return paths;
    }
    
    /**
     * Create a custom TestNG XML file
     * @param testPackages the test packages
     * @param outputFile the output file
     */
    public void createTestXml(List<String> testPackages, File outputFile) {
        logger.info("Creating TestNG XML file: " + outputFile.getAbsolutePath());
        
        try {
            // Create XML suite
            XmlSuite suite = new XmlSuite();
            suite.setName("CSSmartFramework Test Suite");
            
            // Create test
            XmlTest test = new XmlTest(suite);
            test.setName("CSSmartFramework Tests");
            
            // Add packages
            for (String packageName : testPackages) {
                XmlClass xmlClass = new XmlClass(packageName + ".*");
                test.getXmlClasses().add(xmlClass);
            }
            
            // Save XML file
            try (FileWriter writer = new FileWriter(outputFile)) {
                writer.write(suite.toXml());
            }
            
            logger.info("Created TestNG XML file");
        } catch (IOException e) {
            throw new CSSmartException("Failed to create TestNG XML file", e);
        }
    }
    
    /**
     * Parse a TestNG XML file
     * @param xmlFile the XML file
     * @return the parsed suites
     */
    public List<XmlSuite> parseTestXml(File xmlFile) {
        logger.info("Parsing TestNG XML file: " + xmlFile.getAbsolutePath());
        
        try (FileInputStream fileInputStream = new FileInputStream(xmlFile)) {
            Parser parser = new Parser(fileInputStream);
            List<XmlSuite> suites = parser.parse();
            
            logger.info("Parsed " + suites.size() + " test suites from XML file");
            return suites;
        } catch (Exception e) {
            throw new CSSmartException("Failed to parse TestNG XML file: " + xmlFile.getAbsolutePath(), e);
        }
    }
    
    /**
     * Set parallel mode
     * @param mode the parallel mode
     * @param threadCount the thread count
     */
    public void setParallelMode(TestNG.ParallelMode mode, int threadCount) {
        testNG.setParallel(mode);
        testNG.setThreadCount(threadCount);
        logger.info("Set parallel mode: " + mode + " with " + threadCount + " threads");
    }
}

/**
 * CSSmartTestNGListener.java
 * Custom TestNG listeners
 */
package com.cssmart.testng;

import com.cssmart.ado.CSSmartADOIntegration;
import com.cssmart.annotations.CSSmartADOTest;
import com.cssmart.annotations.CSSmartAnnotationProcessor;
import com.cssmart.base.CSSmartBaseSetup;
import com.cssmart.base.CSSmartBaseTeardown;
import com.cssmart.config.CSSmartConfig;
import com.cssmart.driver.CSSmartDriver;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;
import org.testng.annotations.Test;

import java.lang.reflect.Method;

public class CSSmartTestNGListener implements ITestListener {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartConfig config = CSSmartConfig.getInstance();
    private static final CSSmartAnnotationProcessor annotationProcessor = new CSSmartAnnotationProcessor();
    private static final ThreadLocal<CSSmartDriver> threadDriver = new ThreadLocal<>();
    private static final CSSmartADOIntegration adoIntegration = CSSmartADOIntegration.getInstance();
    
    /**
     * Called when the test run starts
     * @param context the test context
     */
    @Override
    public void onStart(ITestContext context) {
        logger.info("Starting test suite: " + context.getName());
        report.startSuite(context.getName());
    }
    
    /**
     * Called when the test run finishes
     * @param context the test context
     */
    @Override
    public void onFinish(ITestContext context) {
        logger.info("Finished test suite: " + context.getName());
        report.endSuite();
    }
    
    /**
     * Called before a test method is executed
     * @param result the test result
     */
    @Override
    public void onTestStart(ITestResult result) {
        // Get test method
        Method method = result.getMethod().getConstructorOrMethod().getMethod();
        Test testAnnotation = method.getAnnotation(Test.class);
        String testDescription = testAnnotation != null ? testAnnotation.description() : "";
        
        // Process annotations
        annotationProcessor.processClassAnnotations(result.getTestClass().getRealClass());
        
        // Create driver if needed
        CSSmartDriver driver = setupDriver();
        threadDriver.set(driver);
        
        // Process method annotations
        annotationProcessor.processMethodAnnotations(method, result.getInstance(), driver);
        
        // Start test reporting
        logger.info("Starting test: " + result.getName());
        report.startTest(result.getName(), testDescription);
        
        // Update ADO test case status if enabled
        if (config.getBooleanProperty("ado.enabled", false)) {
            CSSmartADOTest adoTestAnnotation = method.getAnnotation(CSSmartADOTest.class);
            if (adoTestAnnotation != null && adoTestAnnotation.updateResults()) {
                adoIntegration.startTestCase(adoTestAnnotation.testCaseId());
            }
        }
    }
    
    /**
     * Called when a test method succeeds
     * @param result the test result
     */
    @Override
    public void onTestSuccess(ITestResult result) {
        logger.info("Test passed: " + result.getName());
        
        // Take screenshot if enabled
        CSSmartDriver driver = threadDriver.get();
        if (driver != null && config.getBooleanProperty("screenshot.onSuccess", false)) {
            driver.takeScreenshot("SUCCESS_" + result.getName());
        }
        
        // End test reporting
        report.endTest(result);
        
        // Update ADO test case status if enabled
        updateADOTestStatus(result, true);
        
        // Cleanup driver
        cleanupDriver();
    }
    
    /**
     * Called when a test method fails
     * @param result the test result
     */
    @Override
    public void onTestFailure(ITestResult result) {
        logger.error("Test failed: " + result.getName());
        
        // Take screenshot
        CSSmartDriver driver = threadDriver.get();
        if (driver != null) {
            driver.takeScreenshot("FAILURE_" + result.getName());
        }
        
        // Log exception
        Throwable throwable = result.getThrowable();
        if (throwable != null) {
            logger.error("Test failure reason: " + throwable.getMessage(), throwable);
            report.logError("Test failure reason: " + throwable.getMessage());
        }
        
        // End test reporting
        report.endTest(result);
        
        // Update ADO test case status if enabled
        updateADOTestStatus(result, false);
        
        // Cleanup driver
        cleanupDriver();
    }
    
    /**
     * Called when a test method is skipped
     * @param result the test result
     */
    @Override
    public void onTestSkipped(ITestResult result) {
        logger.info("Test skipped: " + result.getName());
        
        // End test reporting
        report.endTest(result);
        
        // Update ADO test case status if enabled
        if (config.getBooleanProperty("ado.enabled", false)) {
            Method method = result.getMethod().getConstructorOrMethod().getMethod();
            CSSmartADOTest adoTestAnnotation = method.getAnnotation(CSSmartADOTest.class);
            if (adoTestAnnotation != null && adoTestAnnotation.updateResults()) {
                adoIntegration.updateTestCaseStatus(adoTestAnnotation.testCaseId(), "NotExecuted");
            }
        }
        
        // Cleanup driver
        cleanupDriver();
    }
    
    /**
     * Setup driver if needed
     * @return the driver
     */
    private CSSmartDriver setupDriver() {
        if (config.getBooleanProperty("driver.autoCreate", true)) {
            logger.debug("Auto-creating driver for test");
            CSSmartBaseSetup setup = new CSSmartBaseSetup();
            return setup.initializeDriver();
        }
        return null;
    }
    
    /**
     * Cleanup driver
     */
    private void cleanupDriver() {
        CSSmartDriver driver = threadDriver.get();
        if (driver != null) {
            CSSmartBaseTeardown teardown = new CSSmartBaseTeardown();
            teardown.quitDriver(driver);
            threadDriver.remove();
        }
    }
    
    /**
     * Update ADO test case status
     * @param result the test result
     * @param passed whether the test passed
     */
    private void updateADOTestStatus(ITestResult result, boolean passed) {
        if (config.getBooleanProperty("ado.enabled", false)) {
            Method method = result.getMethod().getConstructorOrMethod().getMethod();
            CSSmartADOTest adoTestAnnotation = method.getAnnotation(CSSmartADOTest.class);
            if (adoTestAnnotation != null && adoTestAnnotation.updateResults()) {
                String status = passed ? "Passed" : "Failed";
                adoIntegration.updateTestCaseStatus(adoTestAnnotation.testCaseId(), status);
                
                // Upload report if enabled
                if (adoTestAnnotation.uploadReport()) {
                    adoIntegration.uploadTestReport(adoTestAnnotation.testCaseId(), report.getReportPath());
                }
            }
        }
    }
    
    // Not used but required by interface
    @Override
    public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
        // Not implemented
    }
}

/**
 * CSSmartTestNGReporter.java
 * TestNG-specific reporting
 */
package com.cssmart.testng;

import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.testng.IReporter;
import org.testng.ISuite;
import org.testng.xml.XmlSuite;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CSSmartTestNGReporter implements IReporter {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    
    /**
     * Generate the report
     * @param xmlSuites the XML suites
     * @param suites the suites
     * @param outputDirectory the output directory
     */
    @Override
    public void generateReport(List<XmlSuite> xmlSuites, List<ISuite> suites, String outputDirectory) {
        logger.info("Generating TestNG report in: " + outputDirectory);
        
        try {
            // Create output directory if it doesn't exist
            File outDir = new File(outputDirectory);
            if (!outDir.exists()) {
                outDir.mkdirs();
            }
            
            // Get stats
            Map<String, TestSuiteStats> suiteStats = new HashMap<>();
            
            for (ISuite suite : suites) {
                TestSuiteStats stats = new TestSuiteStats();
                
                // Get test results
                suite.getResults().forEach((testName, testResult) -> {
                    stats.total += testResult.getTestContext().getAllTestMethods().length;
                    stats.passed += testResult.getTestContext().getPassedTests().size();
                    stats.failed += testResult.getTestContext().getFailedTests().size();
                    stats.skipped += testResult.getTestContext().getSkippedTests().size();
                });
                
                suiteStats.put(suite.getName(), stats);
            }
            
            // Generate summary report
            generateSummaryReport(suiteStats, outputDirectory);
            
            logger.info("TestNG report generation completed");
        } catch (Exception e) {
            logger.error("Failed to generate TestNG report", e);
        }
    }
    
    /**
     * Generate summary report
     * @param suiteStats the suite stats
     * @param outputDirectory the output directory
     * @throws IOException if an error occurs
     */
    private void generateSummaryReport(Map<String, TestSuiteStats> suiteStats, String outputDirectory) throws IOException {
        File summaryFile = new File(outputDirectory, "summary.html");
        
        try (FileWriter writer = new FileWriter(summaryFile)) {
            writer.write("<!DOCTYPE html>\n");
            writer.write("<html>\n");
            writer.write("<head>\n");
            writer.write("    <title>TestNG Summary Report</title>\n");
            writer.write("    <style>\n");
            writer.write("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
            writer.write("        table { border-collapse: collapse; width: 100%; }\n");
            writer.write("        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
            writer.write("        th { background-color: #f2f2f2; }\n");
            writer.write("        .passed { color: green; }\n");
            writer.write("        .failed { color: red; }\n");
            writer.write("        .skipped { color: orange; }\n");
            writer.write("    </style>\n");
            writer.write("</head>\n");
            writer.write("<body>\n");
            writer.write("    <h1>TestNG Summary Report</h1>\n");
            
            // Summary table
            writer.write("    <table>\n");
            writer.write("        <tr>\n");
            writer.write("            <th>Suite Name</th>\n");
            writer.write("            <th>Total</th>\n");
            writer.write("            <th>Passed</th>\n");
            writer.write("            <th>Failed</th>\n");
            writer.write("            <th>Skipped</th>\n");
            writer.write("            <th>Pass Rate</th>\n");
            writer.write("            <th>Report</th>\n");
            writer.write("        </tr>\n");
            
            int totalTests = 0;
            int totalPassed = 0;
            int totalFailed = 0;
            int totalSkipped = 0;
            
            for (Map.Entry<String, TestSuiteStats> entry : suiteStats.entrySet()) {
                String suiteName = entry.getKey();
                TestSuiteStats stats = entry.getValue();
                double passRate = stats.total > 0 ? (double) stats.passed / stats.total * 100 : 0;
                
                totalTests += stats.total;
                totalPassed += stats.passed;
                totalFailed += stats.failed;
                totalSkipped += stats.skipped;
                
                writer.write("        <tr>\n");
                writer.write("            <td>" + suiteName + "</td>\n");
                writer.write("            <td>" + stats.total + "</td>\n");
                writer.write("            <td class=\"passed\">" + stats.passed + "</td>\n");
                writer.write("            <td class=\"failed\">" + stats.failed + "</td>\n");
                writer.write("            <td class=\"skipped\">" + stats.skipped + "</td>\n");
                writer.write("            <td>" + String.format("%.2f%%", passRate) + "</td>\n");
                writer.write("            <td><a href=\"" + suiteName + "-results.html\">View</a></td>\n");
                writer.write("        </tr>\n");
            }
            
            // Add total row
            double totalPassRate = totalTests > 0 ? (double) totalPassed / totalTests * 100 : 0;
            
            writer.write("        <tr>\n");
            writer.write("            <th>Total</th>\n");
            writer.write("            <th>" + totalTests + "</th>\n");
            writer.write("            <th class=\"passed\">" + totalPassed + "</th>\n");
            writer.write("            <th class=\"failed\">" + totalFailed + "</th>\n");
            writer.write("            <th class=\"skipped\">" + totalSkipped + "</th>\n");
            writer.write("            <th>" + String.format("%.2f%%", totalPassRate) + "</th>\n");
            writer.write("            <th></th>\n");
            writer.write("        </tr>\n");
            
            writer.write("    </table>\n");
            
            // Link to CSSmartReport
            writer.write("    <h2>Links</h2>\n");
            writer.write("    <p><a href=\"" + report.getReportPath() + "\">View Detailed CSSmartFramework Report</a></p>\n");
            
            writer.write("</body>\n");
            writer.write("</html>");
        }
    }
    
    /**
     * Test suite stats class
     */
    private static class TestSuiteStats {
        int total = 0;
        int passed = 0;
        int failed = 0;
        int skipped = 0;
    }
}


/**
 * CSSmartADOIntegration.java
 * Direct REST API integration with ADO
 */
package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CSSmartADOIntegration {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartADOIntegration INSTANCE = new CSSmartADOIntegration();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    
    private final HttpClient httpClient;
    private final CSSmartConfig config;
    private final Map<String, TestCaseInfo> testCaseMapping = new ConcurrentHashMap<>();
    
    /**
     * Private constructor
     */
    private CSSmartADOIntegration() {
        httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();
        config = CSSmartConfig.getInstance();
        logger.info("Initialized CSSmartADOIntegration");
    }
    
    /**
     * Get the singleton instance
     * @return the instance
     */
    public static CSSmartADOIntegration getInstance() {
        return INSTANCE;
    }
    
    /**
     * Register a test case mapping
     * @param testName the test name
     * @param testCaseId the test case ID
     * @param updateResults whether to update results
     * @param uploadScreenshots whether to upload screenshots
     * @param uploadReport whether to upload the report
     * @param priority the priority
     * @param description the description
     */
    public void registerTestCase(String testName, String testCaseId, boolean updateResults,
                               boolean uploadScreenshots, boolean uploadReport, int priority,
                               String description) {
        TestCaseInfo info = new TestCaseInfo(testCaseId, updateResults, uploadScreenshots, 
            uploadReport, priority, description);
        testCaseMapping.put(testName, info);
        logger.debug("Registered test case mapping: " + testName + " -> " + testCaseId);
    }
    
    /**
     * Start a test case
     * @param testCaseId the test case ID
     */
    public void startTestCase(String testCaseId) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Starting ADO test case: " + testCaseId);
        report.logInfo("Starting ADO test case: " + testCaseId);
        
        try {
            // Get test point ID
            String testPointId = getTestPointId(testCaseId);
            if (testPointId == null) {
                logger.warning("Test point not found for test case: " + testCaseId);
                return;
            }
            
            // Create test run
            createTestRun(testCaseId, testPointId);
        } catch (Exception e) {
            logger.error("Failed to start test case: " + testCaseId, e);
        }
    }
    
    /**
     * Update test case status
     * @param testCaseId the test case ID
     * @param status the status
     */
    public void updateTestCaseStatus(String testCaseId, String status) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Updating ADO test case status: " + testCaseId + " -> " + status);
        report.logInfo("Updating ADO test case status: " + testCaseId + " -> " + status);
        
        try {
            // Get test run ID
            String testRunId = getTestRunId(testCaseId);
            if (testRunId == null) {
                logger.warning("Test run not found for test case: " + testCaseId);
                return;
            }
            
            // Update test result
            updateTestResult(testRunId, testCaseId, status);
        } catch (Exception e) {
            logger.error("Failed to update test case status: " + testCaseId, e);
        }
    }
    
    /**
     * Upload test report
     * @param testCaseId the test case ID
     * @param reportPath the report path
     */
    public void uploadTestReport(String testCaseId, String reportPath) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Uploading test report for: " + testCaseId);
        report.logInfo("Uploading test report for: " + testCaseId);
        
        try {
            // Get test run ID
            String testRunId = getTestRunId(testCaseId);
            if (testRunId == null) {
                logger.warning("Test run not found for test case: " + testCaseId);
                return;
            }
            
            // Upload attachment
            uploadAttachment(testRunId, testCaseId, reportPath);
        } catch (Exception e) {
            logger.error("Failed to upload test report: " + testCaseId, e);
        }
    }
    
    /**
     * Update test case results in batch
     * @param testResults the test results
     */
    public void updateTestResults(Map<String, String> testResults) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Updating ADO test results in batch for " + testResults.size() + " tests");
        report.logInfo("Updating ADO test results in batch");
        
        for (Map.Entry<String, String> entry : testResults.entrySet()) {
            updateTestCaseStatus(entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Get test point ID
     * @param testCaseId the test case ID
     * @return the test point ID
     */
    private String getTestPointId(String testCaseId) {
        try {
            String url = getBaseUrl() + "/test/points?testCaseId=" + testCaseId;
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                ArrayNode points = (ArrayNode) json.get("value");
                
                if (points.size() > 0) {
                    return points.get(0).get("id").asText();
                }
            }
            
            return null;
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test point ID for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Create test run
     * @param testCaseId the test case ID
     * @param testPointId the test point ID
     * @return the test run ID
     */
    private String createTestRun(String testCaseId, String testPointId) {
        try {
            String url = getBaseUrl() + "/test/runs";
            
            // Create request body
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("name", "CSSmartFramework - Test Run for " + testCaseId);
            json.put("state", "InProgress");
            
            // Add test points
            ArrayNode points = json.putArray("pointIds");
            points.add(Integer.parseInt(testPointId));
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(response.body());
                String testRunId = responseJson.get("id").asText();
                
                // Store test run ID
                storeTestRunId(testCaseId, testRunId);
                
                return testRunId;
            } else {
                logger.error("Failed to create test run: " + response.statusCode() + " - " + response.body());
                return null;
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to create test run for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Update test result
     * @param testRunId the test run ID
     * @param testCaseId the test case ID
     * @param status the status
     */
    private void updateTestResult(String testRunId, String testCaseId, String status) {
        try {
            String url = getBaseUrl() + "/test/runs/" + testRunId + "/results";
            
            // Get test results first
            HttpRequest getRequest = createGetRequest(url);
            HttpResponse<String> getResponse = httpClient.send(getRequest, HttpResponse.BodyHandlers.ofString());
            
            if (getResponse.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(getResponse.body());
                ArrayNode results = (ArrayNode) responseJson.get("value");
                
                if (results.size() > 0) {
                    String testResultId = results.get(0).get("id").asText();
                    
                    // Update test result
                    url = getBaseUrl() + "/test/runs/" + testRunId + "/results/" + testResultId;
                    
                    ObjectNode json = JSON_MAPPER.createObjectNode();
                    json.put("outcome", mapStatus(status));
                    
                    HttpRequest request = createPatchRequest(url, json.toString());
                    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
                    
                    if (response.statusCode() != 200) {
                        logger.error("Failed to update test result: " + response.statusCode() + " - " + response.body());
                    }
                }
            } else {
                logger.error("Failed to get test results: " + getResponse.statusCode() + " - " + getResponse.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to update test result for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Upload attachment
     * @param testRunId the test run ID
     * @param testCaseId the test case ID
     * @param filePath the file path
     */
    private void uploadAttachment(String testRunId, String testCaseId, String filePath) {
        try {
            // First, create attachment metadata
            String metadataUrl = getBaseUrl() + "/test/runs/" + testRunId + "/attachments";
            
            String fileName = Paths.get(filePath).getFileName().toString();
            
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("fileName", fileName);
            json.put("comment", "CSSmartFramework Test Report");
            json.put("attachmentType", "GeneralAttachment");
            
            HttpRequest metadataRequest = createPostRequest(metadataUrl, json.toString());
            HttpResponse<String> metadataResponse = httpClient.send(metadataRequest, HttpResponse.BodyHandlers.ofString());
            
            if (metadataResponse.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(metadataResponse.body());
                String attachmentId = responseJson.get("id").asText();
                
                // Then, upload the file content
                String contentUrl = getBaseUrl() + "/test/runs/" + testRunId + "/attachments/" + attachmentId + "/contents";
                
                byte[] fileContent = Files.readAllBytes(Paths.get(filePath));
                
                HttpRequest contentRequest = createPutRequest(contentUrl, fileContent);
                HttpResponse<String> contentResponse = httpClient.send(contentRequest, HttpResponse.BodyHandlers.ofString());
                
                if (contentResponse.statusCode() != 200) {
                    logger.error("Failed to upload attachment content: " + contentResponse.statusCode());
                }
            } else {
                logger.error("Failed to create attachment metadata: " + metadataResponse.statusCode() + " - " + metadataResponse.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to upload attachment for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Get test run ID
     * @param testCaseId the test case ID
     * @return the test run ID
     */
    private String getTestRunId(String testCaseId) {
        // This is a simple approach using a memory cache
        // In a real implementation, you might store this in a database or file
        String cacheKey = "testRun_" + testCaseId;
        return config.getProperty(cacheKey);
    }
    
    /**
     * Store test run ID
     * @param testCaseId the test case ID
     * @param testRunId the test run ID
     */
    private void storeTestRunId(String testCaseId, String testRunId) {
        String cacheKey = "testRun_" + testCaseId;
        config.setProperty(cacheKey, testRunId);
    }
    
    /**
     * Map status to ADO outcome
     * @param status the status
     * @return the outcome
     */
    private String mapStatus(String status) {
        switch (status.toLowerCase()) {
            case "passed":
                return "Passed";
            case "failed":
                return "Failed";
            case "skipped":
            case "notexecuted":
                return "NotExecuted";
            case "inprogress":
                return "InProgress";
            case "blocked":
                return "Blocked";
            default:
                return status;
        }
    }
    
    /**
     * Create GET request
     * @param url the URL
     * @return the request
     */
    private HttpRequest createGetRequest(String url) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .GET()
            .build();
    }
    
    /**
     * Create POST request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPostRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Create PATCH request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPatchRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .method("PATCH", HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Create PUT request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPutRequest(String url, byte[] body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/octet-stream")
            .header("Authorization", getAuthHeader())
            .PUT(HttpRequest.BodyPublishers.ofByteArray(body))
            .build();
    }
    
    /**
     * Get base URL
     * @return the base URL
     */
    private String getBaseUrl() {
        String url = config.getProperty("ado.url");
        String project = config.getProperty("ado.project");
        
        if (url == null || project == null) {
            throw new CSSmartException("ADO URL or project not configured");
        }
        
        return url + "/" + project + "/_apis";
    }
    
    /**
     * Get authorization header
     * @return the authorization header
     */
    private String getAuthHeader() {
        String token = config.getProperty("ado.token");
        
        if (token == null) {
            throw new CSSmartException("ADO token not configured");
        }
        
        String auth = ":" + token;
        return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Create GET request
     * @param url the URL
     * @return the request
     */
    private HttpRequest createGetRequest(String url) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .GET()
            .build();
    }
    
    /**
     * Create POST request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPostRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Test plan details class
     */
    public static class TestPlanDetails {
        private final String id;
        private final String name;
        private final String description;
        private final String state;
        
        /**
         * Constructor
         * @param id the ID
         * @param name the name
         * @param description the description
         * @param state the state
         */
        public TestPlanDetails(String id, String name, String description, String state) {
            this.id = id;
            this.name = name;
            this.description = description;
            this.state = state;
        }
        
        /**
         * Get the ID
         * @return the ID
         */
        public String getId() {
            return id;
        }
        
        /**
         * Get the name
         * @return the name
         */
        public String getName() {
            return name;
        }
        
        /**
         * Get the description
         * @return the description
         */
        public String getDescription() {
            return description;
        }
        
        /**
         * Get the state
         * @return the state
         */
        public String getState() {
            return state;
        }
    }
    
    /**
     * Test suite class
     */
    public static class TestSuite {
        private final String id;
        private final String name;
        private final String parentId;
        
        /**
         * Constructor
         * @param id the ID
         * @param name the name
         * @param parentId the parent ID
         */
        public TestSuite(String id, String name, String parentId) {
            this.id = id;
            this.name = name;
            this.parentId = parentId;
        }
        
        /**
         * Get the ID
         * @return the ID
         */
        public String getId() {
            return id;
        }
        
        /**
         * Get the name
         * @return the name
         */
        public String getName() {
            return name;
        }
        
        /**
         * Get the parent ID
         * @return the parent ID
         */
        public String getParentId() {
            return parentId;
        }
    }
    
    /**
     * Test case class
     */
    public static class TestCase {
        private final String id;
        private final String name;
        private final int priority;
        
        /**
         * Constructor
         * @param id the ID
         * @param name the name
         * @param priority the priority
         */
        public TestCase(String id, String name, int priority) {
            this.id = id;
            this.name = name;
            this.priority = priority;
        }
        
        /**
         * Get the ID
         * @return the ID
         */
        public String getId() {
            return id;
        }
        
        /**
         * Get the name
         * @return the name
         */
        public String getName() {
            return name;
        }
        
        /**
         * Get the priority
         * @return the priority
         */
        public int getPriority() {
            return priority;
        }
    }
}

/**
 * CSSmartADOTestCase.java
 * Test case operations
 */
package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Base64;

public class CSSmartADOTestCase {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    private static final HttpClient httpClient = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10))
        .build();
    
    private final CSSmartConfig config;
    private final String testCaseId;
    
    /**
     * Constructor
     * @param testCaseId the test case ID
     */
    public CSSmartADOTestCase(String testCaseId) {
        this.config = CSSmartConfig.getInstance();
        this.testCaseId = testCaseId;
        logger.info("Initialized CSSmartADOTestCase for ID: " + testCaseId);
    }
    
    /**
     * Get test case details
     * @return the test case details
     */
    public TestCaseDetails getTestCaseDetails() {
        try {
            String url = getBaseUrl() + "/wit/workitems/" + testCaseId;
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                JsonNode fields = json.get("fields");
                
                String title = fields.get("System.Title").asText();
                String state = fields.get("System.State").asText();
                int priority = fields.has("Microsoft.VSTS.Common.Priority") ? 
                    fields.get("Microsoft.VSTS.Common.Priority").asInt() : 2;
                String description = fields.has("System.Description") ? 
                    fields.get("System.Description").asText() : "";
                
                return new TestCaseDetails(testCaseId, title, state, priority, description);
            } else {
                throw new CSSmartException("Failed to get test case details: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test case details", e);
        }
    }
    
    /**
     * Update test case metadata
     * @param title the title
     * @param description the description
     * @param priority the priority
     * @return true if successful
     */
    public boolean updateTestCase(String title, String description, int priority) {
        try {
            String url = getBaseUrl() + "/wit/workitems/" + testCaseId;
            
            // Create patch document
            ObjectNode[] operations = new ObjectNode[3];
            
            operations[0] = JSON_MAPPER.createObjectNode();
            operations[0].put("op", "add");
            operations[0].put("path", "/fields/System.Title");
            operations[0].put("value", title);
            
            operations[1] = JSON_MAPPER.createObjectNode();
            operations[1].put("op", "add");
            operations[1].put("path", "/fields/System.Description");
            operations[1].put("value", description);
            
            operations[2] = JSON_MAPPER.createObjectNode();
            operations[2].put("op", "add");
            operations[2].put("path", "/fields/Microsoft.VSTS.Common.Priority");
            operations[2].put("value", priority);
            
            String jsonBody = JSON_MAPPER.writeValueAsString(operations);
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .header("Content-Type", "application/json-patch+json")
                .header("Accept", "application/json")
                .header("Authorization", getAuthHeader())
                .method("PATCH", HttpRequest.BodyPublishers.ofString(jsonBody))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to update test case", e);
        }
    }
    
    /**
     * Add a comment to a test case
     * @param comment the comment
     * @return true if successful
     */
    public boolean addComment(String comment) {
        try {
            String url = getBaseUrl() + "/wit/workitems/" + testCaseId + "/comments";
            
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("text", comment);
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to add comment to test case", e);
        }
    }
    
    /**
     * Link test case to a work item
     * @param workItemId the work item ID
     * @param linkType the link type
     * @return true if successful
     */
    public boolean linkToWorkItem(String workItemId, String linkType) {
        try {
            String url = getBaseUrl() + "/wit/workitems/" + testCaseId;
            
            ObjectNode operation = JSON_MAPPER.createObjectNode();
            operation.put("op", "add");
            operation.put("path", "/relations/-");
            
            ObjectNode value = JSON_MAPPER.createObjectNode();
            value.put("rel", linkType); // e.g., "System.LinkTypes.Hierarchy-Forward"
            value.put("url", getBaseUrl() + "/wit/workitems/" + workItemId);
            
            operation.set("value", value);
            
            String jsonBody = JSON_MAPPER.writeValueAsString(new ObjectNode[]{operation});
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .header("Content-Type", "application/json-patch+json")
                .header("Accept", "application/json")
                .header("Authorization", getAuthHeader())
                .method("PATCH", HttpRequest.BodyPublishers.ofString(jsonBody))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to link test case to work item", e);
        }
    }
    
    /**
     * Get base URL
     * @return the base URL
     */
    private String getBaseUrl() {
        String url = config.getProperty("ado.url");
        String project = config.getProperty("ado.project");
        
        if (url == null || project == null) {
            throw new CSSmartException("ADO URL or project not configured");
        }
        
        return url + "/" + project + "/_apis";
    }
    
    /**
     * Get authorization header
     * @return the authorization header
     */
    private String getAuthHeader() {
        String token = config.getProperty("ado.token");
        
        if (token == null) {
            throw new CSSmartException("ADO token not configured");
        }
        
        String auth = ":" + token;
        return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Create GET request
     * @param url the URL
     * @return the request
     */
    private HttpRequest createGetRequest(String url) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .GET()
            .build();
    }
    
    /**
     * Create POST request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPostRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Test case details class
     */
    public static class TestCaseDetails {
        private final String id;
        private final String title;
        private final String state;
        private final int priority;
        private final String description;
        
        /**
         * Constructor
         * @param id the ID
         * @param title the title
         * @param state the state
         * @param priority the priority
         * @param description the description
         */
        public TestCaseDetails(String id, String title, String state, int priority, String description) {
            this.id = id;
            this.title = title;
            this.state = state;
            this.priority = priority;
            this.description = description;
        }
        
        /**
         * Get the ID
         * @return the ID
         */
        public String getId() {
            return id;
        }
        
        /**
         * Get the title
         * @return the title
         */
        public String getTitle() {
            return title;
        }
        
        /**
         * Get the state
         * @return the state
         */
        public String getState() {
            return state;
        }
        
        /**
         * Get the priority
         * @return the priority
         */
        public int getPriority() {
            return priority;
        }
        
        /**
         * Get the description
         * @return the description
         */
        public String getDescription() {
            return description;
        }
    }
}

/**
 * CSSmartADOTestResult.java
 * Report test results
 */
package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

public class CSSmartADOTestResult {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    private static final HttpClient httpClient = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10))
        .build();
    
    private final CSSmartConfig config;
    
    /**
     * Constructor
     */
    public CSSmartADOTestResult() {
        this.config = CSSmartConfig.getInstance();
        logger.info("Initialized CSSmartADOTestResult");
    }
    
    /**
     * Create a test run
     * @param name the run name
     * @param testCaseIds the test case IDs
     * @return the test run ID
     */
    public String createTestRun(String name, List<String> testCaseIds) {
        try {
            String url = getBaseUrl() + "/test/runs";
            
            // Get test plan ID
            String testPlanId = config.getProperty("ado.testplan.id");
            if (testPlanId == null) {
                throw new CSSmartException("Test plan ID not configured");
            }
            
            // Create request body
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("name", name);
            json.put("plan", ObjectNode.class.cast(JSON_MAPPER.createObjectNode().put("id", testPlanId)));
            
            // Add test cases
            ArrayNode testCases = json.putArray("testCases");
            for (String testCaseId : testCaseIds) {
                testCases.add(ObjectNode.class.cast(JSON_MAPPER.createObjectNode().put("id", testCaseId)));
            }
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(response.body());
                return responseJson.get("id").asText();
            } else {
                throw new CSSmartException("Failed to create test run: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to create test run", e);
        }
    }
    
    /**
     * Get test results for a run
     * @param runId the run ID
     * @return the test results
     */
    public List<TestResult> getTestResults(String runId) {
        try {
            String url = getBaseUrl() + "/test/runs/" + runId + "/results";
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                ArrayNode results = (ArrayNode) json.get("value");
                
                List<TestResult> testResults = new ArrayList<>();
                
                for (JsonNode result : results) {
                    String id = result.get("id").asText();
                    String testCaseId = result.get("testCase").get("id").asText();
                    String outcome = result.has("outcome") ? result.get("outcome").asText() : "NotExecuted";
                    String comment = result.has("comment") ? result.get("comment").asText() : "";
                    
                    testResults.add(new TestResult(id, testCaseId, outcome, comment));
                }
                
                return testResults;
            } else {
                throw new CSSmartException("Failed to get test results: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test results for run: " + runId, e);
        }
    }
    
    /**
     * Update test result
     * @param runId the run ID
     * @param resultId the result ID
     * @param outcome the outcome
     * @param comment the comment
     * @return true if successful
     */
    public boolean updateTestResult(String runId, String resultId, String outcome, String comment) {
        try {
            String url = getBaseUrl() + "/test/runs/" + runId + "/results/" + resultId;
            
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("outcome", outcome);
            
            if (comment != null && !comment.isEmpty()) {
                json.put("comment", comment);
            }
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .header("Content-Type", "application/json")
                .header("Accept", "application/json")
                .header("Authorization", getAuthHeader())
                .method("PATCH", HttpRequest.BodyPublishers.ofString(json.toString()))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to update test result", e);
        }
    }
    
    /**
     * Complete a test run
     * @param runId the run ID
     * @return true if successful
     */
    public boolean completeTestRun(String runId) {
        try {
            String url = getBaseUrl() + "/test/runs/" + runId;
            
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("state", "Completed");
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .header("Content-Type", "application/json")
                .header("Accept", "application/json")
                .header("Authorization", getAuthHeader())
                .method("PATCH", HttpRequest.BodyPublishers.ofString(json.toString()))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to complete test run", e);
        }
    }
    
    /**
     * Get base URL
     * @return the base URL
     */
    private String getBaseUrl() {
        String url = config.getProperty("ado.url");
        String project = config.getProperty("ado.project");
        
        if (url == null || project == null) {
            throw new CSSmartException("ADO URL or project not configured");
        }
        
        return url + "/" + project + "/_apis";
    }
    
    /**
     * Get authorization header
     * @return the authorization header
     */
    private String getAuthHeader() {
        String token = config.getProperty("ado.token");
        
        if (token == null) {
            throw new CSSmartException("ADO token not configured");
        }
        
        String auth = ":" + token;
        return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Create GET request
     * @param url the URL
     * @return the request
     */
    private HttpRequest createGetRequest(String url) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .GET()
            .build();
    }
    
    /**
     * Create POST request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPostRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Test result class
     */
    public static class TestResult {
        private final String id;
        private final String testCaseId;
        private final String outcome;
        private final String comment;
        
        /**
         * Constructor
         * @param id the ID
         * @param testCaseId the test case ID
         * @param outcome the outcome
         * @param comment the comment
         */
        public TestResult(String id, String testCaseId, String outcome, String comment) {
            this.id = id;
            this.testCaseId = testCaseId;
            this.outcome = outcome;
            this.comment = comment;
        }
        
        /**
         * Get the ID
         * @return the ID
         */
        public String getId() {
            return id;
        }
        
        /**
         * Get the test case ID
         * @return the test case ID
         */
        public String getTestCaseId() {
            return testCaseId;
        }
        
        /**
         * Get the outcome
         * @return the outcome
         */
        public String getOutcome() {
            return outcome;
        }
        
        /**
         * Get the comment
         * @return the comment
         */
        public String getComment() {
            return comment;
        }
    }
}

/**
 * CSSmartADOAttachment.java
 * Upload reports to ADO
 */
package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.io.File;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.Duration;
import java.util.Base64;

public class CSSmartADOAttachment {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    private static final HttpClient httpClient = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10))
        .build();
    
    private final CSSmartConfig config;
    
    /**
     * Constructor
     */
    public CSSmartADOAttachment() {
        this.config = CSSmartConfig.getInstance();
        logger.info("Initialized CSSmartADOAttachment");
    }
    
    /**
     * Upload attachment to a test result
     * @param runId the run ID
     * @param resultId the result ID
     * @param filePath the file path
     * @param comment the comment
     * @return the attachment ID
     */
    public String uploadAttachmentToTestResult(String runId, String resultId, String filePath, String comment) {
        try {
            String url = getBaseUrl() + "/test/runs/" + runId + "/results/" + resultId + "/attachments";
            
            // Create metadata for attachment
            ObjectNode json = JSON_MAPPER.createObjectNode();
            
            File file = new File(filePath);
            json.put("fileName", file.getName());
            json.put("comment", comment);
            json.put("attachmentType", "GeneralAttachment");
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(response.body());
                String attachmentId = responseJson.get("id").asText();
                
                // Upload file content
                url = getBaseUrl() + "/test/runs/" + runId + "/results/" + resultId + "/attachments/" + attachmentId + "/contents";
                
                byte[] fileContent = Files.readAllBytes(file.toPath());
                
                HttpRequest contentRequest = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .header("Content-Type", "application/octet-stream")
                    .header("Authorization", getAuthHeader())
                    .PUT(HttpRequest.BodyPublishers.ofByteArray(fileContent))
                    .build();
                
                HttpResponse<String> contentResponse = httpClient.send(contentRequest, HttpResponse.BodyHandlers.ofString());
                
                if (contentResponse.statusCode() == 200) {
                    return attachmentId;
                } else {
                    throw new CSSmartException("Failed to upload attachment content: " + contentResponse.statusCode());
                }
            } else {
                throw new CSSmartException("Failed to create attachment metadata: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to upload attachment", e);
        }
    }
    
    /**
     * Upload attachment to a work item
     * @param workItemId the work item ID
     * @param filePath the file path
     * @param comment the comment
     * @return the attachment ID
     */
    public String uploadAttachmentToWorkItem(String workItemId, String filePath, String comment) {
        try {
            String url = getBaseUrl() + "/wit/attachments";
            
            // Create metadata for attachment
            ObjectNode json = JSON_MAPPER.createObjectNode();
            
            File file = new File(filePath);
            json.put("fileName", file.getName());
            json.put("comment", comment);
            json.put("uploadType", "simple");
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(response.body());
                String attachmentId = responseJson.get("id").asText();
                String url2 = responseJson.get("url").asText();
                
                // Upload file content
                byte[] fileContent = Files.readAllBytes(file.toPath());
                
                HttpRequest contentRequest = HttpRequest.newBuilder()
                    .uri(URI.create(url2))
                    .header("Content-Type", "application/octet-stream")
                    .header("Authorization", getAuthHeader())
                    .PUT(HttpRequest.BodyPublishers.ofByteArray(fileContent))
                    .build();
                
                HttpResponse<String> contentResponse = httpClient.send(contentRequest, HttpResponse.BodyHandlers.ofString());
                
                if (contentResponse.statusCode() == 201) {
                    // Link attachment to work item
                    url = getBaseUrl() + "/wit/workitems/" + workItemId;
                    
                    ObjectNode operation = JSON_MAPPER.createObjectNode();
                    operation.put("op", "add");
                    operation.put("path", "/relations/-");
                    
                    ObjectNode value = JSON_MAPPER.createObjectNode();
                    value.put("rel", "AttachedFile");
                    value.put("url", url2);
                    if (comment != null && !comment.isEmpty()) {
                        value.put("attributes", ObjectNode.class.cast(JSON_MAPPER.createObjectNode().put("comment", comment)));
                    }
                    
                    operation.set("value", value);
                    
                    String jsonBody = JSON_MAPPER.writeValueAsString(new ObjectNode[]{operation});
                    
                    HttpRequest patchRequest = HttpRequest.newBuilder()
                        .uri(URI.create(url))
                        .header("Content-Type", "application/json-patch+json")
                        .header("Accept", "application/json")
                        .header("Authorization", getAuthHeader())
                        .method("PATCH", HttpRequest.BodyPublishers.ofString(jsonBody))
                        .build();
                    
                    HttpResponse<String> patchResponse = httpClient.send(patchRequest, HttpResponse.BodyHandlers.ofString());
                    
                    if (patchResponse.statusCode() == 200) {
                        return attachmentId;
                    } else {
                        throw new CSSmartException("Failed to link attachment to work item: " + patchResponse.statusCode());
                    }
                } else {
                    throw new CSSmartException("Failed to upload attachment content: " + contentResponse.statusCode());
                }
            } else {
                throw new CSSmartException("Failed to create attachment metadata: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to upload attachment to work item", e);
        }
    }
    
    /**
     * Delete an attachment
     * @param attachmentId the attachment ID
     * @return true if successful
     */
    public boolean deleteAttachment(String attachmentId) {
        try {
            String url = getBaseUrl() + "/wit/attachments/" + attachmentId;
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .header("Authorization", getAuthHeader())
                .DELETE()
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 204;
        } catch (Exception e) {
            throw new CSSmartException("Failed to delete attachment", e);
        }
    }
    
    /**
     * Get base URL
     * @return the base URL
     */
    private String getBaseUrl() {
        String url = config.getProperty("ado.url");
        String project = config.getProperty("ado.project");
        
        if (url == null || project == null) {
            throw new CSSmartException("ADO URL or project not configured");
        }
        
        return url + "/" + project + "/_apis";
    }
    
    /**
     * Get authorization header
     * @return the authorization header
     */
    private String getAuthHeader() {
        String token = config.getProperty("ado.token");
        
        if (token == null) {
            throw new CSSmartException("ADO token not configured");
        }
        
        String auth = ":" + token;
        return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Create GET request
     * @param url the URL
     * @return the request
     */
    private HttpRequest createGetRequest(String url) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .GET()
            .build();
    }
    
    /**
     * Create POST request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPostRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
} or project not configured");
        }
        
        return url + "/" + project + "/_apis";
    }
    
    /**
     * Get authorization header
     * @return the authorization header
     */
    private String getAuthHeader() {
        String token = config.getProperty("ado.token");
        
        if (token == null) {
            throw new CSSmartException("ADO token not configured");
        }
        
        String auth = ":" + token;
        return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Check if ADO integration is enabled
     * @return true if enabled
     */
    private boolean isEnabled() {
        return config.getBooleanProperty("ado.enabled", false);
    }
    
    /**
     * Test case info class
     */
    private static class TestCaseInfo {
        private final String testCaseId;
        private final boolean updateResults;
        private final boolean uploadScreenshots;
        private final boolean uploadReport;
        private final int priority;
        private final String description;
        
        /**
         * Constructor
         * @param testCaseId the test case ID
         * @param updateResults whether to update results
         * @param uploadScreenshots whether to upload screenshots
         * @param uploadReport whether to upload the report
         * @param priority the priority
         * @param description the description
         */
        public TestCaseInfo(String testCaseId, boolean updateResults, boolean uploadScreenshots,
                          boolean uploadReport, int priority, String description) {
            this.testCaseId = testCaseId;
            this.updateResults = updateResults;
            this.uploadScreenshots = uploadScreenshots;
            this.uploadReport = uploadReport;
            this.priority = priority;
            this.description = description;
        }
    }
}

/**
 * CSSmartADOTestPlan.java
 * Test plan management
 */
package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

public class CSSmartADOTestPlan {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    private static final HttpClient httpClient = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10))
        .build();
    
    private final CSSmartConfig config;
    private final String testPlanId;
    
    /**
     * Constructor
     * @param testPlanId the test plan ID
     */
    public CSSmartADOTestPlan(String testPlanId) {
        this.config = CSSmartConfig.getInstance();
        this.testPlanId = testPlanId;
        logger.info("Initialized CSSmartADOTestPlan for ID: " + testPlanId);
    }
    
    /**
     * Constructor with default test plan ID from config
     */
    public CSSmartADOTestPlan() {
        this.config = CSSmartConfig.getInstance();
        this.testPlanId = config.getProperty("ado.testplan.id");
        
        if (testPlanId == null) {
            throw new CSSmartException("Test plan ID not configured in application.properties");
        }
        
        logger.info("Initialized CSSmartADOTestPlan for ID: " + testPlanId);
    }
    
    /**
     * Get test plan details
     * @return the test plan details
     */
    public TestPlanDetails getTestPlanDetails() {
        try {
            String url = getBaseUrl() + "/test/plans/" + testPlanId;
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                
                String name = json.get("name").asText();
                String description = json.has("description") ? json.get("description").asText() : "";
                String state = json.get("state").asText();
                
                return new TestPlanDetails(testPlanId, name, description, state);
            } else {
                throw new CSSmartException("Failed to get test plan details: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test plan details", e);
        }
    }
    
    /**
     * Get test suites in the test plan
     * @return the test suites
     */
    public List<TestSuite> getTestSuites() {
        try {
            String url = getBaseUrl() + "/test/plans/" + testPlanId + "/suites";
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                ArrayNode suites = (ArrayNode) json.get("value");
                
                List<TestSuite> result = new ArrayList<>();
                
                for (JsonNode suite : suites) {
                    String id = suite.get("id").asText();
                    String name = suite.get("name").asText();
                    String parentId = suite.has("parentSuite") ? suite.get("parentSuite").get("id").asText() : null;
                    
                    result.add(new TestSuite(id, name, parentId));
                }
                
                return result;
            } else {
                throw new CSSmartException("Failed to get test suites: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test suites", e);
        }
    }
    
    /**
     * Get test cases in a test suite
     * @param suiteId the test suite ID
     * @return the test cases
     */
    public List<TestCase> getTestCases(String suiteId) {
        try {
            String url = getBaseUrl() + "/test/plans/" + testPlanId + "/suites/" + suiteId + "/testcases";
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                ArrayNode cases = (ArrayNode) json.get("value");
                
                List<TestCase> result = new ArrayList<>();
                
                for (JsonNode testCase : cases) {
                    String id = testCase.get("testCase").get("id").asText();
                    String name = testCase.get("testCase").get("name").asText();
                    int priority = testCase.has("priority") ? testCase.get("priority").asInt() : 2;
                    
                    result.add(new TestCase(id, name, priority));
                }
                
                return result;
            } else {
                throw new CSSmartException("Failed to get test cases: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test cases for suite: " + suiteId, e);
        }
    }
    
    /**
     * Create a test suite
     * @param name the suite name
     * @param parentId the parent suite ID (null for root)
     * @return the created suite
     */
    public TestSuite createTestSuite(String name, String parentId) {
        try {
            String url = getBaseUrl() + "/test/plans/" + testPlanId + "/suites";
            
            // Add parent ID to URL if provided
            if (parentId != null) {
                url += "/" + parentId;
            }
            
            // Create request body
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("name", name);
            json.put("suiteType", "StaticTestSuite");
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(response.body());
                
                String id = responseJson.get("id").asText();
                name = responseJson.get("name").asText();
                
                return new TestSuite(id, name, parentId);
            } else {
                throw new CSSmartException("Failed to create test suite: " + response.statusCode() + " - " + response.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to create test suite: " + name, e);
        }
    }
    
    /**
     * Add a test case to a suite
     * @param suiteId the suite ID
     * @param testCaseId the test case ID
     * @return true if successful
     */
    public boolean addTestCaseToSuite(String suiteId, String testCaseId) {
        try {
            String url = getBaseUrl() + "/test/plans/" + testPlanId + "/suites/" + suiteId + "/testcases/" + testCaseId;
            
            HttpRequest request = createPostRequest(url, "{}");
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to add test case to suite", e);
        }
    }
    
    /**
     * Remove a test case from a suite
     * @param suiteId the suite ID
     * @param testCaseId the test case ID
     * @return true if successful
     */
    public boolean removeTestCaseFromSuite(String suiteId, String testCaseId) {
        try {
            String url = getBaseUrl() + "/test/plans/" + testPlanId + "/suites/" + suiteId + "/testcases/" + testCaseId;
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .header("Accept", "application/json")
                .header("Authorization", getAuthHeader())
                .DELETE()
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            return response.statusCode() == 200;
        } catch (Exception e) {
            throw new CSSmartException("Failed to remove test case from suite", e);
        }
    }
    
    /**
     * Get base URL
     * @return the base URL
     */
    private String getBaseUrl() {
        String url = config.getProperty("ado.url");
        String project = config.getProperty("ado.project");
        
        if (url == null || project == null) {
            throw new CSSmartException("ADO URL



package com.cssmart.ado;

/**
 * Represents test case mapping information
 */
public class TestCaseInfo {
    private final String testCaseId;
    private final boolean updateResults;
    private final boolean uploadScreenshots;
    private final boolean uploadReport;
    private final int priority;
    private final String description;
    
    /**
     * Constructor
     * @param testCaseId the test case ID
     * @param updateResults whether to update results
     * @param uploadScreenshots whether to upload screenshots
     * @param uploadReport whether to upload the report
     * @param priority the priority
     * @param description the description
     */
    public TestCaseInfo(String testCaseId, boolean updateResults, boolean uploadScreenshots,
                      boolean uploadReport, int priority, String description) {
        this.testCaseId = testCaseId;
        this.updateResults = updateResults;
        this.uploadScreenshots = uploadScreenshots;
        this.uploadReport = uploadReport;
        this.priority = priority;
        this.description = description;
    }
    
    /**
     * Get the test case ID
     * @return the test case ID
     */
    public String getTestCaseId() {
        return testCaseId;
    }
    
    /**
     * Check if results should be updated
     * @return true if results should be updated
     */
    public boolean isUpdateResults() {
        return updateResults;
    }
    
    /**
     * Check if screenshots should be uploaded
     * @return true if screenshots should be uploaded
     */
    public boolean isUploadScreenshots() {
        return uploadScreenshots;
    }
    
    /**
     * Check if report should be uploaded
     * @return true if report should be uploaded
     */
    public boolean isUploadReport() {
        return uploadReport;
    }
    
    /**
     * Get the priority
     * @return the priority
     */
    public int getPriority() {
        return priority;
    }
    
    /**
     * Get the description
     * @return the description
     */
    public String getDescription() {
        return description;
    }
}


package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Main integration class for Azure DevOps
 */
public class CSSmartADOIntegration {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartADOIntegration INSTANCE = new CSSmartADOIntegration();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
    
    private final HttpClient httpClient;
    private final CSSmartConfig config;
    private final Map<String, TestCaseInfo> testCaseMapping = new ConcurrentHashMap<>();
    
    /**
     * Private constructor
     */
    private CSSmartADOIntegration() {
        httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();
        config = CSSmartConfig.getInstance();
        logger.info("Initialized CSSmartADOIntegration");
    }
    
    /**
     * Get the singleton instance
     * @return the instance
     */
    public static CSSmartADOIntegration getInstance() {
        return INSTANCE;
    }
    
    /**
     * Register a test case mapping
     * @param testName the test name
     * @param testCaseId the test case ID
     * @param updateResults whether to update results
     * @param uploadScreenshots whether to upload screenshots
     * @param uploadReport whether to upload the report
     * @param priority the priority
     * @param description the description
     */
    public void registerTestCase(String testName, String testCaseId, boolean updateResults,
                               boolean uploadScreenshots, boolean uploadReport, int priority,
                               String description) {
        TestCaseInfo info = new TestCaseInfo(testCaseId, updateResults, uploadScreenshots, 
            uploadReport, priority, description);
        testCaseMapping.put(testName, info);
        logger.debug("Registered test case mapping: " + testName + " -> " + testCaseId);
    }
    
    /**
     * Get test case info for a test name
     * @param testName the test name
     * @return the test case info or null if not found
     */
    public TestCaseInfo getTestCaseInfo(String testName) {
        return testCaseMapping.get(testName);
    }
    
    /**
     * Start a test case
     * @param testCaseId the test case ID
     */
    public void startTestCase(String testCaseId) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Starting ADO test case: " + testCaseId);
        report.logInfo("Starting ADO test case: " + testCaseId);
        
        try {
            // Get test point ID
            String testPointId = getTestPointId(testCaseId);
            if (testPointId == null) {
                logger.warning("Test point not found for test case: " + testCaseId);
                return;
            }
            
            // Create test run
            createTestRun(testCaseId, testPointId);
        } catch (Exception e) {
            logger.error("Failed to start test case: " + testCaseId, e);
        }
    }
    
    /**
     * Update test case status
     * @param testCaseId the test case ID
     * @param status the status
     */
    public void updateTestCaseStatus(String testCaseId, String status) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Updating ADO test case status: " + testCaseId + " -> " + status);
        report.logInfo("Updating ADO test case status: " + testCaseId + " -> " + status);
        
        try {
            // Get test run ID
            String testRunId = getTestRunId(testCaseId);
            if (testRunId == null) {
                logger.warning("Test run not found for test case: " + testCaseId);
                return;
            }
            
            // Update test result
            updateTestResult(testRunId, testCaseId, status);
        } catch (Exception e) {
            logger.error("Failed to update test case status: " + testCaseId, e);
        }
    }
    
    /**
     * Upload test report
     * @param testCaseId the test case ID
     * @param reportPath the report path
     */
    public void uploadTestReport(String testCaseId, String reportPath) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Uploading test report for: " + testCaseId);
        report.logInfo("Uploading test report for: " + testCaseId);
        
        try {
            // Get test run ID
            String testRunId = getTestRunId(testCaseId);
            if (testRunId == null) {
                logger.warning("Test run not found for test case: " + testCaseId);
                return;
            }
            
            // Upload attachment
            uploadAttachment(testRunId, testCaseId, reportPath);
        } catch (Exception e) {
            logger.error("Failed to upload test report: " + testCaseId, e);
        }
    }
    
    /**
     * Upload screenshot for a test case
     * @param testCaseId the test case ID
     * @param screenshotPath the screenshot path
     * @param description the description
     */
    public void uploadScreenshot(String testCaseId, String screenshotPath, String description) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Uploading screenshot for: " + testCaseId);
        report.logInfo("Uploading screenshot for: " + testCaseId);
        
        try {
            // Get test run ID
            String testRunId = getTestRunId(testCaseId);
            if (testRunId == null) {
                logger.warning("Test run not found for test case: " + testCaseId);
                return;
            }
            
            // Upload attachment
            uploadAttachment(testRunId, testCaseId, screenshotPath);
        } catch (Exception e) {
            logger.error("Failed to upload screenshot: " + testCaseId, e);
        }
    }
    
    /**
     * Update test case results in batch
     * @param testResults the test results
     */
    public void updateTestResults(Map<String, String> testResults) {
        if (!isEnabled()) {
            return;
        }
        
        logger.info("Updating ADO test results in batch for " + testResults.size() + " tests");
        report.logInfo("Updating ADO test results in batch");
        
        for (Map.Entry<String, String> entry : testResults.entrySet()) {
            updateTestCaseStatus(entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Get test point ID
     * @param testCaseId the test case ID
     * @return the test point ID
     */
    private String getTestPointId(String testCaseId) {
        try {
            String url = getBaseUrl() + "/test/points?testCaseId=" + testCaseId;
            
            HttpRequest request = createGetRequest(url);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode json = JSON_MAPPER.readTree(response.body());
                ArrayNode points = (ArrayNode) json.get("value");
                
                if (points.size() > 0) {
                    return points.get(0).get("id").asText();
                }
            }
            
            return null;
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test point ID for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Create test run
     * @param testCaseId the test case ID
     * @param testPointId the test point ID
     * @return the test run ID
     */
    private String createTestRun(String testCaseId, String testPointId) {
        try {
            String url = getBaseUrl() + "/test/runs";
            
            // Create request body
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("name", "CSSmartFramework - Test Run for " + testCaseId);
            json.put("state", "InProgress");
            
            // Add test points
            ArrayNode points = json.putArray("pointIds");
            points.add(Integer.parseInt(testPointId));
            
            HttpRequest request = createPostRequest(url, json.toString());
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(response.body());
                String testRunId = responseJson.get("id").asText();
                
                // Store test run ID
                storeTestRunId(testCaseId, testRunId);
                
                return testRunId;
            } else {
                logger.error("Failed to create test run: " + response.statusCode() + " - " + response.body());
                return null;
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to create test run for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Update test result
     * @param testRunId the test run ID
     * @param testCaseId the test case ID
     * @param status the status
     */
    private void updateTestResult(String testRunId, String testCaseId, String status) {
        try {
            String url = getBaseUrl() + "/test/runs/" + testRunId + "/results";
            
            // Get test results first
            HttpRequest getRequest = createGetRequest(url);
            HttpResponse<String> getResponse = httpClient.send(getRequest, HttpResponse.BodyHandlers.ofString());
            
            if (getResponse.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(getResponse.body());
                ArrayNode results = (ArrayNode) responseJson.get("value");
                
                if (results.size() > 0) {
                    String testResultId = results.get(0).get("id").asText();
                    
                    // Update test result
                    url = getBaseUrl() + "/test/runs/" + testRunId + "/results/" + testResultId;
                    
                    ObjectNode json = JSON_MAPPER.createObjectNode();
                    json.put("outcome", mapStatus(status));
                    
                    HttpRequest request = createPatchRequest(url, json.toString());
                    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
                    
                    if (response.statusCode() != 200) {
                        logger.error("Failed to update test result: " + response.statusCode() + " - " + response.body());
                    }
                }
            } else {
                logger.error("Failed to get test results: " + getResponse.statusCode() + " - " + getResponse.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to update test result for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Upload attachment
     * @param testRunId the test run ID
     * @param testCaseId the test case ID
     * @param filePath the file path
     */
    private void uploadAttachment(String testRunId, String testCaseId, String filePath) {
        try {
            // First, create attachment metadata
            String metadataUrl = getBaseUrl() + "/test/runs/" + testRunId + "/attachments";
            
            String fileName = Paths.get(filePath).getFileName().toString();
            
            ObjectNode json = JSON_MAPPER.createObjectNode();
            json.put("fileName", fileName);
            json.put("comment", "CSSmartFramework Test Report");
            json.put("attachmentType", "GeneralAttachment");
            
            HttpRequest metadataRequest = createPostRequest(metadataUrl, json.toString());
            HttpResponse<String> metadataResponse = httpClient.send(metadataRequest, HttpResponse.BodyHandlers.ofString());
            
            if (metadataResponse.statusCode() == 200) {
                JsonNode responseJson = JSON_MAPPER.readTree(metadataResponse.body());
                String attachmentId = responseJson.get("id").asText();
                
                // Then, upload the file content
                String contentUrl = getBaseUrl() + "/test/runs/" + testRunId + "/attachments/" + attachmentId + "/contents";
                
                byte[] fileContent = Files.readAllBytes(Paths.get(filePath));
                
                HttpRequest contentRequest = createPutRequest(contentUrl, fileContent);
                HttpResponse<String> contentResponse = httpClient.send(contentRequest, HttpResponse.BodyHandlers.ofString());
                
                if (contentResponse.statusCode() != 200) {
                    logger.error("Failed to upload attachment content: " + contentResponse.statusCode());
                }
            } else {
                logger.error("Failed to create attachment metadata: " + metadataResponse.statusCode() + " - " + metadataResponse.body());
            }
        } catch (Exception e) {
            throw new CSSmartException("Failed to upload attachment for test case: " + testCaseId, e);
        }
    }
    
    /**
     * Get test run ID
     * @param testCaseId the test case ID
     * @return the test run ID
     */
    private String getTestRunId(String testCaseId) {
        // This is a simple approach using a memory cache
        // In a real implementation, you might store this in a database or file
        String cacheKey = "testRun_" + testCaseId;
        return config.getProperty(cacheKey);
    }
    
    /**
     * Store test run ID
     * @param testCaseId the test case ID
     * @param testRunId the test run ID
     */
    private void storeTestRunId(String testCaseId, String testRunId) {
        String cacheKey = "testRun_" + testCaseId;
        config.setProperty(cacheKey, testRunId);
    }
    
    /**
     * Map status to ADO outcome
     * @param status the status
     * @return the outcome
     */
    private String mapStatus(String status) {
        switch (status.toLowerCase()) {
            case "passed":
                return "Passed";
            case "failed":
                return "Failed";
            case "skipped":
            case "notexecuted":
                return "NotExecuted";
            case "inprogress":
                return "InProgress";
            case "blocked":
                return "Blocked";
            default:
                return status;
        }
    }
    
    /**
     * Create GET request
     * @param url the URL
     * @return the request
     */
    private HttpRequest createGetRequest(String url) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .GET()
            .build();
    }
    
    /**
     * Create POST request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPostRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Create PATCH request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPatchRequest(String url, String body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .header("Authorization", getAuthHeader())
            .method("PATCH", HttpRequest.BodyPublishers.ofString(body))
            .build();
    }
    
    /**
     * Create PUT request
     * @param url the URL
     * @param body the body
     * @return the request
     */
    private HttpRequest createPutRequest(String url, byte[] body) {
        return HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/octet-stream")
            .header("Authorization", getAuthHeader())
            .PUT(HttpRequest.BodyPublishers.ofByteArray(body))
            .build();
    }
    
    /**
     * Get base URL
     * @return the base URL
     */
    private String getBaseUrl() {
        String url = config.getProperty("ado.url");
        String project = config.getProperty("ado.project");
        
        if (url == null || project == null) {
            throw new CSSmartException("ADO URL or project not configured");
        }
        
        return url + "/" + project + "/_apis";
    }
    
    /**
     * Get authorization header
     * @return the authorization header
     */
    private String getAuthHeader() {
        String token = config.getProperty("ado.token");
        
        if (token == null) {
            throw new CSSmartException("ADO token not configured");
        }
        
        String auth = ":" + token;
        return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Check if ADO integration is enabled
     * @return true if enabled
     */
    private boolean isEnabled() {
        return config.getBooleanProperty("ado.enabled", false);
    }
}

package com.cssmart.ado;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Utility class for working with Azure DevOps from the test framework
 */
public class CSSmartADOUtils {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartConfig config = CSSmartConfig.getInstance();
    private static final CSSmartADOUtils INSTANCE = new CSSmartADOUtils();
    
    private final CSSmartADOIntegration adoIntegration;
    private final String screenshotDir;
    private final String reportDir;
    private final Map<String, String> testResultCache;
    
    /**
     * Private constructor
     */
    private CSSmartADOUtils() {
        adoIntegration = CSSmartADOIntegration.getInstance();
        screenshotDir = config.getProperty("screenshot.dir", "screenshots");
        reportDir = config.getProperty("report.dir", "reports");
        testResultCache = new HashMap<>();
        
        logger.info("Initialized CSSmartADOUtils");
    }
    
    /**
     * Get the singleton instance
     * @return the instance
     */
    public static CSSmartADOUtils getInstance() {
        return INSTANCE;
    }
    
    /**
     * Initialize ADO connection
     * @param url the ADO URL
     * @param project the project name
     * @param token the access token
     */
    public void initializeConnection(String url, String project, String token) {
        config.setProperty("ado.url", url);
        config.setProperty("ado.project", project);
        config.setProperty("ado.token", token);
        config.setProperty("ado.enabled", "true");
        
        logger.info("Initialized ADO connection: " + url + "/" + project);
    }
    
    /**
     * Register test mappings in bulk
     * @param mappings Map of test names to test case IDs
     */
    public void registerTestMappings(Map<String, String> mappings) {
        for (Map.Entry<String, String> entry : mappings.entrySet()) {
            adoIntegration.registerTestCase(
                entry.getKey(), 
                entry.getValue(), 
                true,  // Update results
                true,  // Upload screenshots
                true,  // Upload report
                2,     // Default priority
                "Auto-registered test mapping"
            );
        }
        
        logger.info("Registered " + mappings.size() + " test mappings");
    }
    
    /**
     * Register a test mapping
     * @param testName the test name
     * @param testCaseId the test case ID
     */
    public void registerTestMapping(String testName, String testCaseId) {
        adoIntegration.registerTestCase(
            testName, 
            testCaseId, 
            true,  // Update results
            true,  // Upload screenshots
            true,  // Upload report
            2,     // Default priority
            "Auto-registered test mapping"
        );
        
        logger.info("Registered test mapping: " + testName + " -> " + testCaseId);
    }
    
    /**
     * Register a test mapping with additional options
     * @param testName the test name
     * @param testCaseId the test case ID
     * @param updateResults whether to update results
     * @param uploadScreenshots whether to upload screenshots
     * @param uploadReport whether to upload the report
     * @param priority the priority
     * @param description the description
     */
    public void registerTestMapping(String testName, String testCaseId, boolean updateResults,
                                  boolean uploadScreenshots, boolean uploadReport, int priority,
                                  String description) {
        adoIntegration.registerTestCase(
            testName, 
            testCaseId, 
            updateResults,
            uploadScreenshots,
            uploadReport,
            priority,
            description
        );
        
        logger.info("Registered test mapping with options: " + testName + " -> " + testCaseId);
    }
    
    /**
     * Start a test and update ADO
     * @param testName the test name
     */
    public void startTest(String testName) {
        TestCaseInfo info = adoIntegration.getTestCaseInfo(testName);
        
        if (info != null) {
            String testCaseId = info.getTestCaseId();
            logger.info("Starting test with ADO mapping: " + testName + " -> " + testCaseId);
            
            try {
                adoIntegration.startTestCase(testCaseId);
            } catch (Exception e) {
                logger.error("Failed to start test in ADO: " + testName, e);
            }
        } else {
            logger.debug("No ADO mapping found for test: " + testName);
        }
    }
    
    /**
     * End a test and update ADO with the result
     * @param testName the test name
     * @param status the status (passed, failed, skipped)
     */
    public void endTest(String testName, String status) {
        TestCaseInfo info = adoIntegration.getTestCaseInfo(testName);
        
        if (info != null && info.isUpdateResults()) {
            String testCaseId = info.getTestCaseId();
            logger.info("Ending test with ADO update: " + testName + " -> " + status);
            
            try {
                adoIntegration.updateTestCaseStatus(testCaseId, status);
                
                // Cache the result for later report generation
                testResultCache.put(testName, status);
                
                // Upload screenshots if needed
                if (info.isUploadScreenshots()) {
                    uploadScreenshotsForTest(testName, testCaseId);
                }
                
                // Upload report if needed
                if (info.isUploadReport()) {
                    uploadReportForTest(testName, testCaseId);
                }
            } catch (Exception e) {
                logger.error("Failed to update test result in ADO: " + testName, e);
            }
        } else {
            logger.debug("No ADO mapping found for test: " + testName);
        }
    }
    
    /**
     * Upload screenshots for a test
     * @param testName the test name
     * @param testCaseId the test case ID
     */
    private void uploadScreenshotsForTest(String testName, String testCaseId) {
        try {
            // Find screenshots for this test
            Path screenshotPath = Paths.get(screenshotDir, testName + ".png");
            
            if (java.nio.file.Files.exists(screenshotPath)) {
                logger.info("Uploading screenshot for test: " + testName);
                adoIntegration.uploadScreenshot(testCaseId, screenshotPath.toString(), "Test Screenshot");
            } else {
                logger.debug("No screenshot found for test: " + testName);
            }
        } catch (Exception e) {
            logger.error("Failed to upload screenshots for test: " + testName, e);
        }
    }
    
    /**
     * Upload report for a test
     * @param testName the test name
     * @param testCaseId the test case ID
     */
    private void uploadReportForTest(String testName, String testCaseId) {
        try {
            // Find report for this test
            Path reportPath = Paths.get(reportDir, testName + "-report.html");
            
            if (java.nio.file.Files.exists(reportPath)) {
                logger.info("Uploading report for test: " + testName);
                adoIntegration.uploadTestReport(testCaseId, reportPath.toString());
            } else {
                logger.debug("No report found for test: " + testName);
            }
        } catch (Exception e) {
            logger.error("Failed to upload report for test: " + testName, e);
        }
    }
    
    /**
     * Generate and upload a consolidated report for a test run
     * @param testRunName the test run name
     * @return the path to the generated report
     */
    public String generateAndUploadTestRunReport(String testRunName) {
        try {
            if (testResultCache.isEmpty()) {
                logger.warn("No test results to include in report");
                return null;
            }
            
            // Generate an HTML report
            Path reportPath = Paths.get(reportDir, "test-run-report-" + System.currentTimeMillis() + ".html");
            
            StringBuilder html = new StringBuilder();
            html.append("<!DOCTYPE html>\n");
            html.append("<html>\n");
            html.append("<head>\n");
            html.append("  <title>Test Run Report: ").append(testRunName).append("</title>\n");
            html.append("  <style>\n");
            html.append("    body { font-family: Arial, sans-serif; margin: 20px; }\n");
            html.append("    h1 { color: #333; }\n");
            html.append("    table { border-collapse: collapse; width: 100%; }\n");
            html.append("    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
            html.append("    th { background-color: #f2f2f2; }\n");
            html.append("    .passed { color: green; }\n");
            html.append("    .failed { color: red; }\n");
            html.append("    .skipped { color: orange; }\n");
            html.append("  </style>\n");
            html.append("</head>\n");
            html.append("<body>\n");
            html.append("  <h1>Test Run Report: ").append(testRunName).append("</h1>\n");
            html.append("  <p>Generated on: ").append(java.time.LocalDateTime.now()).append("</p>\n");
            
            // Summary
            int passedCount = 0;
            int failedCount = 0;
            int skippedCount = 0;
            
            for (String status : testResultCache.values()) {
                if (status.equalsIgnoreCase("passed")) {
                    passedCount++;
                } else if (status.equalsIgnoreCase("failed")) {
                    failedCount++;
                } else {
                    skippedCount++;
                }
            }
            
            html.append("  <h2>Summary</h2>\n");
            html.append("  <p>Total Tests: ").append(testResultCache.size()).append("</p>\n");
            html.append("  <p>Passed: ").append(passedCount).append("</p>\n");
            html.append("  <p>Failed: ").append(failedCount).append("</p>\n");
            html.append("  <p>Skipped: ").append(skippedCount).append("</p>\n");
            
            // Test results table
            html.append("  <h2>Test Results</h2>\n");
            html.append("  <table>\n");
            html.append("    <tr><th>Test Name</th><th>Status</th><th>Test Case ID</th></tr>\n");
            
            for (Map.Entry<String, String> entry : testResultCache.entrySet()) {
                String testName = entry.getKey();
                String status = entry.getValue();
                String cssClass = status.equalsIgnoreCase("passed") ? "passed" :
                                status.equalsIgnoreCase("failed") ? "failed" : "skipped";
                
                TestCaseInfo info = adoIntegration.getTestCaseInfo(testName);
                String testCaseId = info != null ? info.getTestCaseId() : "N/A";
                
                html.append("    <tr>\n");
                html.append("      <td>").append(testName).append("</td>\n");
                html.append("      <td class=\"").append(cssClass).append("\">").append(status).append("</td>\n");
                html.append("      <td>").append(testCaseId).append("</td>\n");
                html.append("    </tr>\n");
            }
            
            html.append("  </table>\n");
            html.append("</body>\n");
            html.append("</html>");
            
            // Write to file
            java.nio.file.Files.write(reportPath, html.toString().getBytes());
            
            logger.info("Generated test run report: " + reportPath);
            
            // Upload the report to ADO if needed
            // This would require additional implementation
            
            return reportPath.toString();
        } catch (Exception e) {
            logger.error("Failed to generate test run report", e);
            return null;
        }
    }
    
    /**
     * Get all test plans in a project
     * @return the test plans
     */
    public List<CSSmartADOTestPlan.TestPlanDetails> getAllTestPlans() {
        try {
            // This would need implementation using the ADO API
            // In a real implementation, this would call the ADO API to get all test plans
            throw new CSSmartException("This method is not implemented");
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test plans", e);
        }
    }
    
    /**
     * Set the active test plan
     * @param testPlanId the test plan ID
     */
    public void setActiveTestPlan(String testPlanId) {
        config.setProperty("ado.testplan.id", testPlanId);
        logger.info("Set active test plan: " + testPlanId);
    }
    
    /**
     * Get a test case details by ID
     * @param testCaseId the test case ID
     * @return the test case details
     */
    public CSSmartADOTestCase.TestCaseDetails getTestCaseDetails(String testCaseId) {
        try {
            CSSmartADOTestCase testCase = new CSSmartADOTestCase(testCaseId);
            return testCase.getTestCaseDetails();
        } catch (Exception e) {
            throw new CSSmartException("Failed to get test case details", e);
        }
    }
}


package com.cssmart.ado.cucumber;

import com.cssmart.ado.CSSmartADOIntegration;
import com.cssmart.ado.CSSmartADOUtils;
import com.cssmart.ado.TestCaseInfo;
import com.cssmart.config.CSSmartConfig;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import io.cucumber.core.backend.TestCaseState;
import io.cucumber.plugin.ConcurrentEventListener;
import io.cucumber.plugin.EventListener;
import io.cucumber.plugin.event.*;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Bridge between Cucumber BDD tests and Azure DevOps
 * This plugin handles reporting test results from Cucumber to ADO
 */
public class CSSmartADOCucumberBridge implements ConcurrentEventListener {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartConfig config = CSSmartConfig.getInstance();
    
    private final CSSmartADOIntegration adoIntegration;
    private final CSSmartADOUtils adoUtils;
    private final Map<String, String> scenarioTestCaseMapping = new ConcurrentHashMap<>();
    private final Map<String, String> scenarioResultsCache = new ConcurrentHashMap<>();
    
    /**
     * Constructor
     */
    public CSSmartADOCucumberBridge() {
        this.adoIntegration = CSSmartADOIntegration.getInstance();
        this.adoUtils = CSSmartADOUtils.getInstance();
        logger.info("Initialized CSSmartADOCucumberBridge");
    }
    
    @Override
    public void setEventPublisher(EventPublisher publisher) {
        // Listen for test run start
        publisher.registerHandlerFor(TestRunStarted.class, this::handleTestRunStarted);
        
        // Listen for scenario start
        publisher.registerHandlerFor(TestCaseStarted.class, this::handleTestCaseStarted);
        
        // Listen for scenario end
        publisher.registerHandlerFor(TestCaseFinished.class, this::handleTestCaseFinished);
        
        // Listen for test run end
        publisher.registerHandlerFor(TestRunFinished.class, this::handleTestRunFinished);
    }
    
    /**
     * Handle test run started event
     * @param event the event
     */
    private void handleTestRunStarted(TestRunStarted event) {
        logger.info("Cucumber test run started");
        report.logInfo("Cucumber test run started");
    }
    
    /**
     * Handle test case started event
     * @param event the event
     */
    private void handleTestCaseStarted(TestCaseStarted event) {
        TestCase testCase = event.getTestCase();
        String scenarioName = testCase.getName();
        String featureName = extractFeatureName(testCase);
        
        logger.info("Cucumber scenario started: " + scenarioName);
        report.logInfo("Scenario started: " + scenarioName);
        
        // Check if this scenario is mapped to an ADO test case
        String adoTestCaseId = getADOTestCaseId(testCase);
        
        if (adoTestCaseId != null) {
            // Store the mapping for later use
            String scenarioId = testCase.getId().toString();
            scenarioTestCaseMapping.put(scenarioId, adoTestCaseId);
            
            // Start the test case in ADO
            try {
                adoIntegration.startTestCase(adoTestCaseId);
                logger.info("Started ADO test case: " + adoTestCaseId + " for scenario: " + scenarioName);
            } catch (Exception e) {
                logger.error("Failed to start ADO test case: " + adoTestCaseId, e);
            }
        } else {
            logger.debug("No ADO test case mapping found for scenario: " + scenarioName);
        }
    }
    
    /**
     * Handle test case finished event
     * @param event the event
     */
    private void handleTestCaseFinished(TestCaseFinished event) {
        TestCase testCase = event.getTestCase();
        String scenarioName = testCase.getName();
        String scenarioId = testCase.getId().toString();
        Result result = event.getResult();
        
        // Map cucumber status to ADO status
        String adoStatus = mapCucumberStatusToADO(result.getStatus());
        
        logger.info("Cucumber scenario finished: " + scenarioName + " with status: " + adoStatus);
        report.logInfo("Scenario finished: " + scenarioName + " with status: " + adoStatus);
        
        // Store the result for later reporting
        scenarioResultsCache.put(scenarioName, adoStatus);
        
        // Check if this scenario is mapped to an ADO test case
        String adoTestCaseId = scenarioTestCaseMapping.get(scenarioId);
        
        if (adoTestCaseId != null) {
            // Update the test case in ADO
            try {
                adoIntegration.updateTestCaseStatus(adoTestCaseId, adoStatus);
                logger.info("Updated ADO test case: " + adoTestCaseId + " with status: " + adoStatus);
                
                // Upload screenshots if available
                uploadScreenshotsForScenario(scenarioName, adoTestCaseId);
                
                // If the test failed, add the error details as a comment
                if (result.getStatus() == Status.FAILED && result.getError() != null) {
                    // This would require implementing a method to add comments to ADO test cases
                    // adoUtils.addErrorCommentToTestCase(adoTestCaseId, result.getError().getMessage());
                }
            } catch (Exception e) {
                logger.error("Failed to update ADO test case: " + adoTestCaseId, e);
            }
        } else {
            logger.debug("No ADO test case mapping found for scenario: " + scenarioName);
        }
    }
    
    /**
     * Handle test run finished event
     * @param event the event
     */
    private void handleTestRunFinished(TestRunFinished event) {
        logger.info("Cucumber test run finished with status: " + event.getResult().getStatus());
        report.logInfo("Test run finished with status: " + event.getResult().getStatus());
        
        // Generate and upload consolidated report
        try {
            String reportPath = adoUtils.generateAndUploadTestRunReport("Cucumber Test Run " + UUID.randomUUID().toString());
            logger.info("Generated test run report: " + reportPath);
        } catch (Exception e) {
            logger.error("Failed to generate test run report", e);
        }
    }
    
    /**
     * Extract feature name from test case
     * @param testCase the test case
     * @return the feature name
     */
    private String extractFeatureName(TestCase testCase) {
        return testCase.getUri().toString().replaceAll(".*/(.*)\\.feature", "$1");
    }
    
    /**
     * Get ADO test case ID from cucumber tags
     * @param testCase the test case
     * @return the ADO test case ID or null if not found
     */
    private String getADOTestCaseId(TestCase testCase) {
        // Look for an @ADO-TC tag with the format @ADO-TC1234
        Optional<String> tcTag = testCase.getTags().stream()
            .filter(tag -> tag.startsWith("@ADO-TC"))
            .findFirst();
        
        if (tcTag.isPresent()) {
            return tcTag.get().substring(7); // Extract the ID part after "@ADO-TC"
        }
        
        // Or try to find the mapping in the configuration
        String featureName = extractFeatureName(testCase);
        String scenarioName = testCase.getName();
        String mappingKey = featureName + ":" + scenarioName;
        
        TestCaseInfo info = adoIntegration.getTestCaseInfo(mappingKey);
        if (info != null) {
            return info.getTestCaseId();
        }
        
        return null;
    }
    
    /**
     * Map cucumber status to ADO status
     * @param status the cucumber status
     * @return the ADO status
     */
    private String mapCucumberStatusToADO(Status status) {
        switch (status) {
            case PASSED:
                return "Passed";
            case FAILED:
                return "Failed";
            case SKIPPED:
            case UNDEFINED:
            case PENDING:
                return "NotExecuted";
            default:
                return "InProgress";
        }
    }
    
    /**
     * Upload screenshots for a scenario
     * @param scenarioName the scenario name
     * @param testCaseId the test case ID
     */
    private void uploadScreenshotsForScenario(String scenarioName, String testCaseId) {
        try {
            // Define common screenshot paths that might exist
            String[] possiblePaths = {
                "screenshots/" + scenarioName + ".png",
                "target/screenshots/" + scenarioName + ".png",
                "output/screenshots/" + scenarioName + ".png",
                "screenshots/" + scenarioName.replaceAll("\\s+", "_") + ".png",
                "target/screenshots/" + scenarioName.replaceAll("\\s+", "_") + ".png",
            };
            
            for (String path : possiblePaths) {
                Path screenshotPath = Paths.get(path);
                if (java.nio.file.Files.exists(screenshotPath)) {
                    logger.info("Uploading screenshot for scenario: " + scenarioName);
                    adoIntegration.uploadScreenshot(testCaseId, screenshotPath.toString(), "Screenshot for " + scenarioName);
                    break;
                }
            }
        } catch (Exception e) {
            logger.error("Failed to upload screenshot for scenario: " + scenarioName, e);
        }
    }
    
    /**
     * Register scenario mappings
     * @param mappings map of scenario names to ADO test case IDs
     */
    public static void registerScenarioMappings(Map<String, String> mappings) {
        CSSmartADOUtils adoUtils = CSSmartADOUtils.getInstance();
        
        for (Map.Entry<String, String> entry : mappings.entrySet()) {
            adoUtils.registerTestMapping(entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Register a scenario mapping
     * @param scenarioKey the scenario key (feature:scenario)
     * @param testCaseId the ADO test case ID
     */
    public static void registerScenarioMapping(String scenarioKey, String testCaseId) {
        CSSmartADOUtils adoUtils = CSSmartADOUtils.getInstance();
        adoUtils.registerTestMapping(scenarioKey, testCaseId);
    }
}


package com.cssmart.example;

import com.cssmart.ado.CSSmartADOUtils;
import com.cssmart.elements.CSSmartDriver;
import com.cssmart.elements.CSSmartWebElement;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.junit.jupiter.api.*;
import org.openqa.selenium.By;

import java.util.HashMap;
import java.util.Map;

/**
 * Example test class demonstrating integration with Azure DevOps
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SampleADOTest {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final CSSmartADOUtils adoUtils = CSSmartADOUtils.getInstance();
    
    private static CSSmartDriver driver;
    
    @BeforeAll
    public static void setUp() {
        // Initialize driver
        driver = new CSSmartDriver();
        
        // Initialize ADO connection (these values would be loaded from config in a real test)
        adoUtils.initializeConnection(
            "https://dev.azure.com/organization",
            "project-name",
            "your-ado-access-token"
        );
        
        // Register test mappings
        Map<String, String> testMappings = new HashMap<>();
        testMappings.put("loginWithValidCredentials", "12345");  // Map test name to ADO Test Case ID
        testMappings.put("searchFunctionality", "12346");
        testMappings.put("checkoutProcess", "12347");
        
        adoUtils.registerTestMappings(testMappings);
    }
    
    @AfterAll
    public static void tearDown() {
        // Close driver
        if (driver != null) {
            driver.quit();
        }
        
        // Generate and upload consolidated report
        String reportPath = adoUtils.generateAndUploadTestRunReport("Sample Test Run");
        logger.info("Test run report generated: " + reportPath);
    }
    
    @BeforeEach
    public void beforeEach(TestInfo testInfo) {
        String testName = testInfo.getTestMethod().get().getName();
        logger.info("Starting test: " + testName);
        report.startTest(testName);
        
        // Start the test in ADO
        adoUtils.startTest(testName);
    }
    
    @AfterEach
    public void afterEach(TestInfo testInfo) {
        String testName = testInfo.getTestMethod().get().getName();
        
        // Get test status (in a real test, this would be determined by test success/failure)
        String status = "Passed";
        
        logger.info("Ending test: " + testName + " with status: " + status);
        report.endTest(testName, status);
        
        // Update test status in ADO
        adoUtils.endTest(testName, status);
    }
    
    @Test
    @Order(1)
    @DisplayName("Login with valid credentials")
    public void loginWithValidCredentials() {
        report.logInfo("Testing login functionality with valid credentials");
        
        // Navigate to login page
        driver.get("https://example.com/login");
        
        // Create smart elements with self-healing capabilities
        CSSmartWebElement usernameField = new CSSmartWebElement(driver, By.id("username"), "Username Field");
        CSSmartWebElement passwordField = new CSSmartWebElement(driver, By.id("password"), "Password Field");
        CSSmartWebElement loginButton = new CSSmartWebElement(driver, By.id("login-button"), "Login Button");
        
        // Perform login
        usernameField.sendKeys("testuser");
        passwordField.sendKeys("password123");
        loginButton.click();
        
        // Add alternative locators for self-healing
        usernameField.addAlternativeLocator(By.name("username"));
        usernameField.addAlternativeLocator(By.cssSelector("input[placeholder='Username']"));
        
        // Verify login success
        CSSmartWebElement welcomeMessage = new CSSmartWebElement(driver, By.className("welcome-message"), "Welcome Message");
        Assertions.assertTrue(welcomeMessage.isDisplayed(), "Welcome message should be visible after login");
        
        // Take screenshot for ADO
        driver.takeScreenshot("login-success.png");
        
        report.logPass("Login test passed successfully");
    }
    
    @Test
    @Order(2)
    @DisplayName("Test search functionality")
    public void searchFunctionality() {
        report.logInfo("Testing search functionality");
        
        // Navigate to home page
        driver.get("https://example.com/home");
        
        // Create smart elements with self-healing capabilities
        CSSmartWebElement searchBox = new CSSmartWebElement(driver, By.id("search-box"), "Search Box");
        CSSmartWebElement searchButton = new CSSmartWebElement(driver, By.id("search-button"), "Search Button");
        
        // Perform search
        searchBox.sendKeysWithVerification("test product");
        searchButton.click();
        
        // Verify search results
        CSSmartWebElement searchResults = new CSSmartWebElement(driver, By.className("search-results"), "Search Results");
        Assertions.assertTrue(searchResults.isDisplayed(), "Search results should be visible");
        
        // Take screenshot for ADO
        driver.takeScreenshot("search-results.png");
        
        report.logPass("Search test passed successfully");
    }
    
    @Test
    @Order(3)
    @DisplayName("Test checkout process")
    public void checkoutProcess() {
        report.logInfo("Testing checkout process");
        
        // Navigate to product page
        driver.get("https://example.com/product/123");
        
        // Create smart elements with self-healing capabilities
        CSSmartWebElement addToCartButton = new CSSmartWebElement(driver, By.id("add-to-cart"), "Add to Cart Button");
        CSSmartWebElement checkoutButton = new CSSmartWebElement(driver, By.id("checkout"), "Checkout Button");
        
        // Add product to cart
        addToCartButton.click();
        
        // Wait for cart update
        addToCartButton.waitForInvisibility(5);
        
        // Proceed to checkout
        checkoutButton.click();
        
        // Verify checkout page
        CSSmartWebElement checkoutForm = new CSSmartWebElement(driver, By.id("checkout-form"), "Checkout Form");
        Assertions.assertTrue(checkoutForm.isDisplayed(), "Checkout form should be visible");
        
        // Take screenshot for ADO
        driver.takeScreenshot("checkout-process.png");
        
        report.logPass("Checkout test passed successfully");
    }
}


package com.cssmart.ado.config;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Configuration class for Azure DevOps integration settings
 */
public class ADOConfig {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartConfig config = CSSmartConfig.getInstance();
    private static final String ADO_CONFIG_FILE = "ado-config.properties";
    
    private static final ADOConfig INSTANCE = new ADOConfig();
    
    private Properties adoProperties;
    
    /**
     * Private constructor
     */
    private ADOConfig() {
        loadConfiguration();
    }
    
    /**
     * Get the singleton instance
     * @return the instance
     */
    public static ADOConfig getInstance() {
        return INSTANCE;
    }
    
    /**
     * Load the ADO configuration
     */
    public void loadConfiguration() {
        adoProperties = new Properties();
        
        // Try to load from file if it exists
        Path configPath = Paths.get(ADO_CONFIG_FILE);
        if (Files.exists(configPath)) {
            try (FileInputStream fis = new FileInputStream(configPath.toFile())) {
                adoProperties.load(fis);
                logger.info("Loaded ADO configuration from file: " + configPath.toAbsolutePath());
                
                // Sync with global configuration
                syncWithGlobalConfig();
            } catch (IOException e) {
                logger.error("Failed to load ADO configuration from file", e);
            }
        } else {
            // Try to load from existing global configuration
            loadFromGlobalConfig();
        }
    }
    
    /**
     * Save the ADO configuration
     */
    public void saveConfiguration() {
        try (FileOutputStream fos = new FileOutputStream(ADO_CONFIG_FILE)) {
            adoProperties.store(fos, "Azure DevOps Integration Configuration");
            logger.info("Saved ADO configuration to file: " + Paths.get(ADO_CONFIG_FILE).toAbsolutePath());
            
            // Sync with global configuration
            syncWithGlobalConfig();
        } catch (IOException e) {
            logger.error("Failed to save ADO configuration to file", e);
        }
    }
    
    /**
     * Load from global configuration
     */
    private void loadFromGlobalConfig() {
        adoProperties.setProperty("ado.url", config.getProperty("ado.url", ""));
        adoProperties.setProperty("ado.project", config.getProperty("ado.project", ""));
        adoProperties.setProperty("ado.token", config.getProperty("ado.token", ""));
        adoProperties.setProperty("ado.enabled", config.getProperty("ado.enabled", "false"));
        adoProperties.setProperty("ado.testplan.id", config.getProperty("ado.testplan.id", ""));
        adoProperties.setProperty("ado.upload.screenshots", config.getProperty("ado.upload.screenshots", "true"));
        adoProperties.setProperty("ado.upload.reports", config.getProperty("ado.upload.reports", "true"));
        
        logger.info("Loaded ADO configuration from global config");
    }
    
    /**
     * Sync with global configuration
     */
    private void syncWithGlobalConfig() {
        for (String key : adoProperties.stringPropertyNames()) {
            config.setProperty(key, adoProperties.getProperty(key));
        }
    }
    
    /**
     * Set a property
     * @param key the key
     * @param value the value
     */
    public void setProperty(String key, String value) {
        adoProperties.setProperty(key, value);
        config.setProperty(key, value);
    }
    
    /**
     * Get a property
     * @param key the key
     * @return the value
     */
    public String getProperty(String key) {
        return adoProperties.getProperty(key);
    }
    
    /**
     * Get a property with default value
     * @param key the key
     * @param defaultValue the default value
     * @return the value
     */
    public String getProperty(String key, String defaultValue) {
        return adoProperties.getProperty(key, defaultValue);
    }
    
    /**
     * Get a boolean property
     * @param key the key
     * @param defaultValue the default value
     * @return the value
     */
    public boolean getBooleanProperty(String key, boolean defaultValue) {
        String value = getProperty(key);
        if (value == null) {
            return defaultValue;
        }
        return Boolean.parseBoolean(value);
    }
    
    /**
     * Get an integer property
     * @param key the key
     * @param defaultValue the default value
     * @return the value
     */
    public int getIntProperty(String key, int defaultValue) {
        String value = getProperty(key);
        if (value == null) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(value);
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }
    
    /**
     * Check if ADO integration is enabled
     * @return true if enabled
     */
    public boolean isEnabled() {
        return getBooleanProperty("ado.enabled", false);
    }
    
    /**
     * Get the ADO URL
     * @return the URL
     */
    public String getUrl() {
        return getProperty("ado.url", "");
    }
    
    /**
     * Set the ADO URL
     * @param url the URL
     */
    public void setUrl(String url) {
        setProperty("ado.url", url);
    }
    
    /**
     * Get the ADO project
     * @return the project
     */
    public String getProject() {
        return getProperty("ado.project", "");
    }
    
    /**
     * Set the ADO project
     * @param project the project
     */
    public void setProject(String project) {
        setProperty("ado.project", project);
    }
    
    /**
     * Get the ADO token
     * @return the token
     */
    public String getToken() {
        return getProperty("ado.token", "");
    }
    
    /**
     * Set the ADO token
     * @param token the token
     */
    public void setToken(String token) {
        setProperty("ado.token", token);
    }
    
    /**
     * Get the active test plan ID
     * @return the test plan ID
     */
    public String getTestPlanId() {
        return getProperty("ado.testplan.id", "");
    }
    
    /**
     * Set the active test plan ID
     * @param testPlanId the test plan ID
     */
    public void setTestPlanId(String testPlanId) {
        setProperty("ado.testplan.id", testPlanId);
    }
    
    /**
     * Enable or disable ADO integration
     * @param enabled true to enable
     */
    public void setEnabled(boolean enabled) {
        setProperty("ado.enabled", String.valueOf(enabled));
    }
    
    /**
     * Check if screenshot upload is enabled
     * @return true if enabled
     */
    public boolean isUploadScreenshotsEnabled() {
        return getBooleanProperty("ado.upload.screenshots", true);
    }
    
    /**
     * Enable or disable screenshot upload
     * @param enabled true to enable
     */
    public void setUploadScreenshotsEnabled(boolean enabled) {
        setProperty("ado.upload.screenshots", String.valueOf(enabled));
    }
    
    /**
     * Check if report upload is enabled
     * @return true if enabled
     */
    public boolean isUploadReportsEnabled() {
        return getBooleanProperty("ado.upload.reports", true);
    }
    
    /**
     * Enable or disable report upload
     * @param enabled true to enable
     */
    public void setUploadReportsEnabled(boolean enabled) {
        setProperty("ado.upload.reports", String.valueOf(enabled));
    }
    
    /**
     * Validate the configuration
     * @return true if valid
     */
    public boolean validateConfiguration() {
        boolean valid = true;
        
        if (getUrl().isEmpty()) {
            logger.error("ADO URL is not configured");
            valid = false;
        }
        
        if (getProject().isEmpty()) {
            logger.error("ADO project is not configured");
            valid = false;
        }
        
        if (getToken().isEmpty()) {
            logger.error("ADO token is not configured");
            valid = false;
        }
        
        return valid;
    }
    
    /**
     * Initialize the configuration with default values
     */
    public void initializeWithDefaults() {
        setUrl("https://dev.azure.com/organization");
        setProject("project-name");
        setToken("");
        setEnabled(false);
        setTestPlanId("");
        setUploadScreenshotsEnabled(true);
        setUploadReportsEnabled(true);
        
        saveConfiguration();
    }
}



         */
        public boolean hasResultSets() {
            return !resultSets.isEmpty() && !resultSets.get(0).isEmpty();
        }
        
        /**
         * Check if there are output parameters
         * @return true if there are output parameters
         */
        public boolean hasOutputParameters() {
            return !outputParameters.isEmpty();
        }
    }
}


