package com.cssmart.framework.base;

import com.cssmart.framework.bdd.CSSmartBddTestNGBridge;
import com.cssmart.framework.config.CSSmartConfigManager;
import com.cssmart.framework.driver.CSSmartDriverFactory;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.WebDriver;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

/**
 * Base class for all tests in the CSSmartFramework
 * Handles WebDriver initialization, setup, teardown, and reporting
 */
public abstract class CSSmartBaseTest extends CSSmartBddTestNGBridge {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartBaseTest.class);
    
    // WebDriver instance that will be used by all tests
    protected WebDriver driver;
    
    // Config manager for retrieving framework configuration
    protected CSSmartConfigManager configManager;
    
    /**
     * Initialize config manager before any tests
     */
    @BeforeSuite
    public void setupSuite() {
        configManager = CSSmartConfigManager.getInstance();
        logger.info("Setting up test suite with configuration: " + configManager.getConfigFilePath());
        
        // Set up any suite-level resources or reports
        setupSuiteResources();
    }
    
    /**
     * Initialize WebDriver before each class
     */
    @BeforeClass
    public void setupClass() {
        logger.info("Setting up WebDriver for class: " + getClass().getSimpleName());
        
        // Initialize the WebDriver with configuration properties
        String browser = configManager.getProperty("browser", "chrome");
        boolean headless = Boolean.parseBoolean(configManager.getProperty("headless", "false"));
        
        driver = CSSmartDriverFactory.getDriver(browser, headless);
        
        // Configure WebDriver settings
        configureDriver();
        
        // Register step definitions for BDD bridge
        registerStepDefinitions();
    }
    
    /**
     * Configure WebDriver settings
     */
    protected void configureDriver() {
        // Set implicit wait from configuration
        long implicitWaitSeconds = Long.parseLong(configManager.getProperty("implicitWait", "10"));
        driver.manage().timeouts().implicitlyWait(implicitWaitSeconds, TimeUnit.SECONDS);
        
        // Set page load timeout from configuration
        long pageLoadTimeoutSeconds = Long.parseLong(configManager.getProperty("pageLoadTimeout", "30"));
        driver.manage().timeouts().pageLoadTimeout(pageLoadTimeoutSeconds, TimeUnit.SECONDS);
        
        // Maximize window by default
        driver.manage().window().maximize();
    }
    
    /**
     * Register step definitions for BDD testing
     * Override this in subclasses to register specific step definitions
     */
    protected void registerStepDefinitions() {
        // Base implementation does nothing
        // Subclasses should override to register their step definitions
    }
    
    /**
     * Set up suite resources
     * Override this in subclasses to set up specific suite resources
     */
    protected void setupSuiteResources() {
        // Base implementation does nothing
        // Subclasses should override to set up their suite resources
    }
    
    /**
     * Method executed before each test method
     */
    @BeforeMethod
    public void setupMethod(Method method) {
        logger.info("Starting test: " + method.getName());
        
        // Reset browser state if configured
        if (Boolean.parseBoolean(configManager.getProperty("cleanSessionBeforeTest", "true"))) {
            driver.manage().deleteAllCookies();
        }
        
        // Navigate to base URL if configured
        String baseUrl = configManager.getProperty("baseUrl", "");
        if (!baseUrl.isEmpty()) {
            driver.get(baseUrl);
        }
    }
    
    /**
     * Method executed after each test method
     */
    @AfterMethod
    public void tearDownMethod(ITestResult result) {
        // Capture screenshot on failure if configured
        if (result.getStatus() == ITestResult.FAILURE) {
            if (Boolean.parseBoolean(configManager.getProperty("captureScreenshotOnFailure", "true"))) {
                captureScreenshot(result.getName() + "_failure");
            }
        }
        
        logger.info("Finished test: " + result.getName() + " with status: " + getTestResultStatusName(result.getStatus()));
    }
    
    /**
     * Clean up after all tests in the class
     */
    @AfterClass
    public void tearDownClass() {
        logger.info("Tearing down WebDriver for class: " + getClass().getSimpleName());
        
        // Generate BDD reports if BDD testing was used
        if (Boolean.parseBoolean(configManager.getProperty("generateBddReports", "true"))) {
            String featuresOutputDir = configManager.getProperty("bddFeaturesOutputDir", "target/bdd-features");
            String reportsOutputDir = configManager.getProperty("bddReportsOutputDir", "target/bdd-reports");
            
            generateFeatureFiles(featuresOutputDir);
            generateHTMLReport(reportsOutputDir);
        }
        
        // Quit the WebDriver
        if (driver != null) {
            driver.quit();
            driver = null;
        }
    }
    
    /**
     * Clean up suite resources
     */
    @AfterSuite
    public void tearDownSuite() {
        logger.info("Tearing down test suite");
        
        // Clean up any suite-level resources
        tearDownSuiteResources();
    }
    
    /**
     * Tear down suite resources
     * Override this in subclasses to clean up specific suite resources
     */
    protected void tearDownSuiteResources() {
        // Base implementation does nothing
        // Subclasses should override to clean up their suite resources
    }
    
    /**
     * Capture a screenshot with a specific name
     */
    protected void captureScreenshot(String name) {
        try {
            // Use the CSSmartDriverFactory to capture screenshots
            CSSmartDriverFactory.captureScreenshot(driver, name);
        } catch (Exception e) {
            logger.error("Failed to capture screenshot: " + name, e);
        }
    }
    
    /**
     * Get a human-readable test result status name
     */
    private String getTestResultStatusName(int status) {
        switch (status) {
            case ITestResult.SUCCESS:
                return "SUCCESS";
            case ITestResult.FAILURE:
                return "FAILURE";
            case ITestResult.SKIP:
                return "SKIPPED";
            default:
                return "UNKNOWN";
        }
    }
}


package com.cssmart.framework.driver;

import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.safari.SafariDriver;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * Factory for creating and managing WebDriver instances
 */
public class CSSmartDriverFactory {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartDriverFactory.class);
    
    // Default screenshots directory
    private static final String DEFAULT_SCREENSHOTS_DIR = "target/screenshots";
    
    // Cache of driver capabilities
    private static final Map<String, Object> driverCapabilities = new HashMap<>();
    
    /**
     * Get a WebDriver instance for the specified browser
     */
    public static WebDriver getDriver(String browser, boolean headless) {
        browser = browser.toLowerCase();
        
        logger.info("Creating WebDriver instance for browser: " + browser + ", headless: " + headless);
        
        switch (browser) {
            case "chrome":
                return createChromeDriver(headless);
                
            case "firefox":
                return createFirefoxDriver(headless);
                
            case "edge":
                return createEdgeDriver(headless);
                
            case "safari":
                return createSafariDriver();
                
            default:
                logger.warning("Unsupported browser: " + browser + ". Defaulting to Chrome.");
                return createChromeDriver(headless);
        }
    }
    
    /**
     * Create a ChromeDriver instance
     */
    private static WebDriver createChromeDriver(boolean headless) {
        try {
            ChromeOptions options = new ChromeOptions();
            
            if (headless) {
                options.addArguments("--headless");
            }
            
            // Add common Chrome options
            options.addArguments("--start-maximized");
            options.addArguments("--disable-infobars");
            options.addArguments("--disable-extensions");
            options.addArguments("--disable-notifications");
            options.addArguments("--disable-dev-shm-usage");
            options.addArguments("--no-sandbox");
            
            // Add user-specified capabilities
            Object chromeCapabilities = driverCapabilities.get("chrome");
            if (chromeCapabilities instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> capabilities = (Map<String, Object>) chromeCapabilities;
                capabilities.forEach((key, value) -> {
                    if (value instanceof Boolean) {
                        options.addArguments("--" + key + "=" + value);
                    } else {
                        options.addArguments("--" + key);
                    }
                });
            }
            
            return new ChromeDriver(options);
            
        } catch (Exception e) {
            logger.error("Failed to create ChromeDriver", e);
            throw new RuntimeException("Failed to create ChromeDriver", e);
        }
    }
    
    /**
     * Create a FirefoxDriver instance
     */
    private static WebDriver createFirefoxDriver(boolean headless) {
        try {
            FirefoxOptions options = new FirefoxOptions();
            
            if (headless) {
                options.addArguments("-headless");
            }
            
            // Add user-specified capabilities
            Object firefoxCapabilities = driverCapabilities.get("firefox");
            if (firefoxCapabilities instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> capabilities = (Map<String, Object>) firefoxCapabilities;
                capabilities.forEach(options::setCapability);
            }
            
            return new FirefoxDriver(options);
            
        } catch (Exception e) {
            logger.error("Failed to create FirefoxDriver", e);
            throw new RuntimeException("Failed to create FirefoxDriver", e);
        }
    }
    
    /**
     * Create an EdgeDriver instance
     */
    private static WebDriver createEdgeDriver(boolean headless) {
        try {
            EdgeOptions options = new EdgeOptions();
            
            if (headless) {
                options.addArguments("--headless");
            }
            
            // Add common Edge options
            options.addArguments("--start-maximized");
            options.addArguments("--disable-infobars");
            options.addArguments("--disable-extensions");
            options.addArguments("--disable-notifications");
            
            // Add user-specified capabilities
            Object edgeCapabilities = driverCapabilities.get("edge");
            if (edgeCapabilities instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> capabilities = (Map<String, Object>) edgeCapabilities;
                capabilities.forEach(options::setCapability);
            }
            
            return new EdgeDriver(options);
            
        } catch (Exception e) {
            logger.error("Failed to create EdgeDriver", e);
            throw new RuntimeException("Failed to create EdgeDriver", e);
        }
    }
    
    /**
     * Create a SafariDriver instance
     */
    private static WebDriver createSafariDriver() {
        try {
            return new SafariDriver();
            
        } catch (Exception e) {
            logger.error("Failed to create SafariDriver", e);
            throw new RuntimeException("Failed to create SafariDriver", e);
        }
    }
    
    /**
     * Set custom capabilities for a specific browser
     */
    public static void setDriverCapabilities(String browser, Map<String, Object> capabilities) {
        driverCapabilities.put(browser.toLowerCase(), capabilities);
    }
    
    /**
     * Capture a screenshot and save it to the default directory
     */
    public static String captureScreenshot(WebDriver driver, String name) {
        return captureScreenshot(driver, name, DEFAULT_SCREENSHOTS_DIR);
    }
    
    /**
     * Capture a screenshot and save it to the specified directory
     */
    public static String captureScreenshot(WebDriver driver, String name, String directory) {
        if (!(driver instanceof TakesScreenshot)) {
            logger.warning("Driver does not support taking screenshots");
            return null;
        }
        
        try {
            // Create timestamp for unique filename
            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String filename = name + "_" + timestamp + ".png";
            
            // Create directory if it doesn't exist
            Path dirPath = Paths.get(directory);
            if (!Files.exists(dirPath)) {
                Files.createDirectories(dirPath);
            }
            
            // Capture screenshot
            File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
            
            // Save to specified location
            Path destinationPath = Paths.get(directory, filename);
            Files.copy(screenshotFile.toPath(), destinationPath);
            
            logger.info("Screenshot saved: " + destinationPath.toAbsolutePath());
            return destinationPath.toAbsolutePath().toString();
            
        } catch (Exception e) {
            logger.error("Failed to capture screenshot", e);
            return null;
        }
    }
}


package com.cssmart.framework.config;

import com.cssmart.framework.logging.CSSmartLogger;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Configuration manager for the CSSmartFramework
 * Handles loading and accessing configuration properties
 */
public class CSSmartConfigManager {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartConfigManager.class);
    
    // Default configuration file paths to check
    private static final String[] DEFAULT_CONFIG_PATHS = {
        "cssmart.properties",
        "src/test/resources/cssmart.properties",
        "config/cssmart.properties"
    };
    
    // System property for custom config path
    private static final String CONFIG_PATH_PROPERTY = "cssmart.config";
    
    // Singleton instance
    private static CSSmartConfigManager instance;
    
    // Properties loaded from config file
    private final Properties properties = new Properties();
    
    // Path of the loaded config file
    private String configFilePath;
    
    /**
     * Get the singleton instance of the ConfigManager
     */
    public static synchronized CSSmartConfigManager getInstance() {
        if (instance == null) {
            instance = new CSSmartConfigManager();
        }
        return instance;
    }
    
    /**
     * Private constructor - loads configuration
     */
    private CSSmartConfigManager() {
        loadConfig();
    }
    
    /**
     * Load configuration from properties file
     */
    private void loadConfig() {
        // First check if config file path is specified via system property
        String customPath = System.getProperty(CONFIG_PATH_PROPERTY);
        
        if (customPath != null && !customPath.isEmpty()) {
            if (loadPropertiesFromPath(customPath)) {
                configFilePath = customPath;
                logger.info("Configuration loaded from system property path: " + customPath);
                return;
            } else {
                logger.warning("Failed to load configuration from system property path: " + customPath);
            }
        }
        
        // Try default paths
        for (String path : DEFAULT_CONFIG_PATHS) {
            if (loadPropertiesFromPath(path)) {
                configFilePath = path;
                logger.info("Configuration loaded from default path: " + path);
                return;
            }
        }
        
        // No configuration found - create default
        createDefaultConfig();
    }
    
    /**
     * Load properties from a specific file path
     */
    private boolean loadPropertiesFromPath(String path) {
        try {
            Path configPath = Paths.get(path);
            if (Files.exists(configPath)) {
                try (InputStream input = new FileInputStream(configPath.toFile())) {
                    properties.load(input);
                    return true;
                }
            }
        } catch (IOException e) {
            logger.error("Error loading configuration from path: " + path, e);
        }
        return false;
    }
    
    /**
     * Create default configuration if no config file is found
     */
    private void createDefaultConfig() {
        logger.warning("No configuration file found. Using default settings.");
        
        // Browser settings
        properties.setProperty("browser", "chrome");
        properties.setProperty("headless", "false");
        
        // Timeouts
        properties.setProperty("implicitWait", "10");
        properties.setProperty("pageLoadTimeout", "30");
        properties.setProperty("scriptTimeout", "10");
        
        // Test execution
        properties.setProperty("captureScreenshotOnFailure", "true");
        properties.setProperty("cleanSessionBeforeTest", "true");
        
        // Reporting
        properties.setProperty("generateBddReports", "true");
        properties.setProperty("bddFeaturesOutputDir", "target/bdd-features");
        properties.setProperty("bddReportsOutputDir", "target/bdd-reports");
        
        // AI Features
        properties.setProperty("enableSelfHealing", "true");
        properties.setProperty("selfHealingLog", "target/self-healing-log.json");
        properties.setProperty("aiSentimentAnalysis", "true");
        properties.setProperty("aiPathAnalysis", "true");
        
        configFilePath = "default-in-memory-config";
    }
    
    /**
     * Get a property value
     */
    public String getProperty(String key) {
        return properties.getProperty(key);
    }
    
    /**
     * Get a property value with a default if not found
     */
    public String getProperty(String key, String defaultValue) {
        return properties.getProperty(key, defaultValue);
    }
    
    /**
     * Set a property value
     */
    public void setProperty(String key, String value) {
        properties.setProperty(key, value);
    }
    
    /**
     * Get the path of the loaded config file
     */
    public String getConfigFilePath() {
        return configFilePath;
    }
    
    /**
     * Get a boolean property value
     */
    public boolean getBooleanProperty(String key, boolean defaultValue) {
        String value = getProperty(key);
        if (value == null) {
            return defaultValue;
        }
        return Boolean.parseBoolean(value);
    }
    
    /**
     * Get an integer property value
     */
    public int getIntProperty(String key, int defaultValue) {
        String value = getProperty(key);
        if (value == null) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(value);
        } catch (NumberFormatException e) {
            logger.warning("Invalid integer value for property: " + key + ", using default: " + defaultValue);
            return defaultValue;
        }
    }
    
    /**
     * Get a long property value
     */
    public long getLongProperty(String key, long defaultValue) {
        String value = getProperty(key);
        if (value == null) {
            return defaultValue;
        }
        try {
            return Long.parseLong(value);
        } catch (NumberFormatException e) {
            logger.warning("Invalid long value for property: " + key + ", using default: " + defaultValue);
            return defaultValue;
        }
    }
}


package com.cssmart.framework.base;

import com.cssmart.framework.annotation.CSSmartFindBy;
import com.cssmart.framework.config.CSSmartConfigManager;
import com.cssmart.framework.element.CSSmartWebElement;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.lang.reflect.Field;
import java.time.Duration;
import java.util.List;

/**
 * Base class for all Page Objects in the CSSmartFramework
 * Provides common functionality and handles element initialization
 */
public abstract class CSSmartBasePage {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartBasePage.class);
    
    // WebDriver instance
    protected final WebDriver driver;
    
    // Configuration manager
    protected final CSSmartConfigManager configManager;
    
    // Default wait timeout
    protected final int defaultWaitTimeoutSeconds;
    
    /**
     * Constructor
     */
    public CSSmartBasePage(WebDriver driver) {
        this.driver = driver;
        this.configManager = CSSmartConfigManager.getInstance();
        this.defaultWaitTimeoutSeconds = configManager.getIntProperty("defaultWaitTimeout", 10);
        
        // Initialize page elements
        initElements();
        
        // Verify page is loaded
        isPageLoaded();
    }
    
    /**
     * Initialize elements annotated with @CSSmartFindBy
     */
    protected void initElements() {
        Class<?> clazz = this.getClass();
        
        // Process all fields in the class
        for (Field field : clazz.getDeclaredFields()) {
            // Look for CSSmartFindBy annotation
            CSSmartFindBy annotation = field.getAnnotation(CSSmartFindBy.class);
            
            if (annotation != null && field.getType() == CSSmartWebElement.class) {
                try {
                    // Make field accessible
                    field.setAccessible(true);
                    
                    // Create locator from annotation
                    By locator = createLocatorFromAnnotation(annotation);
                    
                    // Create and set CSSmartWebElement
                    CSSmartWebElement element = new CSSmartWebElement(driver, field.getName(), annotation, locator);
                    field.set(this, element);
                    
                    logger.debug("Initialized element: " + field.getName() + " with locator: " + locator);
                } catch (Exception e) {
                    logger.error("Failed to initialize element: " + field.getName(), e);
                }
            }
        }
    }
    
    /**
     * Create a By locator from the CSSmartFindBy annotation
     */
    private By createLocatorFromAnnotation(CSSmartFindBy annotation) {
        // Try locator strategies in priority order
        if (!annotation.id().isEmpty()) {
            return By.id(annotation.id());
        } else if (!annotation.css().isEmpty()) {
            return By.cssSelector(annotation.css());
        } else if (!annotation.xpath().isEmpty()) {
            return By.xpath(annotation.xpath());
        } else if (!annotation.name().isEmpty()) {
            return By.name(annotation.name());
        } else if (!annotation.className().isEmpty()) {
            return By.className(annotation.className());
        } else if (!annotation.tagName().isEmpty()) {
            return By.tagName(annotation.tagName());
        } else if (!annotation.linkText().isEmpty()) {
            return By.linkText(annotation.linkText());
        } else if (!annotation.partialLinkText().isEmpty()) {
            return By.partialLinkText(annotation.partialLinkText());
        } else {
            // If AI is enabled, try to create a locator from the description
            if (annotation.useAI() && !annotation.description().isEmpty()) {
                return createAILocator(annotation.description());
            } else {
                // Default to a xpath that will fail but allows element to be created
                logger.warning("No locator strategy specified for element. Using fallback locator.");
                return By.xpath("//invalid-fallback-locator");
            }
        }
    }
    
    /**
     * Create a locator using AI from a natural language description
     */
    private By createAILocator(String description) {
        // This would be an implementation of the AI locator generation
        // For now, we'll create a best-guess XPath based on the description
        
        // If description contains "button", look for button elements
        if (description.toLowerCase().contains("button")) {
            return By.xpath("//button[contains(text(),'" + getMainKeyword(description) + "')] | " +
                           "//input[@type='button' and contains(@value,'" + getMainKeyword(description) + "')] | " +
                           "//a[contains(text(),'" + getMainKeyword(description) + "')]");
        }
        
        // If description contains "field" or "input", look for input elements
        if (description.toLowerCase().contains("field") || description.toLowerCase().contains("input")) {
            return By.xpath("//input[contains(@placeholder,'" + getMainKeyword(description) + "')] | " +
                           "//input[contains(@name,'" + getMainKeyword(description) + "')] | " +
                           "//label[contains(text(),'" + getMainKeyword(description) + "')]/following::input[1]");
        }
        
        // If description contains "link", look for anchor elements
        if (description.toLowerCase().contains("link")) {
            return By.xpath("//a[contains(text(),'" + getMainKeyword(description) + "')]");
        }
        
        // If description contains "dropdown" or "select", look for select elements
        if (description.toLowerCase().contains("dropdown") || description.toLowerCase().contains("select")) {
            return By.xpath("//select[contains(@name,'" + getMainKeyword(description) + "')] | " +
                           "//label[contains(text(),'" + getMainKeyword(description) + "')]/following::select[1]");
        }
        
        // Default to a generic search
        return By.xpath("//*[contains(text(),'" + getMainKeyword(description) + "')] | " +
                       "//*[contains(@name,'" + getMainKeyword(description) + "')] | " +
                       "//*[contains(@id,'" + getMainKeyword(description) + "')] | " +
                       "//*[contains(@placeholder,'" + getMainKeyword(description) + "')]");
    }
    
    /**
     * Extract the main keyword from a description
     */
    private String getMainKeyword(String description) {
        // This is a simplified keyword extraction
        // Remove common prefixes and suffixes
        String simplified = description.toLowerCase()
            .replace("the ", "")
            .replace(" field", "")
            .replace(" button", "")
            .replace(" link", "")
            .replace(" dropdown", "")
            .replace(" select", "")
            .replace(" in the", "")
            .replace(" on the", "");
        
        // Split by spaces and get the last word as main keyword
        String[] parts = simplified.split("\\s+");
        if (parts.length > 0) {
            return parts[parts.length - 1];
        }
        
        return "";
    }
    
    /**
     * Check if the page is loaded
     * Override this method in page classes to implement specific page load checks
     */
    public boolean isPageLoaded() {
        // Wait for document ready state by default
        return waitForDocumentReady(defaultWaitTimeoutSeconds);
    }
    
    /**
     * Wait for the document to be in ready state
     */
    protected boolean waitForDocumentReady(int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            
            // Wait for document ready state
            return wait.until((ExpectedCondition<Boolean>) driver -> {
                try {
                    return ((JavascriptExecutor) driver)
                        .executeScript("return document.readyState")
                        .equals("complete");
                } catch (Exception e) {
                    return false;
                }
            });
        } catch (Exception e) {
            logger.warning("Timeout waiting for page to load", e);
            return false;
        }
    }
    
    /**
     * Wait for an element to be visible
     */
    protected WebElement waitForElementVisible(By locator, int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
        } catch (Exception e) {
            logger.warning("Timeout waiting for element to be visible: " + locator, e);
            return null;
        }
    }
    
    /**
     * Wait for an element to be clickable
     */
    protected WebElement waitForElementClickable(By locator, int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            return wait.until(ExpectedConditions.elementToBeClickable(locator));
        } catch (Exception e) {
            logger.warning("Timeout waiting for element to be clickable: " + locator, e);
            return null;
        }
    }
    
    /**
     * Wait for an element to be present in the DOM
     */
    protected WebElement waitForElementPresent(By locator, int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
        } catch (Exception e) {
            logger.warning("Timeout waiting for element to be present: " + locator, e);
            return null;
        }
    }
    
    /**
     * Wait for elements to be present in the DOM
     */
    protected List<WebElement> waitForElementsPresent(By locator, int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            return wait.until(ExpectedConditions.presenceOfAllElementsLocatedBy(locator));
        } catch (Exception e) {
            logger.warning("Timeout waiting for elements to be present: " + locator, e);
            return null;
        }
    }
    
    /**
     * Execute JavaScript
     */
    protected Object executeJavaScript(String script, Object... args) {
        try {
            return ((JavascriptExecutor) driver).executeScript(script, args);
        } catch (Exception e) {
            logger.error("Error executing JavaScript: " + script, e);
            return null;
        }
    }
    
    /**
     * Get the page title
     */
    public String getPageTitle() {
        return driver.getTitle();
    }
    
    /**
     * Get the current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Navigate back
     */
    public void navigateBack() {
        driver.navigate().back();
    }
    
    /**
     * Navigate forward
     */
    public void navigateForward() {
        driver.navigate().forward();
    }
    
    /**
     * Refresh the page
     */
    public void refreshPage() {
        driver.navigate().refresh();
    }
}


package com.cssmart.example;

import com.cssmart.framework.annotation.*;
import com.cssmart.framework.ai.CSSmartAITestRecommender;
import com.cssmart.framework.base.CSSmartBasePage;
import com.cssmart.framework.base.CSSmartBaseTest;
import com.cssmart.framework.element.CSSmartWebElement;
import com.cssmart.framework.enums.*;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.WebDriver;
import org.testng.Assert;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;

/**
 * Example showing how to use the CSSmartFramework with all its AI-powered features
 * Extends CSSmartBaseTest to get all the base functionality
 */
public class CSSmartFrameworkExample extends CSSmartBaseTest {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartFrameworkExample.class);
    
    /**
     * Initialize step definitions for BDD
     */
    @Override
    protected void registerStepDefinitions() {
        registerStepDefinitions(new LoginSteps(driver), new HomePageSteps(driver));
    }
    
    /**
     * Example test using CSSmartFindBy with AI-powered element location
     */
    @Test
    public void testAIElementLocation() {
        driver.get("https://example.com/login");
        
        // Access a page with CSSmartFindBy elements
        LoginPage loginPage = new LoginPage(driver);
        
        // Use self-healing elements
        loginPage.enterUsername("testuser");
        loginPage.enterPassword("password");
        loginPage.clickLogin();
        
        // Assert that login was successful
        HomePage homePage = new HomePage(driver);
        Assert.assertTrue(homePage.isWelcomeMessageDisplayed(), "Login failed");
    }
    
    /**
     * Example test using AI-powered data generation and smart test step
     */
    @CSSmartTestStep(
        description = "I test login with generated data", 
        category = StepCategory.ACTION, 
        importance = Importance.CRITICAL,
        takeScreenshot = ScreenshotType.BEFORE_AND_AFTER
    )
    @CSSmartDataProvider(
        type = DataSourceType.SMART_GENERATION,
        targetForm = "loginForm",
        coverage = Coverage.COMPREHENSIVE,
        constraints = {
            @Constraint(field = "username", type = "string"),
            @Constraint(field = "password", type = "string", min = "8")
        }
    )
    @Test
    public void testLoginWithGeneratedData(Map<String, Object> data) {
        driver.get("https://example.com/login");
        
        LoginPage loginPage = new LoginPage(driver);
        
        // Use the generated data
        loginPage.enterUsername((String) data.get("username"));
        loginPage.enterPassword((String) data.get("password"));
        loginPage.clickLogin();
        
        // Assert that login was successful if using valid data
        if (data.containsKey("valid") && (Boolean) data.get("valid")) {
            HomePage homePage = new HomePage(driver);
            Assert.assertTrue(homePage.isWelcomeMessageDisplayed(), "Login failed with valid data");
        } else {
            // Assert that error message is displayed for invalid data
            Assert.assertTrue(loginPage.isErrorMessageDisplayed(), "No error message for invalid data");
        }
    }
    
    /**
     * Example test using BDD-TestNG bridge
     */
    @CSSmartScenario(
        feature = "User Authentication",
        scenario = "Login with valid credentials",
        steps = {
            "Given I am on the login page",
            "When I enter valid user credentials",
            "And I click the login button",
            "Then I should be logged in successfully"
        },
        tags = {"smoke", "authentication"}
    )
    @Test
    public void testLoginWithBdd() {
        // The framework will execute the BDD steps
        // No code needed here as the steps are defined in the step classes
    }
    
    /**
     * Example test using AI test path analyzer
     */
    @Test
    public void testAIPathAnalysis() {
        driver.get("https://example.com");
        
        // Use the AI test recommender to find optimal test paths
        CSSmartAITestRecommender recommender = new CSSmartAITestRecommender();
        List<CSSmartAITestRecommender.TestPath> optimalPaths = recommender.findOptimalTestPaths(driver, "https://example.com");
        
        // Find edge cases
        List<CSSmartAITestRecommender.EdgeCase> edgeCases = recommender.identifyEdgeCases(optimalPaths);
        
        // Perform risk analysis
        List<CSSmartAITestRecommender.RiskAnalysis> riskAnalyses = recommender.performRiskAnalysis(optimalPaths);
        
        // Log the results
        logger.info("Found " + optimalPaths.size() + " optimal test paths");
        logger.info("Identified " + edgeCases.size() + " edge cases");
        logger.info("Completed risk analysis for " + riskAnalyses.size() + " paths");
        
        // Execute the highest priority test path
        if (!optimalPaths.isEmpty()) {
            CSSmartAITestRecommender.TestPath topPath = optimalPaths.get(0);
            logger.info("Executing highest priority path: " + topPath.getName());
            
            // In a real implementation, we'd execute the path actions here
        }
    }
    
    /**
     * Example test using sentiment analysis
     */
    @CSSmartDataProvider(
        type = DataSourceType.JSON,
        path = "user-comments.json",
        preprocessing = {
            @Transformation(type = TransformType.SENTIMENT_ANALYSIS, fields = {"comment"})
        },
        filtering = "@sentiment.comment > 0.5"
    )
    @Test
    public void testUserProfileWithSentimentData(Map<String, Object> userData) {
        // This test would only run with positive sentiment comments
        driver.get("https://example.com/profile");
        
        // Access the sentiment scores
        @SuppressWarnings("unchecked")
        Map<String, Double> sentiment = (Map<String, Double>) userData.get("@sentiment");
        double commentSentiment = sentiment.get("comment");
        
        logger.info("Testing with positive comment (sentiment: " + commentSentiment + ")");
        
        // Use the data for testing
        ProfilePage profilePage = new ProfilePage(driver);
        profilePage.enterComment((String) userData.get("comment"));
        profilePage.submitComment();
        
        // Assert the comment was posted
        Assert.assertTrue(profilePage.isCommentPosted(), "Comment was not posted");
    }
    
    /**
     * Example test using accessibility analysis
     */
    @Test
    public void testAccessibility() {
        driver.get("https://example.com");
        
        // Perform accessibility analysis
        CSSmartAITestRecommender recommender = new CSSmartAITestRecommender();
        CSSmartAITestRecommender.AccessibilityAnalysis analysis = recommender.analyzeAccessibility(driver, "AA");
        
        // Log the results
        logger.info("Accessibility compliance score: " + analysis.getComplianceScore() + "/100");
        logger.info("Compliance status: " + analysis.getComplianceStatus());
        logger.info("Found " + analysis.getIssues().size() + " accessibility issues");
        
        // Assert a minimum compliance score
        Assert.assertTrue(analysis.getComplianceScore() >= 70, 
            "Accessibility score below threshold: " + analysis.getComplianceScore());
    }
}

/**
 * Example login page extending CSSmartBasePage
 */
class LoginPage extends CSSmartBasePage {
    
    @CSSmartFindBy(
        description = "Username field in the login form", 
        useAI = true,
        contextAware = true,
        fingerprint = true,
        failureHandling = FailureHandling.SELF_HEAL,
        priority = {LocatorStrategy.SEMANTIC, LocatorStrategy.DOM, LocatorStrategy.VISUAL},
        alternateLocators = {
            @AlternateLocator(id = "username"),
            @AlternateLocator(name = "username"),
            @AlternateLocator(css = "input[type='text']")
        }
    )
    private CSSmartWebElement usernameField;
    
    @CSSmartFindBy(
        description = "Password field in the login form", 
        useAI = true,
        contextAware = true,
        fingerprint = true,
        failureHandling = FailureHandling.SELF_HEAL,
        priority = {LocatorStrategy.SEMANTIC, LocatorStrategy.DOM, LocatorStrategy.VISUAL},
        alternateLocators = {
            @AlternateLocator(id = "password"),
            @AlternateLocator(name = "password"),
            @AlternateLocator(css = "input[type='password']")
        }
    )
    private CSSmartWebElement passwordField;
    
    @CSSmartFindBy(
        description = "Login button on the login form", 
        useAI = true,
        contextAware = true,
        fingerprint = true,
        failureHandling = FailureHandling.SELF_HEAL,
        priority = {LocatorStrategy.SEMANTIC, LocatorStrategy.DOM, LocatorStrategy.VISUAL},
        alternateLocators = {
            @AlternateLocator(id = "login-button"),
            @AlternateLocator(css = "button[type='submit']"),
            @AlternateLocator(xpath = "//button[contains(text(), 'Login')]")
        }
    )
    private CSSmartWebElement loginButton;
    
    @CSSmartFindBy(
        description = "Error message on the login form", 
        useAI = true,
        failureHandling = FailureHandling.CONTINUE
    )
    private CSSmartWebElement errorMessage;
    
    public LoginPage(WebDriver driver) {
        super(driver);
    }
    
    /**
     * Override isPageLoaded to verify specific elements for this page
     */
    @Override
    public boolean isPageLoaded() {
        // Wait for the base page to load first
        if (!super.isPageLoaded()) {
            return false;
        }
        
        // Wait for specific elements that indicate this page is loaded
        return waitForElementVisible(usernameField.getLocator(), defaultWaitTimeoutSeconds) != null &&
               waitForElementVisible(passwordField.getLocator(), defaultWaitTimeoutSeconds) != null &&
               waitForElementVisible(loginButton.getLocator(), defaultWaitTimeoutSeconds) != null;
    }
    
    public void enterUsername(String username) {
        usernameField.smartWait().clear();
        usernameField.sendKeys(username);
    }
    
    public void enterPassword(String password) {
        passwordField.smartWait().clear();
        passwordField.sendKeys(password);
    }
    
    public void clickLogin() {
        loginButton.smartWait().click();
    }
    
    public boolean isErrorMessageDisplayed() {
        try {
            return errorMessage.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * Example home page extending CSSmartBasePage
 */
class HomePage extends CSSmartBasePage {
    
    @CSSmartFindBy(
        description = "Welcome message on the home page", 
        useAI = true,
        failureHandling = FailureHandling.SELF_HEAL
    )
    private CSSmartWebElement welcomeMessage;
    
    public HomePage(WebDriver driver) {
        super(driver);
    }
    
    /**
     * Override isPageLoaded to verify specific elements for this page
     */
    @Override
    public boolean isPageLoaded() {
        // Wait for the base page to load first
        if (!super.isPageLoaded()) {
            return false;
        }
        
        // Wait for specific elements that indicate this page is loaded
        return waitForElementVisible(welcomeMessage.getLocator(), defaultWaitTimeoutSeconds) != null;
    }
    
    public boolean isWelcomeMessageDisplayed() {
        try {
            return welcomeMessage.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * Example profile page extending CSSmartBasePage
 */
class ProfilePage extends CSSmartBasePage {
    
    @CSSmartFindBy(
        description = "Comment field on the profile page", 
        useAI = true,
        failureHandling = FailureHandling.SELF_HEAL
    )
    private CSSmartWebElement commentField;
    
    @CSSmartFindBy(
        description = "Submit comment button", 
        useAI = true,
        failureHandling = FailureHandling.SELF_HEAL
    )
    private CSSmartWebElement submitButton;
    
    @CSSmartFindBy(
        description = "Posted comment confirmation", 
        useAI = true,
        failureHandling = FailureHandling.CONTINUE
    )
    private CSSmartWebElement postedComment;
    
    public ProfilePage(WebDriver driver) {
        super(driver);
    }
    
    /**
     * Override isPageLoaded to verify specific elements for this page
     */
    @Override
    public boolean isPageLoaded() {
        // Wait for the base page to load first
        if (!super.isPageLoaded()) {
            return false;
        }
        
        // Wait for specific elements that indicate this page is loaded
        return waitForElementVisible(commentField.getLocator(), defaultWaitTimeoutSeconds) != null &&
               waitForElementVisible(submitButton.getLocator(), defaultWaitTimeoutSeconds) != null;
    }
    
    public void enterComment(String comment) {
        commentField.smartWait().clear();
        commentField.sendKeys(comment);
    }
    
    public void submitComment() {
        submitButton.smartWait().click();
    }
    
    public boolean isCommentPosted() {
        try {
            return postedComment.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * Example BDD step definitions for login
 */
class LoginSteps {
    private final WebDriver driver;
    private LoginPage loginPage;
    
    public LoginSteps(WebDriver driver) {
        this.driver = driver;
    }
    
    @CSSmartTestStep(description = "I am on the login page")
    public void navigateToLoginPage() {
        driver.get("https://example.com/login");
        loginPage = new LoginPage(driver);
    }
    
    @CSSmartTestStep(description = "I enter valid user credentials")
    public void enterValidCredentials() {
        loginPage.enterUsername("testuser");
        loginPage.enterPassword("password");
    }
    
    @CSSmartTestStep(description = "I click the login button")
    public void clickLoginButton() {
        loginPage.clickLogin();
    }
}

/**
 * Example BDD step definitions for home page
 */
class HomePageSteps {
    private final WebDriver driver;
    private HomePage homePage;
    
    public HomePageSteps(WebDriver driver) {
        this.driver = driver;
    }
    
    @CSSmartTestStep(description = "I should be logged in successfully")
    public void verifySuccessfulLogin() {
        homePage = new HomePage(driver);
        Assert.assertTrue(homePage.isWelcomeMessageDisplayed(), "Login was not successful");
    }
}

package com.cssmart.framework.selfhealing;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.JavascriptExecutor;
import com.cssmart.framework.exceptions.ElementNotFoundException;
import com.cssmart.framework.logging.LogManager;
import com.cssmart.framework.utils.StringSimilarityUtil;

/**
 * Implements a semantic healing strategy using text content analysis
 * to identify elements based on semantic similarity
 */
public class SemanticHealingStrategy implements ElementHealingStrategy {
    private static final LogManager logger = LogManager.getLogger(SemanticHealingStrategy.class);
    // Minimum threshold for text similarity score (0-1)
    private static final double TEXT_SIMILARITY_THRESHOLD = 0.7;
    // Maximum elements to consider per healing attempt
    private static final int MAX_CANDIDATES = 10;
    
    @Override
    public WebElement findElement(WebDriver driver, ElementData originalElementData) {
        logger.debug("Applying semantic healing strategy");
        
        // Collect all potential matching elements first
        List<CandidateElement> candidates = new ArrayList<>();
        
        try {
            // If we have text content from the original element, use it as primary matcher
            if (originalElementData.getTextContent() != null && !originalElementData.getTextContent().isEmpty()) {
                candidates.addAll(findElementsByTextSimilarity(driver, originalElementData));
            }
            
            // If we have label or aria attributes, use them for semantic matching
            if (originalElementData.hasSemanticAttributes()) {
                candidates.addAll(findElementsBySemanticAttributes(driver, originalElementData));
            }
            
            // If we have contextual elements, use them for proximity analysis
            if (originalElementData.hasContextualInfo()) {
                candidates.addAll(findElementsByContextualProximity(driver, originalElementData));
            }
            
            // Score and sort candidates
            if (!candidates.isEmpty()) {
                CandidateElement bestMatch = rankAndSelectBestCandidate(candidates);
                logger.info("Semantic healing found element with confidence: " + bestMatch.getScore());
                return bestMatch.getElement();
            }
        } catch (Exception e) {
            logger.error("Error in semantic healing strategy", e);
        }
        
        logger.debug("Semantic healing strategy failed to find element");
        return null;
    }
    
    /**
     * Finds elements with similar text content to the original element
     */
    private List<CandidateElement> findElementsByTextSimilarity(WebDriver driver, ElementData originalElementData) {
        String originalText = originalElementData.getTextContent().trim();
        String tagName = originalElementData.getTagName() != null ? 
                         originalElementData.getTagName().toLowerCase() : "*";
        
        List<CandidateElement> candidates = new ArrayList<>();
        
        // First try exact text match
        try {
            List<WebElement> exactMatches = driver.findElements(By.xpath(
                    "//" + tagName + "[normalize-space(text())='" + escapeXPathValue(originalText) + "']"));
            
            for (WebElement element : exactMatches) {
                candidates.add(new CandidateElement(element, 1.0));
            }
        } catch (Exception e) {
            logger.debug("Error finding exact text matches", e);
        }
        
        // If no exact matches, try to find elements with similar text
        if (candidates.isEmpty()) {
            try {
                // Get all elements with any text
                List<WebElement> allTextElements = driver.findElements(By.xpath(
                        "//" + tagName + "[string-length(normalize-space(text())) > 0]"));
                
                for (WebElement element : allTextElements) {
                    String elementText = element.getText().trim();
                    double similarity = StringSimilarityUtil.calculateSimilarity(originalText, elementText);
                    
                    if (similarity >= TEXT_SIMILARITY_THRESHOLD) {
                        candidates.add(new CandidateElement(element, similarity));
                    }
                    
                    // Limit the number of candidates to prevent performance issues
                    if (candidates.size() >= MAX_CANDIDATES) {
                        break;
                    }
                }
            } catch (Exception e) {
                logger.debug("Error finding similar text matches", e);
            }
        }
        
        return candidates;
    }
    
    /**
     * Finds elements with matching semantic attributes (aria labels, placeholder, title)
     */
    private List<CandidateElement> findElementsBySemanticAttributes(WebDriver driver, ElementData originalElementData) {
        List<CandidateElement> candidates = new ArrayList<>();
        Map<String, String> semanticAttributes = originalElementData.getSemanticAttributes();
        
        if (semanticAttributes.isEmpty()) {
            return candidates;
        }
        
        String tagName = originalElementData.getTagName() != null ? 
                         originalElementData.getTagName().toLowerCase() : "*";
        
        // Build XPath predicates for semantic attributes
        for (Map.Entry<String, String> entry : semanticAttributes.entrySet()) {
            String attrName = entry.getKey();
            String attrValue = escapeXPathValue(entry.getValue());
            
            try {
                // Try exact attribute match
                List<WebElement> exactMatches = driver.findElements(By.xpath(
                        "//" + tagName + "[@" + attrName + "='" + attrValue + "']"));
                
                for (WebElement element : exactMatches) {
                    candidates.add(new CandidateElement(element, 0.9)); // High but not perfect score
                }
                
                // Try contains for longer attributes
                if (attrValue.length() > 10) {
                    List<WebElement> containsMatches = driver.findElements(By.xpath(
                            "//" + tagName + "[contains(@" + attrName + ", '" + attrValue + "')]"));
                    
                    for (WebElement element : containsMatches) {
                        if (!exactMatches.contains(element)) {
                            candidates.add(new CandidateElement(element, 0.8));
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error finding semantic attribute matches for " + attrName, e);
            }
        }
        
        return candidates;
    }
    
    /**
     * Finds elements based on their contextual proximity to other known elements
     */
    private List<CandidateElement> findElementsByContextualProximity(WebDriver driver, ElementData originalElementData) {
        List<CandidateElement> candidates = new ArrayList<>();
        
        // Use JavaScript to analyze DOM proximity if contextual elements are available
        try {
            if (originalElementData.getParentTextContent() != null && !originalElementData.getParentTextContent().isEmpty()) {
                String parentText = originalElementData.getParentTextContent().trim();
                String tagName = originalElementData.getTagName() != null ? 
                                originalElementData.getTagName().toLowerCase() : "*";
                
                // Find elements that are children of elements with similar text
                List<WebElement> contextuallySimilar = driver.findElements(By.xpath(
                        "//*[contains(normalize-space(text()), '" + escapeXPathValue(parentText) + "')]//" + tagName));
                
                for (WebElement element : contextuallySimilar) {
                    candidates.add(new CandidateElement(element, 0.7));
                }
            }
            
            // Use sibling text if available
            if (originalElementData.getSiblingTextContent() != null && !originalElementData.getSiblingTextContent().isEmpty()) {
                String siblingText = originalElementData.getSiblingTextContent().trim();
                String tagName = originalElementData.getTagName() != null ? 
                                originalElementData.getTagName().toLowerCase() : "*";
                
                // Find elements that are siblings of elements with similar text
                List<WebElement> siblingContextual = driver.findElements(By.xpath(
                        "//*[contains(normalize-space(text()), '" + escapeXPathValue(siblingText) + "')]/following-sibling::" + tagName +
                        " | //*[contains(normalize-space(text()), '" + escapeXPathValue(siblingText) + "')]/preceding-sibling::" + tagName));
                
                for (WebElement element : siblingContextual) {
                    candidates.add(new CandidateElement(element, 0.65));
                }
            }
        } catch (Exception e) {
            logger.debug("Error finding contextual proximity matches", e);
        }
        
        return candidates;
    }
    
    /**
     * Ranks all candidates and selects the best match
     */
    private CandidateElement rankAndSelectBestCandidate(List<CandidateElement> candidates) {
        // Sort by score descending
        Collections.sort(candidates, Comparator.comparing(CandidateElement::getScore).reversed());
        
        // Return the highest scoring candidate
        return candidates.get(0);
    }
    
    /**
     * Escapes special characters in XPath string values
     */
    private String escapeXPathValue(String value) {
        if (value == null) return "";
        
        // Check if value contains both single and double quotes
        if (value.contains("'") && value.contains("\"")) {
            // Use concat() for complex strings with mixed quotes
            StringBuilder sb = new StringBuilder("concat(");
            boolean isFirst = true;
            
            for (int i = 0; i < value.length(); i++) {
                char c = value.charAt(i);
                if (c == '\'') {
                    if (!isFirst) sb.append(", ");
                    sb.append("\"'\", ");
                    isFirst = false;
                } else {
                    if (isFirst) {
                        sb.append("'");
                        isFirst = false;
                    } else if (i > 0 && value.charAt(i-1) == '\'') {
                        sb.append("'");
                    }
                    sb.append(c);
                }
            }
            
            if (!isFirst) sb.append("'");
            sb.append(")");
            return sb.toString();
        } else if (value.contains("'")) {
            // If only single quotes are present, use double quotes
            return "\"" + value + "\"";
        } else {
            // Default case, use single quotes
            return "'" + value + "'";
        }
    }
    
    /**
     * Internal class to represent and rank candidate elements
     */
    private static class CandidateElement {
        private final WebElement element;
        private final double score;
        
        public CandidateElement(WebElement element, double score) {
            this.element = element;
            this.score = score;
        }
        
        public WebElement getElement() {
            return element;
        }
        
        public double getScore() {
            return score;
        }
    }
}

package com.cssmart.framework.selfhealing;

import java.util.*;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.JavascriptExecutor;
import com.cssmart.framework.exceptions.ElementNotFoundException;
import com.cssmart.framework.logging.LogManager;

/**
 * Implements a DOM-based healing strategy that uses structural patterns
 * and DOM hierarchy analysis to identify elements
 */
public class DomHealingStrategy implements ElementHealingStrategy {
    private static final LogManager logger = LogManager.getLogger(DomHealingStrategy.class);
    // Weights for different DOM properties in similarity calculation
    private static final double ATTRIBUTE_WEIGHT = 0.4;
    private static final double STRUCTURE_WEIGHT = 0.5;
    private static final double POSITION_WEIGHT = 0.1;
    // Minimum threshold for overall similarity score (0-1)
    private static final double SIMILARITY_THRESHOLD = 0.6;
    
    @Override
    public WebElement findElement(WebDriver driver, ElementData originalElementData) {
        logger.debug("Applying DOM healing strategy");
        
        if (originalElementData.getDomPath() == null) {
            logger.debug("No DOM path available for healing");
            return null;
        }
        
        try {
            // Try to find element based on DOM fingerprint
            WebElement element = findElementByDomFingerprint(driver, originalElementData);
            if (element != null) {
                logger.info("DOM fingerprint match found");
                return element;
            }
            
            // Try to find element based on CSS path
            element = findElementByCssPathVariations(driver, originalElementData);
            if (element != null) {
                logger.info("CSS path variation match found");
                return element;
            }
            
            // Try to find element by attribute signature
            element = findElementByAttributeSignature(driver, originalElementData);
            if (element != null) {
                logger.info("Attribute signature match found");
                return element;
            }
            
            // Try to find element by structural analysis
            element = findElementByStructuralAnalysis(driver, originalElementData);
            if (element != null) {
                logger.info("Structural analysis match found");
                return element;
            }
            
        } catch (Exception e) {
            logger.error("Error in DOM healing strategy", e);
        }
        
        logger.debug("DOM healing strategy failed to find element");
        return null;
    }
    
    /**
     * Finds an element using its DOM fingerprint (a unique structure-based identifier)
     */
    private WebElement findElementByDomFingerprint(WebDriver driver, ElementData originalElementData) {
        String domFingerprint = generateDomFingerprint(originalElementData);
        
        if (domFingerprint == null || domFingerprint.isEmpty()) {
            return null;
        }
        
        // Execute JavaScript to find element by DOM fingerprint
        String script = 
            "function findByFingerprint(fingerprint) {" +
            "  const allElements = document.getElementsByTagName('*');" +
            "  for (let i = 0; i < allElements.length; i++) {" +
            "    const element = allElements[i];" +
            "    const elementFingerprint = generateFingerprint(element);" +
            "    if (elementFingerprint === fingerprint) {" +
            "      return element;" +
            "    }" +
            "  }" +
            "  return null;" +
            "}" +
            
            "function generateFingerprint(element) {" +
            "  if (!element) return '';" +
            "  const tagName = element.tagName.toLowerCase();" +
            "  const classNames = element.className ? Array.from(element.classList).join('.') : '';" +
            "  const id = element.id ? '#' + element.id : '';" +
            "  const attributeCount = element.attributes.length;" +
            "  const childrenCount = element.children.length;" +
            "  const textLength = element.textContent ? element.textContent.trim().length : 0;" +
            "  return `${tagName}${id}${classNames}:${attributeCount}:${childrenCount}:${textLength}`;" +
            "}" +
            
            "return findByFingerprint(arguments[0]);";
        
        try {
            WebElement element = (WebElement) ((JavascriptExecutor) driver).executeScript(script, domFingerprint);
            return element;
        } catch (Exception e) {
            logger.debug("Error finding element by DOM fingerprint", e);
            return null;
        }
    }
    
    /**
     * Generates a DOM fingerprint from ElementData
     */
    private String generateDomFingerprint(ElementData data) {
        StringBuilder fingerprint = new StringBuilder();
        
        try {
            // Add tag name
            fingerprint.append(data.getTagName().toLowerCase());
            
            // Add ID if present
            if (data.getAttributes().containsKey("id")) {
                fingerprint.append("#").append(data.getAttributes().get("id"));
            }
            
            // Add classes if present
            if (data.getAttributes().containsKey("class")) {
                String[] classes = data.getAttributes().get("class").split("\\s+");
                Arrays.sort(classes); // Sort to make fingerprint more stable
                for (String cls : classes) {
                    if (!cls.isEmpty()) {
                        fingerprint.append(".").append(cls);
                    }
                }
            }
            
            // Add attribute count, children count and text length
            fingerprint.append(":").append(data.getAttributes().size());
            fingerprint.append(":").append(data.getChildrenCount());
            
            String textContent = data.getTextContent();
            int textLength = textContent != null ? textContent.trim().length() : 0;
            fingerprint.append(":").append(textLength);
            
            return fingerprint.toString();
        } catch (Exception e) {
            logger.debug("Error generating DOM fingerprint", e);
            return null;
        }
    }
    
    /**
     * Finds an element by trying variations of its CSS path
     */
    private WebElement findElementByCssPathVariations(WebDriver driver, ElementData originalElementData) {
        String cssPath = originalElementData.getDomPath();
        
        if (cssPath == null || !cssPath.startsWith("css=")) {
            return null;
        }
        
        cssPath = cssPath.substring(4); // Remove "css=" prefix
        List<String> variations = generateCssPathVariations(cssPath);
        
        // Try each variation
        for (String variation : variations) {
            try {
                List<WebElement> elements = driver.findElements(By.cssSelector(variation));
                if (!elements.isEmpty()) {
                    return elements.get(0);
                }
            } catch (Exception e) {
                // Continue with next variation
            }
        }
        
        return null;
    }
    
    /**
     * Generates CSS path variations by simplifying and generalizing the original path
     */
    private List<String> generateCssPathVariations(String originalPath) {
        List<String> variations = new ArrayList<>();
        
        // Add original path first
        variations.add(originalPath);
        
        try {
            // Remove positional selectors (e.g., :nth-child(3) -> "")
            String withoutPositional = originalPath.replaceAll(":\\s*nth-child\\([0-9]+\\)", "");
            if (!withoutPositional.equals(originalPath)) {
                variations.add(withoutPositional);
            }
            
            // Extract class-based selectors
            List<String> classSelectors = new ArrayList<>();
            String[] parts = originalPath.split("\\s+");
            for (String part : parts) {
                if (part.contains(".")) {
                    String tagWithClass = part.split(":", 2)[0]; // Remove any pseudo-selectors
                    if (!tagWithClass.equals(part)) {
                        variations.add(tagWithClass);
                    }
                    
                    // Extract individual classes for this selector
                    int tagEnd = tagWithClass.indexOf(".");
                    if (tagEnd > 0) {
                        String tag = tagWithClass.substring(0, tagEnd);
                        String[] classes = tagWithClass.substring(tagEnd).split("\\.");
                        
                        for (int i = 1; i < classes.length; i++) { // Start at 1 to skip empty string before first dot
                            if (!classes[i].isEmpty()) {
                                classSelectors.add(tag + "." + classes[i]);
                            }
                        }
                    }
                }
            }
            
            // Add individual class selectors as variations
            variations.addAll(classSelectors);
            
            // Create a simplified path with just the tag name and id/class (if available)
            if (parts.length > 0) {
                String lastPart = parts[parts.length - 1];
                
                // Extract tag name
                String tagName = lastPart.split("[.#:]", 2)[0];
                
                // Extract ID if present
                String id = "";
                int idStart = lastPart.indexOf("#");
                if (idStart >= 0) {
                    int idEnd = lastPart.indexOf(".", idStart);
                    if (idEnd < 0) idEnd = lastPart.indexOf(":", idStart);
                    if (idEnd < 0) idEnd = lastPart.length();
                    id = lastPart.substring(idStart, idEnd);
                }
                
                // Create simplified variations
                if (!id.isEmpty()) {
                    variations.add(tagName + id);
                } else {
                    // Extract main class if present
                    int classStart = lastPart.indexOf(".");
                    if (classStart >= 0) {
                        int classEnd = lastPart.indexOf(".", classStart + 1);
                        if (classEnd < 0) classEnd = lastPart.indexOf(":", classStart);
                        if (classEnd < 0) classEnd = lastPart.length();
                        String mainClass = lastPart.substring(classStart, classEnd);
                        variations.add(tagName + mainClass);
                    } else {
                        variations.add(tagName);
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Error generating CSS path variations", e);
        }
        
        return variations;
    }
    
    /**
     * Finds an element based on its attribute signature
     */
    private WebElement findElementByAttributeSignature(WebDriver driver, ElementData originalElementData) {
        String tagName = originalElementData.getTagName();
        Map<String, String> attributes = originalElementData.getAttributes();
        
        if (tagName == null || attributes.isEmpty()) {
            return null;
        }
        
        // Try to find unique attribute combinations
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            String attrName = entry.getKey();
            String attrValue = entry.getValue();
            
            // Skip common attributes that might not be unique
            if (attrName.equals("style") || attrName.equals("class") || attrValue.isEmpty()) {
                continue;
            }
            
            try {
                List<WebElement> elements = driver.findElements(
                        By.xpath("//" + tagName.toLowerCase() + "[@" + attrName + "='" + attrValue.replace("'", "\\'") + "']"));
                
                if (elements.size() == 1) {
                    return elements.get(0);
                }
            } catch (Exception e) {
                // Try next attribute
            }
        }
        
        // Try combinations of attributes if we have multiple
        if (attributes.size() >= 2) {
            List<String> attrNames = new ArrayList<>(attributes.keySet());
            
            // Try pairs of attributes
            for (int i = 0; i < attrNames.size(); i++) {
                String attr1 = attrNames.get(i);
                if (attr1.equals("style")) continue;
                
                for (int j = i + 1; j < attrNames.size(); j++) {
                    String attr2 = attrNames.get(j);
                    if (attr2.equals("style")) continue;
                    
                    try {
                        String xpath = "//" + tagName.toLowerCase() + 
                                       "[@" + attr1 + "='" + attributes.get(attr1).replace("'", "\\'") + "' and " +
                                       "@" + attr2 + "='" + attributes.get(attr2).replace("'", "\\'") + "']";
                        
                        List<WebElement> elements = driver.findElements(By.xpath(xpath));
                        if (elements.size() == 1) {
                            return elements.get(0);
                        }
                    } catch (Exception e) {
                        // Try next combination
                    }
                }
            }
        }
        
        return null;
    }
    
    /**
     * Finds an element by analyzing its structural position in the DOM
     */
    private WebElement findElementByStructuralAnalysis(WebDriver driver, ElementData originalElementData) {
        // Use JavaScript for deeper DOM analysis
        String script = 
            "function findSimilarElements(tagName, attributes, textLength, position, parentInfo) {" +
            "  const allElements = document.getElementsByTagName(tagName);" +
            "  const candidates = [];" +
            
            "  for (let i = 0; i < allElements.length; i++) {" +
            "    const element = allElements[i];" +
            "    let score = 0;" +
            "    let matches = 0;" +
            "    let totalAttrs = 0;" +
            
            "    // Check attributes" +
            "    for (const attrName in attributes) {" +
            "      totalAttrs++;" +
            "      if (element.hasAttribute(attrName)) {" +
            "        matches++;" +
            "        if (element.getAttribute(attrName) === attributes[attrName]) {" +
            "          score += 2;" +
            "        } else {" +
            "          score += 0.5;" +
            "        }" +
            "      }" +
            "    }" +
            
            "    // Check text length similarity" +
            "    const elementTextLength = element.textContent ? element.textContent.trim().length : 0;" +
            "    if (Math.abs(elementTextLength - textLength) < 5) {" +
            "      score += 1;" +
            "    } else if (Math.abs(elementTextLength - textLength) < 20) {" +
            "      score += 0.5;" +
            "    }" +
            
            "    // Check structural position" +
            "    if (parentInfo && element.parentElement) {" +
            "      if (element.parentElement.tagName.toLowerCase() === parentInfo.tagName) {" +
            "        score += 1;" +
            "        if (parentInfo.className && element.parentElement.className.includes(parentInfo.className)) {" +
            "          score += 1;" +
            "        }" +
            "      }" +
            "    }" +
            
            "    // Calculate final similarity score" +
            "    const attributeScore = totalAttrs > 0 ? matches / totalAttrs : 0;" +
            "    const normalizedScore = score / (totalAttrs * 2 + 3);" +
            
            "    if (normalizedScore >= 0.6) {" +
            "      candidates.push({element: element, score: normalizedScore});" +
            "    }" +
            "  }" +
            
            "  // Sort candidates by score (descending)" +
            "  candidates.sort((a, b) => b.score - a.score);" +
            "  return candidates.length > 0 ? candidates[0].element : null;" +
            "}" +
            
            "const tagName = arguments[0];" +
            "const attributes = arguments[1];" +
            "const textLength = arguments[2];" +
            "const position = arguments[3];" +
            "const parentInfo = arguments[4];" +
            
            "return findSimilarElements(tagName, attributes, textLength, position, parentInfo);";
        
        try {
            // Prepare parent info
            Map<String, String> parentInfo = null;
            if (originalElementData.getParentTagName() != null) {
                parentInfo = new HashMap<>();
                parentInfo.put("tagName", originalElementData.getParentTagName().toLowerCase());
                if (originalElementData.getParentClass() != null) {
                    parentInfo.put("className", originalElementData.getParentClass());
                }
            }
            
            // Calculate text length
            int textLength = 0;
            if (originalElementData.getTextContent() != null) {
                textLength = originalElementData.getTextContent().trim().length();
            }
            
            // Calculate relative position
            Map<String, Integer> position = new HashMap<>();
            position.put("index", originalElementData.getIndex());
            
            WebElement element = (WebElement) ((JavascriptExecutor) driver).executeScript(
                script, 
                originalElementData.getTagName().toLowerCase(),
                originalElementData.getAttributes(),
                textLength,
                position,
                parentInfo
            );
            
            return element;
        } catch (Exception e) {
            logger.debug("Error finding element by structural analysis", e);
            return null;
        }
    }
}


package com.cssmart.framework.selfhealing;

import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.*;
import javax.imageio.ImageIO;
import org.openqa.selenium.*;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.safari.SafariDriver;
import com.cssmart.framework.exceptions.ElementImageCaptureException;
import com.cssmart.framework.logging.LogManager;
import com.cssmart.framework.config.ConfigurationManager;

/**
 * Implements a visual healing strategy using image comparison techniques
 * to identify elements based on visual appearance
 */
public class VisualHealingStrategy implements ElementHealingStrategy {
    private static final LogManager logger = LogManager.getLogger(VisualHealingStrategy.class);
    // Minimum threshold for image similarity score (0-1)
    private static final double SIMILARITY_THRESHOLD = 0.8;
    // Maximum elements to analyze per healing attempt
    private static final int MAX_CANDIDATES = 20;
    // Path to store image snapshots
    private static String IMAGE_STORAGE_PATH;
    
    public VisualHealingStrategy() {
        IMAGE_STORAGE_PATH = ConfigurationManager.getInstance().getProperty(
            "visual.healing.images.path", 
            System.getProperty("java.io.tmpdir") + File.separator + "cssmart" + File.separator + "images"
        );
        ensureDirectoryExists(IMAGE_STORAGE_PATH);
    }
    
    @Override
    public WebElement findElement(WebDriver driver, ElementData originalElementData) {
        logger.debug("Applying visual healing strategy");
        
        // Skip if we don't have a visual snapshot or browser doesn't support screenshots
        if (originalElementData.getVisualSnapshot() == null || !isBrowserSupported(driver)) {
            logger.debug("Visual healing not applicable - no snapshot or unsupported browser");
            return null;
        }
        
        try {
            // First, try to get the element at the original position as a shortcut
            WebElement elementAtPosition = findElementAtOriginalPosition(driver, originalElementData);
            if (elementAtPosition != null && verifyElementVisually(driver, elementAtPosition, originalElementData)) {
                logger.info("Found element at original position with visual match");
                return elementAtPosition;
            }
            
            // Find all potential matching elements by tag and location
            List<WebElement> candidates = findCandidateElements(driver, originalElementData);
            
            // Verify candidates using visual comparison
            WebElement bestMatch = findBestVisualMatch(driver, candidates, originalElementData);
            if (bestMatch != null) {
                logger.info("Found element by visual comparison");
                return bestMatch;
            }
            
        } catch (Exception e) {
            logger.error("Error in visual healing strategy", e);
        }
        
        logger.debug("Visual healing strategy failed to find element");
        return null;
    }
    
    /**
     * Checks if the browser supports screenshot capabilities needed for visual healing
     */
    private boolean isBrowserSupported(WebDriver driver) {
        return (driver instanceof ChromeDriver || 
                driver instanceof FirefoxDriver || 
                driver instanceof EdgeDriver || 
                driver instanceof SafariDriver);
    }
    
    /**
     * Attempts to find an element at the original position first
     */
    private WebElement findElementAtOriginalPosition(WebDriver driver, ElementData originalElementData) {
        try {
            if (originalElementData.getX() <= 0 || originalElementData.getY() <= 0) {
                return null;
            }
            
            // Use JavaScript to find element at the given coordinates
            String script = 
                "function getElementAtPosition(x, y) {" +
                "  return document.elementFromPoint(x, y);" +
                "}" +
                "return getElementAtPosition(arguments[0], arguments[1]);";
            
            WebElement element = (WebElement) ((JavascriptExecutor) driver).executeScript(
                script, originalElementData.getX() + (originalElementData.getWidth() / 2),
                       originalElementData.getY() + (originalElementData.getHeight() / 2));
            
            // Check if the found element matches the expected tag name
            if (element != null && element.getTagName().equalsIgnoreCase(originalElementData.getTagName())) {
                return element;
            }
        } catch (Exception e) {
            logger.debug("Error finding element at original position", e);
        }
        
        return null;
    }
    
    /**
     * Finds candidate elements that could potentially match the original element
     */
    private List<WebElement> findCandidateElements(WebDriver driver, ElementData originalElementData) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Find all elements of the same tag name
            String tagName = originalElementData.getTagName();
            List<WebElement> elements = driver.findElements(By.tagName(tagName));
            
            // Filter elements by similar location and size
            for (WebElement element : elements) {
                // Get element size and position
                Rectangle rect = getElementRectangle(element);
                if (rect == null) continue;
                
                // Calculate distance from original position
                double distance = calculateDistance(
                    originalElementData.getX(), originalElementData.getY(),
                    rect.x, rect.y
                );
                
                // Calculate size similarity
                double sizeSimilarity = calculateSizeSimilarity(
                    originalElementData.getWidth(), originalElementData.getHeight(),
                    rect.width, rect.height
                );
                
                // Add element to candidates if it's relatively close and similar
                if (sizeSimilarity > 0.7) {
                    candidates.add(element);
                }
                
                // Limit the number of candidates to prevent performance issues
                if (candidates.size() >= MAX_CANDIDATES) {
                    break;
                }
            }
            
            // Sort candidates by position first (closest to original position)
            candidates.sort((e1, e2) -> {
                Rectangle r1 = getElementRectangle(e1);
                Rectangle r2 = getElementRectangle(e2);
                
                if (r1 == null || r2 == null) return 0;
                
                double d1 = calculateDistance(
                    originalElementData.getX(), originalElementData.getY(), r1.x, r1.y);
                double d2 = calculateDistance(
                    originalElementData.getX(), originalElementData.getY(), r2.x, r2.y);
                
                return Double.compare(d1, d2);
            });
        } catch (Exception e) {
            logger.debug("Error finding candidate elements", e);
        }
        
        return candidates;
    }
    
    /**
     * Finds the best visual match among candidate elements
     */
    private WebElement findBestVisualMatch(WebDriver driver, List<WebElement> candidates, ElementData originalElementData) {
        byte[] originalImage = originalElementData.getVisualSnapshot();
        WebElement bestMatch = null;
        double bestScore = 0;
        
        if (originalImage == null || candidates.isEmpty()) {
            return null;
        }
        
        try {
            BufferedImage originalBufferedImage = ImageIO.read(new ByteArrayInputStream(originalImage));
            
            for (WebElement candidate : candidates) {
                // Take screenshot of current candidate
                byte[] candidateImage = captureElementImage(driver, candidate);
                
                if (candidateImage == null) continue;
                
                BufferedImage candidateBufferedImage = ImageIO.read(new ByteArrayInputStream(candidateImage));
                
                // Compare images
                double similarity = compareImages(originalBufferedImage, candidateBufferedImage);
                
                if (similarity > bestScore) {
                    bestScore = similarity;
                    bestMatch = candidate;
                }
                
                // If we found a very good match, stop searching
                if (similarity > 0.95) {
                    break;
                }
            }
        } catch (Exception e) {
            logger.error("Error comparing element images", e);
        }
        
        // Return the best match if it meets the threshold
        return bestScore >= SIMILARITY_THRESHOLD ? bestMatch : null;
    }
    
    /**
     * Captures an image of a specific element
     */
    private byte[] captureElementImage(WebDriver driver, WebElement element) {
        try {
            // Check if element is displayed
            if (!element.isDisplayed()) {
                return null;
            }
            
            // Take screenshot of the entire page
            byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
            BufferedImage fullImg = ImageIO.read(new ByteArrayInputStream(screenshot));
            
            // Get element dimensions
            Rectangle rect = getElementRectangle(element);
            if (rect == null) return null;
            
            // Crop the screenshot to the element's dimensions
            BufferedImage elementImg = fullImg.getSubimage(
                rect.x, rect.y, Math.min(rect.width, fullImg.getWidth() - rect.x),
                Math.min(rect.height, fullImg.getHeight() - rect.y)
            );
            
            // Save image to byte array
            return ImageUtil.toByteArray(elementImg, "PNG");
            
        } catch (Exception e) {
            logger.debug("Failed to capture element image", e);
            return null;
        }
    }
    
    /**
     * Verifies if an element matches the original element visually
     */
    private boolean verifyElementVisually(WebDriver driver, WebElement element, ElementData originalElementData) {
        try {
            byte[] originalImage = originalElementData.getVisualSnapshot();
            byte[] currentImage = captureElementImage(driver, element);
            
            if (originalImage == null || currentImage == null) {
                return false;
            }
            
            BufferedImage originalBufferedImage = ImageIO.read(new ByteArrayInputStream(originalImage));
            BufferedImage currentBufferedImage = ImageIO.read(new ByteArrayInputStream(currentImage));
            
            double similarity = compareImages(originalBufferedImage, currentBufferedImage);
            
            return similarity >= SIMILARITY_THRESHOLD;
        } catch (Exception e) {
            logger.debug("Error verifying element visually", e);
            return false;
        }
    }
    
    /**
     * Compares two images and returns a similarity score (0-1)
     */
    private double compareImages(BufferedImage img1, BufferedImage img2) {
        try {
            // Resize images to the same dimensions for comparison
            BufferedImage resizedImg2 = ImageUtil.resizeImage(img2, img1.getWidth(), img1.getHeight());
            
            // Calculate histogram similarity
            double histogramSimilarity = calculateHistogramSimilarity(img1, resizedImg2);
            
            // Calculate pixel-by-pixel similarity using Mean Squared Error
            double pixelSimilarity = calculatePixelSimilarity(img1, resizedImg2);
            
            // Combine scores with weights (histogram has more influence)
            return (histogramSimilarity * 0.6) + (pixelSimilarity * 0.4);
        } catch (Exception e) {
            logger.error("Error comparing images", e);
            return 0;
        }
    }
    
    /**
     * Calculates histogram similarity between two images
     */
    private double calculateHistogramSimilarity(BufferedImage img1, BufferedImage img2) {
        // Calculate histograms for both images
        int[] histogram1 = calculateHistogram(img1);
        int[] histogram2 = calculateHistogram(img2);
        
        // Compare histograms using correlation
        double correlation = 0;
        double sum1 = 0, sum2 = 0, sum1Sq = 0, sum2Sq = 0, productSum = 0;
        
        for (int i = 0; i < 256; i++) {
            sum1 += histogram1[i];
            sum2 += histogram2[i];
            sum1Sq += histogram1[i] * histogram1[i];
            sum2Sq += histogram2[i] * histogram2[i];
            productSum += histogram1[i] * histogram2[i];
        }
        
        double numerator = productSum - (sum1 * sum2 / 256);
        double denominator = Math.sqrt((sum1Sq - (sum1 * sum1 / 256)) * (sum2Sq - (sum2 * sum2 / 256)));
        
        if (denominator > 0) {
            correlation = numerator / denominator;
        }
        
        // Convert correlation to a 0-1 score
        return (correlation + 1) / 2;
    }
    
    /**
     * Calculates grayscale histogram for an image
     */
    private int[] calculateHistogram(BufferedImage img) {
        int[] histogram = new int[256];
        
        for (int y = 0; y < img.getHeight(); y++) {
            for (int x = 0; x < img.getWidth(); x++) {
                int rgb = img.getRGB(x, y);
                int red = (rgb >> 16) & 0xFF;
                int green = (rgb >> 8) & 0xFF;
                int blue = rgb & 0xFF;
                
                // Convert to grayscale
                int gray = (red + green + blue) / 3;
                histogram[gray]++;
            }
        }
        
        return histogram;
    }
    
    /**
     * Calculates pixel-by-pixel similarity using Mean Squared Error
     */
    private double calculatePixelSimilarity(BufferedImage img1, BufferedImage img2) {
        long diff = 0;
        int width = img1.getWidth();
        int height = img1.getHeight();
        
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int rgb1 = img1.getRGB(x, y);
                int rgb2 = img2.getRGB(x, y);
                
                int r1 = (rgb1 >> 16) & 0xFF;
                int g1 = (rgb1 >> 8) & 0xFF;
                int b1 = rgb1 & 0xFF;
                
                int r2 = (rgb2 >> 16) & 0xFF;
                int g2 = (rgb2 >> 8) & 0xFF;
                int b2 = rgb2 & 0xFF;
                
                diff += Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2);
            }
        }
        
        double mse = (double) diff / (width * height * 3);
        double maxMSE = Math.pow(255, 2) * 3; // Maximum possible MSE
        
        // Convert MSE to similarity score (0-1, where 1 is identical)
        return 1 - Math.min(1, mse / maxMSE);
    }
    
    /**
     * Gets element's rectangle position and size
     */
    private Rectangle getElementRectangle(WebElement element) {
        try {
            Point location = element.getLocation();
            Dimension size = element.getSize();
            
            return new Rectangle(location.getX(), location.getY(), size.getWidth(), size.getHeight());
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Calculates Euclidean distance between two points
     */
    private double calculateDistance(int x1, int y1, int x2, int y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    
    /**
     * Calculates size similarity ratio between two elements
     */
    private double calculateSizeSimilarity(int width1, int height1, int width2, int height2) {
        double widthRatio = Math.min(width1, width2) / (double) Math.max(width1, width2);
        double heightRatio = Math.min(height1, height2) / (double) Math.max(height1, height2);
        
        return (widthRatio + heightRatio) / 2.0;
    }
    
    /**
     * Ensures the directory for storing images exists
     */
    private void ensureDirectoryExists(String path) {
        File directory = new File(path);
        if (!directory.exists()) {
            directory.mkdirs();
        }
    }
    
    /**
     * Utility class for image manipulation
     */
    private static class ImageUtil {
        /**
         * Converts BufferedImage to byte array
         */
        public static byte[] toByteArray(BufferedImage image, String format) throws IOException {
            java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
            ImageIO.write(image, format, baos);
            return baos.toByteArray();
        }
        
        /**
         * Resizes an image to the specified dimensions
         */
        public static BufferedImage resizeImage(BufferedImage originalImage, int targetWidth, int targetHeight) {
            BufferedImage resizedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
            java.awt.Graphics2D g = resizedImage.createGraphics();
            g.drawImage(originalImage, 0, 0, targetWidth, targetHeight, null);
            g.dispose();
            return resizedImage;
        }
    }
}



package com.cssmart.framework.selfhealing;

import java.util.*;
import java.util.concurrent.*;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.TimeoutException;
import com.cssmart.framework.exceptions.ElementNotFoundException;
import com.cssmart.framework.logging.LogManager;
import com.cssmart.framework.config.ConfigurationManager;
import com.cssmart.framework.reporting.ReportManager;
import com.cssmart.framework.utils.PerformanceTracker;

/**
 * Coordinates the self-healing process using multiple healing strategies
 * to find broken elements
 */
public class ElementHealer {
    private static final LogManager logger = LogManager.getLogger(ElementHealer.class);
    private static ElementHealer instance;
    
    // List of healing strategies to try in order
    private final List<ElementHealingStrategy> healingStrategies;
    
    // Element data store
    private final ElementDataRepository elementRepository;
    
    // Configuration
    private final boolean selfHealingEnabled;
    private final boolean parallelHealingEnabled;
    private final int healingTimeoutSeconds;
    private final int maxHealingAttempts;
    
    // Performance tracking
    private final PerformanceTracker performanceTracker;
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private ElementHealer() {
        ConfigurationManager config = ConfigurationManager.getInstance();
        
        // Initialize configuration
        this.selfHealingEnabled = config.getBooleanProperty("selfhealing.enabled", true);
        this.parallelHealingEnabled = config.getBooleanProperty("selfhealing.parallel.enabled", true);
        this.healingTimeoutSeconds = config.getIntProperty("selfhealing.timeout.seconds", 10);
        this.maxHealingAttempts = config.getIntProperty("selfhealing.max.attempts", 3);
        
        // Initialize element repository
        this.elementRepository = ElementDataRepository.getInstance();
        
        // Initialize performance tracker
        this.performanceTracker = new PerformanceTracker("ElementHealer");
        
        // Initialize healing strategies based on configuration
        this.healingStrategies = initializeStrategies(config);
        
        logger.info("ElementHealer initialized with " + healingStrategies.size() + " healing strategies");
        for (ElementHealingStrategy strategy : healingStrategies) {
            logger.info("Loaded healing strategy: " + strategy.getClass().getSimpleName());
        }
    }
    
    /**
     * Gets the singleton instance of ElementHealer
     */
    public static synchronized ElementHealer getInstance() {
        if (instance == null) {
            instance = new ElementHealer();
        }
        return instance;
    }
    
    /**
     * Initializes healing strategies based on configuration
     */
    private List<ElementHealingStrategy> initializeStrategies(ConfigurationManager config) {
        List<ElementHealingStrategy> strategies = new ArrayList<>();
        
        // Get enabled strategies from configuration
        boolean attributeHealingEnabled = config.getBooleanProperty("selfhealing.attribute.enabled", true);
        boolean semanticHealingEnabled = config.getBooleanProperty("selfhealing.semantic.enabled", true);
        boolean domHealingEnabled = config.getBooleanProperty("selfhealing.dom.enabled", true);
        boolean visualHealingEnabled = config.getBooleanProperty("selfhealing.visual.enabled", true);
        
        // Add strategies in order of preference (fastest and most reliable first)
        if (attributeHealingEnabled) {
            strategies.add(new AttributeHealingStrategy());
        }
        
        if (domHealingEnabled) {
            strategies.add(new DomHealingStrategy());
        }
        
        if (semanticHealingEnabled) {
            strategies.add(new SemanticHealingStrategy());
        }
        
        if (visualHealingEnabled) {
            strategies.add(new VisualHealingStrategy());
        }
        
        return Collections.unmodifiableList(strategies);
    }
    
    /**
     * Attempts to heal a broken element
     * 
     * @param driver WebDriver instance
     * @param elementId Unique identifier for the element
     * @param originalLocator Original locator that failed
     * @return WebElement if found, null otherwise
     */
    public WebElement healElement(WebDriver driver, String elementId, String originalLocator) {
        if (!selfHealingEnabled) {
            logger.debug("Self-healing is disabled. Skipping healing for " + elementId);
            return null;
        }
        
        long startTime = System.currentTimeMillis();
        WebElement healedElement = null;
        
        try {
            // Look up element data in repository
            ElementData elementData = elementRepository.getElementData(elementId);
            if (elementData == null) {
                logger.warn("No element data found for healing: " + elementId);
                return null;
            }
            
            logger.info("Attempting to heal element: " + elementId + " (originally located by: " + originalLocator + ")");
            
            // Try healing with different strategies
            if (parallelHealingEnabled) {
                healedElement = healElementInParallel(driver, elementData);
            } else {
                healedElement = healElementSequentially(driver, elementData);
            }
            
            // Record healing result
            if (healedElement != null) {
                long duration = System.currentTimeMillis() - startTime;
                logSuccessfulHealing(elementId, elementData, duration);
                
                // Update element data with current information
                updateElementData(driver, healedElement, elementData);
            } else {
                logger.warn("Failed to heal element: " + elementId);
            }
            
        } catch (Exception e) {
            logger.error("Error during element healing: " + e.getMessage(), e);
        } finally {
            performanceTracker.recordOperation("healElement", System.currentTimeMillis() - startTime);
        }
        
        return healedElement;
    }
    
    /**
     * Updates element data with current information after successful healing
     */
    private void updateElementData(WebDriver driver, WebElement element, ElementData elementData) {
        try {
            // Update location and size
            elementData.updateFromWebElement(driver, element);
            
            // Store updated data
            elementRepository.saveElementData(elementData);
        } catch (Exception e) {
            logger.debug("Error updating element data after healing", e);
        }
    }
    
    /**
     * Heals element by trying strategies sequentially
     */
    private WebElement healElementSequentially(WebDriver driver, ElementData elementData) {
        // Try each strategy in order
        for (ElementHealingStrategy strategy : healingStrategies) {
            logger.debug("Trying healing strategy: " + strategy.getClass().getSimpleName());
            long strategyStart = System.currentTimeMillis();
            
            try {
                WebElement element = strategy.findElement(driver, elementData);
                
                if (element != null) {
                    long duration = System.currentTimeMillis() - strategyStart;
                    logger.info("Element healed successfully using " + strategy.getClass().getSimpleName() + 
                               " in " + duration + "ms");
                    return element;
                }
            } catch (Exception e) {
                logger.debug("Error in healing strategy " + strategy.getClass().getSimpleName(), e);
            }
        }
        
        return null;
    }
    
    /**
     * Heals element by trying strategies in parallel
     */
    private WebElement healElementInParallel(WebDriver driver, ElementData elementData) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(healingStrategies.size());
        CompletionService<WebElement> completionService = new ExecutorCompletionService<>(executor);
        
        // Submit all healing tasks
        for (final ElementHealingStrategy strategy : healingStrategies) {
            completionService.submit(() -> {
                logger.debug("Parallel healing with: " + strategy.getClass().getSimpleName());
                try {
                    return strategy.findElement(driver, elementData);
                } catch (Exception e) {
                    logger.debug("Error in parallel healing strategy: " + e.getMessage());
                    return null;
                }
            });
        }
        
        WebElement result = null;
        try {
            // Wait for first successful result or timeout
            Future<WebElement> future = completionService.poll(healingTimeoutSeconds, TimeUnit.SECONDS);
            if (future != null) {
                result = future.get();
                if (result != null) {
                    logger.info("Element healed successfully with parallel strategy");
                }
            }
        } catch (TimeoutException | ExecutionException e) {
            logger.debug("Parallel healing timed out or failed", e);
        } finally {
            executor.shutdownNow();
        }
        
        return result;
    }
    
    /**
     * Logs successful healing for reporting and analytics
     */
    private void logSuccessfulHealing(String elementId, ElementData elementData, long duration) {
        String message = "Successfully healed element '" + elementId + "' in " + duration + "ms";
        logger.info(message);
        
        // Report healing success
        Map<String, String> healingData = new HashMap<>();
        healingData.put("elementId", elementId);
        healingData.put("tagName", elementData.getTagName());
        healingData.put("healingTime", String.valueOf(duration));
        
        try {
            ReportManager.getInstance().logEvent("ElementHealed", message, healingData);
        } catch (Exception e) {
            logger.debug("Error logging healing success to reports", e);
        }
    }
    
    /**
     * Registers a new element for future healing
     * 
     * @param driver WebDriver instance
     * @param element WebElement to register
     * @param elementId Unique identifier for the element
     * @param locator Locator used to find the element
     */
    public void registerElement(WebDriver driver, WebElement element, String elementId, String locator) {
        if (!selfHealingEnabled) {
            return;
        }
        
        try {
            long startTime = System.currentTimeMillis();
            
            // Check if element is already registered
            ElementData existingData = elementRepository.getElementData(elementId);
            if (existingData != null) {
                // Update existing data
                existingData.updateFromWebElement(driver, element);
                existingData.addLocator(locator);
                elementRepository.saveElementData(existingData);
            } else {
                // Create new element data
                ElementData newData = ElementData.fromWebElement(driver, element, elementId, locator);
                elementRepository.saveElementData(newData);
            }
            
            performanceTracker.recordOperation("registerElement", System.currentTimeMillis() - startTime);
        } catch (Exception e) {
            logger.debug("Error registering element for healing: " + e.getMessage());
        }
    }
    
    /**
     * Gets performance metrics for healing operations
     */
    public Map<String, Object> getPerformanceMetrics() {
        return performanceTracker.getMetrics();
    }
}


package com.cssmart.framework.ai;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.time.Duration;
import java.time.Instant;

import com.cssmart.framework.config.ConfigurationManager;
import com.cssmart.framework.logging.LogManager;
import com.cssmart.framework.database.DatabaseManager;
import com.cssmart.framework.reporting.ReportManager;
import com.cssmart.framework.utils.CryptoUtils;
import com.cssmart.framework.utils.StatisticsUtil;

/**
 * Implements a machine learning based test path analyzer that learns from test
 * executions and suggests optimal test execution paths
 */
public class TestPathAnalyzer {
    private static final LogManager logger = LogManager.getLogger(TestPathAnalyzer.class);
    private static TestPathAnalyzer instance;
    
    // Configuration
    private final boolean enabled;
    private final String dataStoragePath;
    private final int minimumDataPoints;
    private final boolean useDatabaseStorage;
    
    // Test execution history
    private final Map<String, TestExecutionData> testHistory;
    
    // Path analysis cache
    private final Map<String, PathAnalysisResult> analysisCache;
    
    // Feature weights - will be adjusted through learning
    private final Map<String, Double> featureWeights;
    
    // Current test session data
    private final Map<String, List<TestStepData>> currentSession;
    
    // Last training time
    private Instant lastModelTrainingTime;
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private TestPathAnalyzer() {
        ConfigurationManager config = ConfigurationManager.getInstance();
        
        // Initialize configuration
        this.enabled = config.getBooleanProperty("testpath.analyzer.enabled", true);
        this.dataStoragePath = config.getProperty("testpath.analyzer.data.path", 
                                                  System.getProperty("user.home") + File.separator + 
                                                  ".cssmart" + File.separator + "testdata");
        this.minimumDataPoints = config.getIntProperty("testpath.analyzer.min.datapoints", 5);
        this.useDatabaseStorage = config.getBooleanProperty("testpath.analyzer.use.database", false);
                
        // Initialize data structures
        this.testHistory = new ConcurrentHashMap<>();
        this.analysisCache = new ConcurrentHashMap<>();
        this.featureWeights = initializeFeatureWeights();
        this.currentSession = new ConcurrentHashMap<>();
        
        // Create storage directory if needed
        if (!useDatabaseStorage) {
            createDataStorageDirectory();
        }
        
        // Load historical data
        loadTestExecutionHistory();
        
        logger.info("Test Path Analyzer initialized. Enabled: " + enabled);
    }
    
    /**
     * Gets the singleton instance of TestPathAnalyzer
     */
    public static synchronized TestPathAnalyzer getInstance() {
        if (instance == null) {
            instance = new TestPathAnalyzer();
        }
        return instance;
    }
    
    /**
     * Initializes feature weights with default values
     */
    private Map<String, Double> initializeFeatureWeights() {
        Map<String, Double> weights = new HashMap<>();
        
        // Default weights based on importance of different features
        weights.put("executionTime", 1.0);      // Execution time is a primary factor
        weights.put("passRate", 1.5);           // Pass rate is highly important
        weights.put("complexity", 0.8);         // Test complexity matters but less than pass rate
        weights.put("dataDependency", 0.6);     // Data dependencies between tests
        weights.put("resourceUsage", 0.4);      // Resource usage is less important initially
        weights.put("coverageGain", 1.2);       // Coverage gain is important
        weights.put("flakiness", 1.3);          // Flakiness is very important to consider
        weights.put("lastExecutionStatus", 0.7); // Recent failures might need prioritization
        weights.put("age", 0.3);                // How recently the test was created/modified
        weights.put("userPriority", 1.1);       // User-defined priority can override algorithms
        
        return weights;
    }
    
    /**
     * Creates data storage directory if it doesn't exist
     */
    private void createDataStorageDirectory() {
        try {
            Path directory = Paths.get(dataStoragePath);
            if (!Files.exists(directory)) {
                Files.createDirectories(directory);
                logger.info("Created test path analyzer data directory: " + dataStoragePath);
            }
        } catch (IOException e) {
            logger.error("Failed to create data directory: " + e.getMessage(), e);
        }
    }
    
    /**
     * Loads historical test execution data from file or database
     */
    private void loadTestExecutionHistory() {
        if (!enabled) return;
        
        try {
            if (useDatabaseStorage) {
                loadHistoryFromDatabase();
            } else {
                loadHistoryFromFiles();
            }
            
            int historySize = testHistory.size();
            logger.info("Loaded " + historySize + " test execution records");
            
            // Pre-calculate analysis results for common test suites
            if (historySize >= minimumDataPoints) {
                updateModel();
            }
        } catch (Exception e) {
            logger.error("Error loading test execution history: " + e.getMessage(), e);
        }
    }
    
    /**
     * Loads test history from database
     */
    private void loadHistoryFromDatabase() throws Exception {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            conn = DatabaseManager.getInstance().getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery("SELECT * FROM test_execution_history ORDER BY execution_time DESC LIMIT 1000");
            
            while (rs.next()) {
                String testId = rs.getString("test_id");
                TestExecutionData data = new TestExecutionData();
                
                data.setTestId(testId);
                data.setExecutionTime(rs.getLong("execution_time"));
                data.setResult(rs.getString("result"));
                data.setDuration(rs.getLong("duration"));
                data.setResourceUsage(rs.getDouble("resource_usage"));
                data.setComplexityScore(rs.getDouble("complexity_score"));
                data.setFlakiness(rs.getDouble("flakiness"));
                
                // Parse dependencies and coverage
                String dependenciesJson = rs.getString("dependencies");
                String coverageJson = rs.getString("coverage");
                
                if (dependenciesJson != null && !dependenciesJson.isEmpty()) {
                    data.setDependencies(parseStringList(dependenciesJson));
                }
                
                if (coverageJson != null && !coverageJson.isEmpty()) {
                    data.setCoverage(parseMap(coverageJson));
                }
                
                // Store in history map
                testHistory.put(testId, data);
            }
        } finally {
            if (rs != null) rs.close();
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
        }
    }
    
    /**
     * Loads test history from file storage
     */
    private void loadHistoryFromFiles() throws Exception {
        Path historyDir = Paths.get(dataStoragePath);
        if (!Files.exists(historyDir)) {
            return;
        }
        
        // Iterate through all JSON files in the directory
        Files.list(historyDir)
            .filter(path -> path.toString().endsWith(".json"))
            .forEach(path -> {
                try {
                    String content = new String(Files.readAllBytes(path));
                    TestExecutionData data = parseTestExecutionData(content);
                    if (data != null && data.getTestId() != null) {
                        testHistory.put(data.getTestId(), data);
                    }
                } catch (Exception e) {
                    logger.debug("Error loading test history file: " + path, e);
                }
            });
    }
    
    /**
     * Parses test execution data from JSON string
     */
    private TestExecutionData parseTestExecutionData(String json) {
        try {
            // Simple JSON parsing without external libraries
            TestExecutionData data = new TestExecutionData();
            
            // Extract testId
            String testIdPattern = "\"testId\"\\s*:\\s*\"([^\"]+)\"";
            java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(testIdPattern);
            java.util.regex.Matcher matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setTestId(matcher.group(1));
            }
            
            // Extract execution time
            String executionTimePattern = "\"executionTime\"\\s*:\\s*(\\d+)";
            pattern = java.util.regex.Pattern.compile(executionTimePattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setExecutionTime(Long.parseLong(matcher.group(1)));
            }
            
            // Extract result
            String resultPattern = "\"result\"\\s*:\\s*\"([^\"]+)\"";
            pattern = java.util.regex.Pattern.compile(resultPattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setResult(matcher.group(1));
            }
            
            // Extract duration
            String durationPattern = "\"duration\"\\s*:\\s*(\\d+)";
            pattern = java.util.regex.Pattern.compile(durationPattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setDuration(Long.parseLong(matcher.group(1)));
            }
            
            // Parse remaining fields similarly
            // ...
            
            return data;
        } catch (Exception e) {
            logger.debug("Error parsing test execution data: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a JSON string list into a List<String>
     */
    private List<String> parseStringList(String json) {
        List<String> result = new ArrayList<>();
        try {
            // Basic JSON array parsing
            if (json.startsWith("[") && json.endsWith("]")) {
                String content = json.substring(1, json.length() - 1);
                String[] items = content.split(",");
                
                for (String item : items) {
                    // Remove quotes and trim
                    item = item.trim();
                    if (item.startsWith("\"") && item.endsWith("\"")) {
                        item = item.substring(1, item.length() - 1);
                    }
                    result.add(item);
                }
            }
        } catch (Exception e) {
            logger.debug("Error parsing string list: " + e.getMessage());
        }
        return result;
    }
    
    /**
     * Parses a JSON map into a Map<String, Double>
     */
    private Map<String, Double> parseMap(String json) {
        Map<String, Double> result = new HashMap<>();
        try {
            // Basic JSON object parsing
            if (json.startsWith("{") && json.endsWith("}")) {
                String content = json.substring(1, json.length() - 1);
                String[] pairs = content.split(",");
                
                for (String pair : pairs) {
                    String[] keyValue = pair.split(":");
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim();
                        String value = keyValue[1].trim();
                        
                        // Remove quotes from key
                        if (key.startsWith("\"") && key.endsWith("\"")) {
                            key = key.substring(1, key.length() - 1);
                        }
                        
                        result.put(key, Double.parseDouble(value));
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Error parsing map: " + e.getMessage());
        }
        return result;
    }
    
    /**
     * Records the start of a test execution
     */
    public void recordTestStart(String testId, String testName, Map<String, String> metadata) {
        if (!enabled) return;
        
        try {
            // Create or retrieve test step list for this test
            List<TestStepData> steps = currentSession.computeIfAbsent(testId, k -> new ArrayList<>());
            
            // Create test step data for the test start
            TestStepData startStep = new TestStepData();
            startStep.setTestId(testId);
            startStep.setTestName(testName);
            startStep.setStepType("START");
            startStep.setTimestamp(System.currentTimeMillis());
            startStep.setMetadata(metadata != null ? new HashMap<>(metadata) : new HashMap<>());
            
            // Add to the steps list
            steps.add(startStep);
            
            logger.debug("Recorded test start: " + testId);
        } catch (Exception e) {
            logger.debug("Error recording test start: " + e.getMessage());
        }
    }
    
    /**
     * Records a test step execution
     */
    public void recordTestStep(String testId, String stepName, String stepType, 
                              boolean stepPassed, long durationMs, Map<String, String> metadata) {
        if (!enabled) return;
        
        try {
            // Create or retrieve test step list for this test
            List<TestStepData> steps = currentSession.computeIfAbsent(testId, k -> new ArrayList<>());
            
            // Create test step data
            TestStepData stepData = new TestStepData();
            stepData.setTestId(testId);
            stepData.setStepName(stepName);
            stepData.setStepType(stepType);
            stepData.setPassed(stepPassed);
            stepData.setDuration(durationMs);
            stepData.setTimestamp(System.currentTimeMillis());
            stepData.setMetadata(metadata != null ? new HashMap<>(metadata) : new HashMap<>());
            
            // Add to the steps list
            steps.add(stepData);
            
            logger.debug("Recorded test step: " + testId + " / " + stepName);
        } catch (Exception e) {
            logger.debug("Error recording test step: " + e.getMessage());
        }
    }
    
    /**
     * Records the end of a test execution
     */
    public void recordTestEnd(String testId, boolean passed, long durationMs, 
                             Map<String, Double> coverage, Map<String, String> metadata) {
        if (!enabled) return;
        
        try {
            // Create test execution data
            TestExecutionData execData = new TestExecutionData();
            execData.setTestId(testId);
            execData.setExecutionTime(System.currentTimeMillis());
            execData.setResult(passed ? "PASS" : "FAIL");
            execData.setDuration(durationMs);
            
            // Get steps for this test
            List<TestStepData> steps = currentSession.get(testId);
            if (steps != null) {
                // Calculate complexity based on steps
                execData.setComplexityScore(calculateComplexity(steps));
                
                // Calculate resource usage
                execData.setResourceUsage(calculateResourceUsage(steps));
                
                // Extract dependencies
                execData.setDependencies(extractDependencies(steps));
            }
            
            // Set coverage data
            if (coverage != null) {
                execData.setCoverage(new HashMap<>(coverage));
            }
            
            // Set flakiness score based on history
            execData.setFlakiness(calculateFlakiness(testId, passed));
            
            // Store execution data
            storeTestExecutionData(execData);
            
            // Update in-memory history
            testHistory.put(testId, execData);
            
            // Clean up session data
            currentSession.remove(testId);
            
            logger.info("Recorded test end: " + testId + ", passed: " + passed + ", duration: " + durationMs + "ms");
            
            // Check if we need to update model
            checkAndUpdateModel();
        } catch (Exception e) {
            logger.error("Error recording test end: " + e.getMessage(), e);
        }
    }
    
    /**
     * Stores test execution data to persistent storage
     */
    private void storeTestExecutionData(TestExecutionData data) throws Exception {
        if (useDatabaseStorage) {
            storeToDatabase(data);
        } else {
            storeToFile(data);
        }
    }
    
    /**
     * Stores test execution data to database
     */
    private void storeToDatabase(TestExecutionData data) throws Exception {
        Connection conn = null;
        PreparedStatement pstmt = null;
        
        try {
            conn = DatabaseManager.getInstance().getConnection();
            
            String sql = "INSERT INTO test_execution_history " +
                         "(test_id, execution_time, result, duration, resource_usage, " +
                         "complexity_score, dependencies, coverage, flakiness) " +
                         "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
            
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, data.getTestId());
            pstmt.setLong(2, data.getExecutionTime());
            pstmt.setString(3, data.getResult());
            pstmt.setLong(4, data.getDuration());
            pstmt.setDouble(5, data.getResourceUsage());
            pstmt.setDouble(6, data.getComplexityScore());
            
            // Convert dependencies to JSON
            String dependenciesJson = convertListToJson(data.getDependencies());
            pstmt.setString(7, dependenciesJson);
            
            // Convert coverage to JSON
            String coverageJson = convertMapToJson(data.getCoverage());
            pstmt.setString(8, coverageJson);
            
            pstmt.setDouble(9, data.getFlakiness());
            
            pstmt.executeUpdate();
        } finally {
            if (pstmt != null) pstmt.close();
            if (conn != null) conn.close();
        }
    }
    
    /**
     * Stores test execution data to file
     */
    private void storeToFile(TestExecutionData data) throws Exception {
        // Create filename based on test ID and timestamp
        String filename = CryptoUtils.sha256Hash(data.getTestId()) + "_" + 
                          data.getExecutionTime() + ".json";
        
        Path filePath = Paths.get(dataStoragePath, filename);
        
        // Convert data to JSON
        String json = convertToJson(data);
        
        // Write to file
        Files.write(filePath, json.getBytes());
    }
    
    /**
     * Converts test execution data to JSON string
     */
    private String convertToJson(TestExecutionData data) {
        StringBuilder json = new StringBuilder();
        json.append("{");
        
        json.append("\"testId\":\"").append(data.getTestId()).append("\",");
        json.append("\"executionTime\":").append(data.getExecutionTime()).append(",");
        json.append("\"result\":\"").append(data.getResult()).append("\",");
        json.append("\"duration\":").append(data.getDuration()).append(",");
        json.append("\"resourceUsage\":").append(data.getResourceUsage()).append(",");
        json.append("\"complexityScore\":").append(data.getComplexityScore()).append(",");
        
        // Add dependencies
        json.append("\"dependencies\":").append(convertListToJson(data.getDependencies())).append(",");
        
        // Add coverage
        json.append("\"coverage\":").append(convertMapToJson(data.getCoverage())).append(",");
        
        json.append("\"flakiness\":").append(data.getFlakiness());
        
        json.append("}");
        return json.toString();
    }
    
    /**
     * Converts a list to JSON array
     */
    private String convertListToJson(List<String> list) {
        if (list == null || list.isEmpty()) {
            return "[]";
        }
        
        StringBuilder json = new StringBuilder();
        json.append("[");
        
        boolean first = true;
        for (String item : list) {
            if (!first) {
                json.append(",");
            }
            json.append("\"").append(item).append("\"");
            first = false;
        }
        
        json.append("]");
        return json.toString();
    }
    
    /**
     * Converts a map to JSON object
     */
    private String convertMapToJson(Map<String, Double> map) {
        if (map == null || map.isEmpty()) {
            return "{}";
        }
        
        StringBuilder json = new StringBuilder();
        json.append("{");
        
        boolean first = true;
        for (Map.Entry<String, Double> entry : map.entrySet()) {
            if (!first) {
                json.append(",");
            }
            json.append("\"").append(entry.getKey()).append("\":")
                .append(entry.getValue());
            first = false;
        }
        
        json.append("}");
        return json.toString();
    }
    
    /**
     * Calculates test complexity score based on test steps
     */
    private double calculateComplexity(List<TestStepData> steps) {
        if (steps == null || steps.isEmpty()) {
            return 0.0;
        }
        
        // Count different types of actions
        int validationCount = 0;
        int interactionCount = 0;
        int navigationCount = 0;
        int dataOperationCount = 0;
        
        for (TestStepData step : steps) {
            String type = step.getStepType();
            if (type == null) continue;
            
            switch (type.toUpperCase()) {
                case "ASSERT":
                case "VERIFY":
                case "VALIDATE":
                    validationCount++;
                    break;
                case "CLICK":
                case "TYPE":
                case "SELECT":
                case "DRAG":
                    interactionCount++;
                    break;
                case "NAVIGATE":
                case "REDIRECT":
                    navigationCount++;
                    break;
                case "DATA":
                case "API":
                case "DB":
                    dataOperationCount++;
                    break;
            }
        }
        
        // Calculate complexity score
        // More interactive steps and validations = higher complexity
        double baseComplexity = 0.1 * steps.size();
        double interactionComplexity = 0.2 * interactionCount;
        double validationComplexity = 0.3 * validationCount;
        double navigationComplexity = 0.2 * navigationCount;
        double dataComplexity = 0.4 * dataOperationCount;
        
        return baseComplexity + interactionComplexity + validationComplexity + 
               navigationComplexity + dataComplexity;
    }
    
    /**
     * Calculates resource usage based on test steps
     */
    private double calculateResourceUsage(List<TestStepData> steps) {
        if (steps == null || steps.isEmpty()) {
            return 0.0;
        }
        
        // Sum up durations and check for resource-intensive operations
        long totalDuration = 0;
        int resourceIntensiveOps = 0;
        
        for (TestStepData step : steps) {
            totalDuration += step.getDuration();
            
            // Check for resource-intensive operations in metadata
            Map<String, String> metadata = step.getMetadata();
            if (metadata != null) {
                if ("true".equalsIgnoreCase(metadata.get("memoryIntensive")) ||
                    "true".equalsIgnoreCase(metadata.get("cpuIntensive")) ||
                    "true".equalsIgnoreCase(metadata.get("ioIntensive"))) {
                    resourceIntensiveOps++;
                }
            }
        }
        
        // Calculate resource usage score
        double durationFactor = Math.min(1.0, totalDuration / 10000.0); // Normalize to 0-1
        double intensiveOpsFactor = Math.min(1.0, resourceIntensiveOps / 5.0); // Normalize to 0-1
        
        return (durationFactor * 0.7) + (intensiveOpsFactor * 0.3);
    }
    
    /**
     * Extracts test dependencies from test steps
     */
    private List<String> extractDependencies(List<TestStepData> steps) {
        Set<String> dependencies = new HashSet<>();
        
        if (steps != null) {
            for (TestStepData step : steps) {
                Map<String, String> metadata = step.getMetadata();
                if (metadata != null) {
                    String deps = metadata.get("dependencies");
                    if (deps != null && !deps.isEmpty()) {
                        // Split comma-separated dependencies
                        String[] depsArray = deps.split(",");
                        for (String dep : depsArray) {
                            dependencies.add(dep.trim());
                        }
                    }
                }
            }
        }
        
        return new ArrayList<>(dependencies);
    }
    
    /**
     * Calculates flakiness score based on test history
     */
    private double calculateFlakiness(String testId, boolean currentPassed) {
        TestExecutionData previousData = testHistory.get(testId);
        if (previousData == null) {
            // No history, baseline flakiness
            return 0.1;
        }
        
        // Get previous 10 executions if available
        List<TestExecutionData> recentExecutions = getRecentExecutions(testId, 10);
        
        // If we have multiple executions
        if (recentExecutions.size() > 1) {
            int passCount = 0;
            int totalCount = recentExecutions.size();
            
            for (TestExecutionData exec : recentExecutions) {
                if ("PASS".equals(exec.getResult())) {
                    passCount++;
                }
            }
            
            // Calculate pass rate
            double passRate = (double) passCount / totalCount;
            
            // Flakiness is higher when the pass rate is closer to 0.5
            // (most unpredictable) and lower when it's close to 0 or 1
            double flakiness = 1.0 - (Math.abs(passRate - 0.5) * 2.0);
            
            // Adjust based on current result vs previous result
            if (previousData != null) {
                boolean previousPassed = "PASS".equals(previousData.getResult());
                if (previousPassed != currentPassed) {
                    // Outcome changed, increase flakiness
                    flakiness += 0.2;
                }
            }
            
            return Math.min(1.0, Math.max(0.0, flakiness));
        } else {
            // Not enough history
            return 0.1;
        }
    }
    
    /**
     * Gets recent test executions
     */
    private List<TestExecutionData> getRecentExecutions(String testId, int limit) {
        // First check in-memory history
        TestExecutionData data = testHistory.get(testId);
        List<TestExecutionData> result = new ArrayList<>();
        
        if (data != null) {
            result.add(data);
        }
        
        // If using database, get additional history
        if (useDatabaseStorage && result.size() < limit) {
            try {
                Connection conn = null;
                PreparedStatement pstmt = null;
                ResultSet rs = null;
                
                try {
                    conn = DatabaseManager.getInstance().getConnection();
                    pstmt = conn.prepareStatement(
                        "SELECT * FROM test_execution_history WHERE test_id = ? " +
                        "ORDER BY execution_time DESC LIMIT ?"
                    );
                    
                    pstmt.setString(1, testId);
                    pstmt.setInt(2, limit);
                    
                    rs = pstmt.executeQuery();
                    
                    while (rs.next()) {
                        TestExecutionData execData = new TestExecutionData();
                        execData.setTestId(testId);
                        execData.setExecutionTime(rs.getLong("execution_time"));
                        execData.setResult(rs.getString("result"));
                        // Load other fields as needed
                        
                        result.add(execData);
                    }
                } finally {
                    if (rs != null) rs.close();
                    if (pstmt != null) pstmt.close();
                    if (conn != null) conn.close();
                }
            } catch (Exception e) {
                logger.debug("Error getting recent executions from database", e);
            }
        } else if (!useDatabaseStorage && result.size() < limit) {
            // If using file storage, search for files
            try {
                Path historyDir = Paths.get(dataStoragePath);
                if (Files.exists(historyDir)) {
                    // Find files for this test
                    String testIdHash = CryptoUtils.sha256Hash(testId);
                    
                    List<Path> matchingFiles = Files.list(historyDir)
                        .filter(path -> path.toString().contains(testIdHash))
                        .sorted((p1, p2) -> p2.toString().compareTo(p1.toString())) // Sort desc
                        .limit(limit - result.size())
                        .collect(Collectors.toList());
                    
                    for (Path path : matchingFiles) {
                        String content = new String(Files.readAllBytes(path));
                        TestExecutionData execData = parseTestExecutionData(content);
                        if (execData != null) {
                            result.add(execData);
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error getting recent executions from files", e);
            }
        }
        
        return result;
    }
    
    /**
     * Checks if model update is needed and triggers update if so
     */
    private void checkAndUpdateModel() {
        // Check if enough time has passed since last update
        if (lastModelTrainingTime == null ||
            Duration.between(lastModelTrainingTime, Instant.now()).toHours() >= 24) {
            
            // Check if we have enough data
            if (testHistory.size() >= minimumDataPoints) {
                updateModel();
            }
        }
    }
    
    /**
     * Updates the machine learning model based on historical data
     */
    private void updateModel() {
        try {
            logger.info("Updating test path analyzer model...");
            
            // Record start time
            long startTime = System.currentTimeMillis();
            
            // Optimize feature weights based on historical data
            optimizeFeatureWeights();
            
            // Clear analysis cache since weights changed
            analysisCache.clear();
            
            // Update last training time
            lastModelTrainingTime = Instant.now();
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("Model update completed in " + duration + "ms");
            
            // Log updated weights
            logger.info("Updated feature weights: " + featureWeights);
        } catch (Exception e) {
            logger.error("Error updating model: " + e.getMessage(), e);
        }
    }
    
    /**
     * Optimizes feature weights based on historical performance data
     */
    private void optimizeFeatureWeights() {
        // This is a simplified weight optimization algorithm
        // In a real implementation, this would use more sophisticated ML techniques
        
        if (testHistory.size() < minimumDataPoints) {
            return;
        }
        
        // Calculate success metrics for each feature
        Map<String, Double> featureCorrelations = new HashMap<>();
        
        // Initialize correlations
        for (String feature : featureWeights.keySet()) {
            featureCorrelations.put(feature, 0.0);
        }
        
        // Calculate feature correlations with test success
        calculateFeatureSuccessCorrelations(featureCorrelations);
        
        // Adjust weights based on correlations
        for (Map.Entry<String, Double> entry : featureCorrelations.entrySet()) {
            String feature = entry.getKey();
            double correlation = entry.getValue();
            
            // Get current weight
            double currentWeight = featureWeights.get(feature);
            
            // Calculate adjustment factor (positive correlation means increase weight)
            double adjustment = correlation * 0.1; // 10% maximum adjustment
            
            // Update weight
            double newWeight = Math.max(0.1, Math.min(2.0, currentWeight + adjustment));
            featureWeights.put(feature, newWeight);
        }
    }
    
    /**
     * Calculates correlations between features and test success
     */
    private void calculateFeatureSuccessCorrelations(Map<String, Double> correlations) {
        // Collect feature values and success indicators
        Map<String, List<Double>> featureValues = new HashMap<>();
        List<Double> successValues = new ArrayList<>();
        
        // Initialize feature lists
        for (String feature : featureWeights.keySet()) {
            featureValues.put(feature, new ArrayList<>());
        }
        
        // Collect data from history
        for (TestExecutionData data : testHistory.values()) {
            // Success is 1.0 for pass, 0.0 for fail
            double success = "PASS".equals(data.getResult()) ? 1.0 : 0.0;
            successValues.add(success);
            
            // Collect feature values
            featureValues.get("executionTime").add((double) data.getDuration());
            featureValues.get("passRate").add(getHistoricalPassRate(data.getTestId()));
            featureValues.get("complexity").add(data.getComplexityScore());
            featureValues.get("resourceUsage").add(data.getResourceUsage());
            featureValues.get("flakiness").add(data.getFlakiness());
            
            // Set dummy values for features we don't have direct data for
            featureValues.get("dataDependency").add((double) data.getDependencies().size());
            featureValues.get("coverageGain").add(getCoverageGainScore(data));
            featureValues.get("lastExecutionStatus").add(success); // Using current status as proxy
            featureValues.get("age").add(0.5); // Neutral value
            featureValues.get("userPriority").add(0.5); // Neutral value
        }
        
        // Calculate correlation for each feature
        for (String feature : featureWeights.keySet()) {
            List<Double> featureData = featureValues.get(feature);
            if (featureData.size() == successValues.size() && !featureData.isEmpty()) {
                double correlation = StatisticsUtil.calculateCorrelation(
                    featureData, successValues);
                correlations.put(feature, correlation);
            }
        }
    }
    
    /**
     * Gets historical pass rate for a test
     */
    private double getHistoricalPassRate(String testId) {
        List<TestExecutionData> history = getRecentExecutions(testId, 10);
        
        if (history.isEmpty()) {
            return 0.5; // Neutral value if no history
        }
        
        int passCount = 0;
        for (TestExecutionData data : history) {
            if ("PASS".equals(data.getResult())) {
                passCount++;
            }
        }
        
        return (double) passCount / history.size();
    }
    
    /**
     * Calculates coverage gain score for a test
     */
    private double getCoverageGainScore(TestExecutionData data) {
        Map<String, Double> coverage = data.getCoverage();
        
        if (coverage == null || coverage.isEmpty()) {
            return 0.0;
        }
        
        // Calculate average coverage
        double sum = 0.0;
        for (Double value : coverage.values()) {
            sum += value;
        }
        
        return sum / coverage.size();
    }
    
    /**
     * Analyzes a test suite and suggests optimal execution order
     */
    public PathAnalysisResult analyzeTestPath(List<String> testIds) {
        if (!enabled || testIds == null || testIds.isEmpty()) {
            return new PathAnalysisResult(testIds, Collections.emptyMap());
        }
        
        // Generate cache key for this analysis
        String cacheKey = String.join(":", testIds);
        
        // Check if we have a cached result
        PathAnalysisResult cachedResult = analysisCache.get(cacheKey);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        try {
            logger.info("Analyzing optimal test path for " + testIds.size() + " tests");
            
            // Record start time
            long startTime = System.currentTimeMillis();
            
            // Calculate scores for each test
            Map<String, Double> testScores = calculateTestScores(testIds);
            
            // Sort tests by score (higher is better)
            List<String> optimizedOrder = testIds.stream()
                .sorted((t1, t2) -> Double.compare(testScores.getOrDefault(t2, 0.0), 
                                                  testScores.getOrDefault(t1, 0.0)))
                .collect(Collectors.toList());
            
            // Create result
            PathAnalysisResult result = new PathAnalysisResult(optimizedOrder, testScores);
            
            // Cache the result
            analysisCache.put(cacheKey, result);
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("Test path analysis completed in " + duration + "ms");
            
            return result;
        } catch (Exception e) {
            logger.error("Error analyzing test path: " + e.getMessage(), e);
            return new PathAnalysisResult(testIds, Collections.emptyMap());
        }
    }
    
    /**
     * Calculates scores for each test based on weighted features
     */
    private Map<String, Double> calculateTestScores(List<String> testIds) {
        Map<String, Double> scores = new HashMap<>();
        
        for (String testId : testIds) {
            double score = calculateTestScore(testId);
            scores.put(testId, score);
        }
        
        return scores;
    }
    
    /**
     * Calculates score for a single test based on weighted features
     */
    private double calculateTestScore(String testId) {
        TestExecutionData data = testHistory.get(testId);
        
        if (data == null) {
            // No history - neutral score
            return 0.5;
        }
        
        double score = 0.0;
        double totalWeight = 0.0;
        
        // Execution time (negative factor - shorter is better)
        double normalizedTime = Math.min(1.0, data.getDuration() / 30000.0); // Cap at 30 seconds
        double timeScore = 1.0 - normalizedTime;
        score += timeScore * featureWeights.get("executionTime");
        totalWeight += featureWeights.get("executionTime");
        
        // Pass rate
        double passRate = getHistoricalPassRate(testId);
        score += passRate * featureWeights.get("passRate");
        totalWeight += featureWeights.get("passRate");
        
        // Complexity
        double normalizedComplexity = Math.min(1.0, data.getComplexityScore() / 10.0); // Cap at 10
        score += (1.0 - normalizedComplexity) * featureWeights.get("complexity");
        totalWeight += featureWeights.get("complexity");
        
        // Resource usage (negative factor - lower is better)
        score += (1.0 - data.getResourceUsage()) * featureWeights.get("resourceUsage");
        totalWeight += featureWeights.get("resourceUsage");
        
        // Data dependency (negative factor - fewer dependencies is better)
        double dependencyScore = Math.max(0.0, 1.0 - (data.getDependencies().size() / 5.0));
        score += dependencyScore * featureWeights.get("dataDependency");
        totalWeight += featureWeights.get("dataDependency");
        
        // Coverage gain
        double coverageScore = getCoverageGainScore(data);
        score += coverageScore * featureWeights.get("coverageGain");
        totalWeight += featureWeights.get("coverageGain");
        
        // Flakiness (negative factor - lower is better)
        score += (1.0 - data.getFlakiness()) * featureWeights.get("flakiness");
        totalWeight += featureWeights.get("flakiness");
        
        // Last execution status
        double lastStatusScore = "PASS".equals(data.getResult()) ? 1.0 : 0.0;
        score += lastStatusScore * featureWeights.get("lastExecutionStatus");
        totalWeight += featureWeights.get("lastExecutionStatus");
        
        // Normalize final score
        return score / totalWeight;
    }
    
    /**
     * Gets feature weights
     */
    public Map<String, Double> getFeatureWeights() {
        return new HashMap<>(featureWeights);
    }
    
    /**
     * Gets test history size
     */
    public int getTestHistorySize() {
        return testHistory.size();
    }
    
    /**
     * Data class for test execution data
     */
    public static class TestExecutionData {
        private String testId;
        private long executionTime;
        private String result;
        private long duration;
        private double resourceUsage;
        private double complexityScore;
        private List<String> dependencies = new ArrayList<>();
        private Map<String, Double> coverage = new HashMap<>();
        private double flakiness;
        
        // Getters and setters
        public String getTestId() { return testId; }
        public void setTestId(String testId) { this.testId = testId; }
        
        public long getExecutionTime() { return executionTime; }
        public void setExecutionTime(long executionTime) { this.executionTime = executionTime; }
        
        public String getResult() { return result; }
        public void setResult(String result) { this.result = result; }
        
        public long getDuration() { return duration; }
        public void setDuration(long duration) { this.duration = duration; }
        
        public double getResourceUsage() { return resourceUsage; }
        public void setResourceUsage(double resourceUsage) { this.resourceUsage = resourceUsage; }
        
        public double getComplexityScore() { return complexityScore; }
        public void setComplexityScore(double complexityScore) { this.complexityScore = complexityScore; }
        
        public List<String> getDependencies() { return dependencies; }
        public void setDependencies(List<String> dependencies) { 
            this.dependencies = dependencies != null ? dependencies : new ArrayList<>(); 
        }
        
        public Map<String, Double> getCoverage() { return coverage; }
        public void setCoverage(Map<String, Double> coverage) { 
            this.coverage = coverage != null ? coverage : new HashMap<>(); 
        }
        
        public double getFlakiness() { return flakiness; }
        public void setFlakiness(double flakiness) { this.flakiness = flakiness; }
    }
    
    /**
     * Data class for test step data
     */
    public static class TestStepData {
        private String testId;
        private String testName;
        private String stepName;
        private String stepType;
        private boolean passed;
        private long duration;
        private long timestamp;
        private Map<String, String> metadata = new HashMap<>();
        
        // Getters and setters
        public String getTestId() { return testId; }
        public void setTestId(String testId) { this.testId = testId; }
        
        public String getTestName() { return testName; }
        public void setTestName(String testName) { this.testName = testName; }
        
        public String getStepName() { return stepName; }
        public void setStepName(String stepName) { this.stepName = stepName; }
        
        public String getStepType() { return stepType; }
        public void setStepType(String stepType) { this.stepType = stepType; }
        
        public boolean isPassed() { return passed; }
        public void setPassed(boolean passed) { this.passed = passed; }
        
        public long getDuration() { return duration; }
        public void setDuration(long duration) { this.duration = duration; }
        
        public long getTimestamp() { return timestamp; }
        public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
        
        public Map<String, String> getMetadata() { return metadata; }
        public void setMetadata(Map<String, String> metadata) { 
            this.metadata = metadata != null ? metadata : new HashMap<>(); 
        }
    }
    
    /**
     * Data class for path analysis result
     */
    public static class PathAnalysisResult {
        private final List<String> optimizedOrder;
        private final Map<String, Double> testScores;
        
        public PathAnalysisResult(List<String> optimizedOrder, Map<String, Double> testScores) {
            this.optimizedOrder = optimizedOrder;
            this.testScores = testScores;
        }
        
        public List<String> getOptimizedOrder() {
            return optimizedOrder;
        }
        
        public Map<String, Double> getTestScores() {
            return testScores;
        }
    }
}



package com.cssmart.framework.ai;

import java.util.*;
import java.io.*;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.*;
import java.util.regex.*;
import java.util.stream.Collectors;

import com.cssmart.framework.config.ConfigurationManager;
import com.cssmart.framework.logging.LogManager;
import com.cssmart.framework.reporting.ReportManager;
import com.cssmart.framework.utils.StringUtils;

/**
 * Implements a sentiment analysis engine for analyzing test results
 * and identifying patterns in test failures
 */
public class SentimentAnalysisEngine {
    private static final LogManager logger = LogManager.getLogger(SentimentAnalysisEngine.class);
    private static SentimentAnalysisEngine instance;
    
    // Configuration
    private final boolean enabled;
    private final int maxLogSize;
    private final String logAnalysisPath;
    private final double sentimentThreshold;
    
    // NLP-related constants
    private static final Set<String> POSITIVE_INDICATORS = new HashSet<>(Arrays.asList(
        "pass", "passed", "success", "successful", "completed", "verified", "correct", 
        "expected", "properly", "ok", "valid", "true"
    ));
    
    private static final Set<String> NEGATIVE_INDICATORS = new HashSet<>(Arrays.asList(
        "fail", "failed", "error", "exception", "crash", "timeout", "invalid", 
        "incorrect", "unexpected", "wrong", "issue", "problem", "bug", "defect", "false",
        "not found", "null pointer", "assertion", "unable", "inaccessible"
    ));
    
    // Pattern collections
    private final Map<String, Pattern> errorPatterns;
    private final Map<String, Double> patternWeights;
    
    // Analysis caches
    private final Map<String, SentimentAnalysisResult> analysisCache;
    private final Map<String, List<String>> entityCache;
    
    // Thread pool for parallel processing
    private final ExecutorService executorService;
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private SentimentAnalysisEngine() {
        ConfigurationManager config = ConfigurationManager.getInstance();
        
        // Initialize configuration
        this.enabled = config.getBooleanProperty("sentiment.analysis.enabled", true);
        this.maxLogSize = config.getIntProperty("sentiment.analysis.max.log.size", 10 * 1024 * 1024); // 10MB
        this.logAnalysisPath = config.getProperty("sentiment.analysis.log.path", 
                                                 System.getProperty("java.io.tmpdir") + File.separator + 
                                                 "cssmart" + File.separator + "logs");
        this.sentimentThreshold = config.getDoubleProperty("sentiment.analysis.threshold", 0.1);
        
        // Initialize pattern collections
        this.errorPatterns = initializeErrorPatterns();
        this.patternWeights = initializePatternWeights();
        
        // Initialize caches
        this.analysisCache = new ConcurrentHashMap<>();
        this.entityCache = new ConcurrentHashMap<>();
        
        // Initialize thread pool
        this.executorService = Executors.newFixedThreadPool(
            config.getIntProperty("sentiment.analysis.threads", 
                                 Math.max(1, Runtime.getRuntime().availableProcessors() / 2))
        );
        
        logger.info("Sentiment Analysis Engine initialized. Enabled: " + enabled);
    }
    
    /**
     * Gets the singleton instance of SentimentAnalysisEngine
     */
    public static synchronized SentimentAnalysisEngine getInstance() {
        if (instance == null) {
            instance = new SentimentAnalysisEngine();
        }
        return instance;
    }
    
    /**
     * Initializes regex patterns for error detection
     */
    private Map<String, Pattern> initializeErrorPatterns() {
        Map<String, Pattern> patterns = new HashMap<>();
        
        // Common Java exceptions
        patterns.put("NullPointerException", 
                    Pattern.compile("(?i)java\\.lang\\.NullPointerException|NPE|null pointer"));
        patterns.put("IllegalArgumentException", 
                    Pattern.compile("(?i)java\\.lang\\.IllegalArgumentException"));
        patterns.put("ClassCastException", 
                    Pattern.compile("(?i)java\\.lang\\.ClassCastException"));
        patterns.put("IndexOutOfBoundsException", 
                    Pattern.compile("(?i)java\\.lang\\.(Index|ArrayIndex)OutOfBoundsException"));
        patterns.put("NoSuchElementException", 
                    Pattern.compile("(?i)java\\.util\\.NoSuchElementException"));
        
        // Selenium-specific errors
        patterns.put("ElementNotFound", 
                    Pattern.compile("(?i)no such element|element not found|unable to locate element"));
        patterns.put("StaleElementReference", 
                    Pattern.compile("(?i)stale element reference|element is stale|element reference is stale"));
        patterns.put("TimeoutException", 
                    Pattern.compile("(?i)timeout|timed out|wait timed out"));
        patterns.put("ElementNotInteractable", 
                    Pattern.compile("(?i)element not interactable|not clickable|element is not clickable"));
        patterns.put("ElementNotVisible", 
                    Pattern.compile("(?i)element not visible|element is not visible"));
        
        // Web application errors
        patterns.put("NetworkError", 
                    Pattern.compile("(?i)network error|connection refused|unable to connect|connection reset"));
        patterns.put("JavaScriptError", 
                    Pattern.compile("(?i)javascript error|js error|script error"));
        patterns.put("HttpError", 
                    Pattern.compile("(?i)status code [45][0-9]{2}|http [45][0-9]{2}|4[0-9]{2}|5[0-9]{2}"));
        
        // Application-specific errors
        patterns.put("ValidationError", 
                    Pattern.compile("(?i)validation (failed|error)|invalid (input|value|data)"));
        patterns.put("DataError", 
                    Pattern.compile("(?i)data (error|incorrect|invalid|missing)|database error"));
        patterns.put("LoginError", 
                    Pattern.compile("(?i)login (failed|error|incorrect)|authentication (failed|error)"));
        
        // Environment issues
        patterns.put("EnvironmentError", 
                    Pattern.compile("(?i)environment (issue|error)|configuration (issue|error)"));
        patterns.put("ResourceError", 
                    Pattern.compile("(?i)resource (not found|unavailable|error)|out of (memory|resources)"));
        
        // Create custom patterns from configuration if available
        ConfigurationManager config = ConfigurationManager.getInstance();
        String customPatterns = config.getProperty("sentiment.analysis.custom.patterns", "");
        
        if (!customPatterns.isEmpty()) {
            String[] entries = customPatterns.split(";");
            for (String entry : entries) {
                String[] parts = entry.split("=", 2);
                if (parts.length == 2) {
                    String name = parts[0].trim();
                    String regex = parts[1].trim();
                    try {
                        patterns.put(name, Pattern.compile(regex));
                    } catch (Exception e) {
                        logger.error("Invalid regex pattern in configuration: " + regex, e);
                    }
                }
            }
        }
        
        return patterns;
    }
    
    /**
     * Initializes pattern weights for scoring
     */
    private Map<String, Double> initializePatternWeights() {
        Map<String, Double> weights = new HashMap<>();
        
        // Default weights for different error types
        // Higher weight = more important for sentiment analysis
        
        // Critical errors
        weights.put("NullPointerException", 0.9);
        weights.put("IndexOutOfBoundsException", 0.8);
        weights.put("ClassCastException", 0.7);
        
        // Selenium errors
        weights.put("ElementNotFound", 0.8);
        weights.put("StaleElementReference", 0.7);
        weights.put("TimeoutException", 0.6);
        weights.put("ElementNotInteractable", 0.6);
        weights.put("ElementNotVisible", 0.5);
        
        // Web errors
        weights.put("NetworkError", 0.7);
        weights.put("JavaScriptError", 0.6);
        weights.put("HttpError", 0.5);
        
        // Application errors
        weights.put("ValidationError", 0.4);
        weights.put("DataError", 0.5);
        weights.put("LoginError", 0.6);
        
        // Environment issues
        weights.put("EnvironmentError", 0.7);
        weights.put("ResourceError", 0.6);
        
        // For any pattern without a specific weight, use a default
        for (String pattern : errorPatterns.keySet()) {
            if (!weights.containsKey(pattern)) {
                weights.put(pattern, 0.5); // Default weight
            }
        }
        
        return weights;
    }
    
    /**
     * Analyzes text content for sentiment
     * 
     * @param text The text to analyze
     * @return SentimentAnalysisResult containing the analysis
     */
    public SentimentAnalysisResult analyzeSentiment(String text) {
        if (!enabled || text == null || text.isEmpty()) {
            return new SentimentAnalysisResult(0.0, Collections.emptyMap(), Collections.emptyList());
        }
        
        try {
            // Check cache first
            String cacheKey = generateCacheKey(text);
            SentimentAnalysisResult cachedResult = analysisCache.get(cacheKey);
            if (cachedResult != null) {
                return cachedResult;
            }
            
            // Preprocess text
            String processedText = preprocessText(text);
            
            // Calculate basic sentiment score
            double sentimentScore = calculateBasicSentimentScore(processedText);
            
            // Find error patterns
            Map<String, Integer> detectedPatterns = findErrorPatterns(processedText);
            
            // Extract key entities
            List<String> entities = extractEntities(processedText);
            
            // Create result
            SentimentAnalysisResult result = new SentimentAnalysisResult(
                sentimentScore, detectedPatterns, entities);
            
            // Cache result
            analysisCache.put(cacheKey, result);
            
            return result;
        } catch (Exception e) {
            logger.error("Error analyzing sentiment: " + e.getMessage(), e);
            return new SentimentAnalysisResult(0.0, Collections.emptyMap(), Collections.emptyList());
        }
    }
    
    /**
     * Preprocesses text for analysis
     */
    private String preprocessText(String text) {
        if (text == null) return "";
        
        // Limit text size for performance
        if (text.length() > maxLogSize) {
            text = text.substring(0, maxLogSize);
        }
        
        // Convert to lowercase for case-insensitive matching
        String processed = text.toLowerCase();
        
        // Remove irrelevant noise
        processed = processed.replaceAll("\\[INFO\\]|\\[DEBUG\\]", " ");
        processed = processed.replaceAll("\\d{2}:\\d{2}:\\d{2}\\.\\d{3}", " "); // Remove timestamps
        processed = processed.replaceAll("\\r\\n|\\r|\\n", " "); // Normalize line breaks
        processed = processed.replaceAll("\\s+", " "); // Normalize whitespace
        
        return processed;
    }
    
    /**
     * Calculates a basic sentiment score from text
     * Returns a value between -1 (negative) and 1 (positive)
     */
    private double calculateBasicSentimentScore(String text) {
        if (text == null || text.isEmpty()) {
            return 0.0;
        }
        
        // Split into words for analysis
        String[] words = text.split("\\s+");
        
        int positiveCount = 0;
        int negativeCount = 0;
        
        // Count positive and negative indicator words
        for (String word : words) {
            if (POSITIVE_INDICATORS.contains(word)) {
                positiveCount++;
            } else if (NEGATIVE_INDICATORS.contains(word)) {
                negativeCount++;
            }
            
            // Check for negations that flip sentiment
            boolean hasNegation = word.equals("not") || word.equals("no") || 
                                  word.startsWith("un") || word.startsWith("dis");
            
            if (hasNegation) {
                // If we find a negation, look ahead for indicators to flip
                int lookAheadLimit = 3; // Check next 3 words maximum
                for (int i = 1; i <= lookAheadLimit && i < words.length; i++) {
                    String nextWord = words[i];
                    if (POSITIVE_INDICATORS.contains(nextWord)) {
                        positiveCount--;
                        negativeCount++;
                        break;
                    } else if (NEGATIVE_INDICATORS.contains(nextWord)) {
                        negativeCount--;
                        positiveCount++;
                        break;
                    }
                }
            }
        }
        
        // Calculate ratio of sentiment indicators to total words
        int totalIndicators = positiveCount + negativeCount;
        if (totalIndicators == 0) {
            return 0.0; // Neutral if no indicators
        }
        
        // Calculate sentiment score (-1 to 1)
        return (double)(positiveCount - negativeCount) / totalIndicators;
    }
    
    /**
     * Finds error patterns in the text
     */
    private Map<String, Integer> findErrorPatterns(String text) {
        Map<String, Integer> results = new HashMap<>();
        
        if (text == null || text.isEmpty()) {
            return results;
        }
        
        // Check each pattern
        for (Map.Entry<String, Pattern> entry : errorPatterns.entrySet()) {
            String patternName = entry.getKey();
            Pattern pattern = entry.getValue();
            
            // Count matches
            Matcher matcher = pattern.matcher(text);
            int count = 0;
            while (matcher.find()) {
                count++;
            }
            
            if (count > 0) {
                results.put(patternName, count);
            }
        }
        
        return results;
    }
    
    /**
     * Extracts key entities from text
     */
    private List<String> extractEntities(String text) {
        if (text == null || text.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Get cache key for this text
        String cacheKey = generateCacheKey(text);
        
        // Check cache first
        List<String> cachedEntities = entityCache.get(cacheKey);
        if (cachedEntities != null) {
            return cachedEntities;
        }
        
        Set<String> entities = new HashSet<>();
        
        try {
            // Extract class names (typical Java/Selenium class pattern)
            Pattern classPattern = Pattern.compile("(?i)\\b(?:[a-z][a-z0-9]*\\.)+[A-Z][a-zA-Z0-9]*\\b");
            Matcher classMatcher = classPattern.matcher(text);
            while (classMatcher.find()) {
                entities.add(classMatcher.group());
            }
            
            // Extract element identifiers (XPath, CSS, ID patterns)
            extractElementIdentifiers(text, entities);
            
            // Extract URLs
            Pattern urlPattern = Pattern.compile("(?i)https?://[^\\s/$.?#].[^\\s]*");
            Matcher urlMatcher = urlPattern.matcher(text);
            while (urlMatcher.find()) {
                entities.add(urlMatcher.group());
            }
            
            // Extract element text (text in quotes)
            Pattern textPattern = Pattern.compile("\"([^\"]{3,})\"");
            Matcher textMatcher = textPattern.matcher(text);
            while (textMatcher.find()) {
                entities.add(textMatcher.group(1));
            }
            
            List<String> result = new ArrayList<>(entities);
            
            // Cache results
            entityCache.put(cacheKey, result);
            
            return result;
        } catch (Exception e) {
            logger.debug("Error extracting entities: " + e.getMessage(), e);
            return new ArrayList<>(entities);
        }
    }
    
    /**
     * Extracts element identifiers from text
     */
    private void extractElementIdentifiers(String text, Set<String> entities) {
        // Extract XPath expressions
        Pattern xpathPattern = Pattern.compile("(?i)xpath\\s*=\\s*(?:\"([^\"]+)\"|'([^']+)')");
        Matcher xpathMatcher = xpathPattern.matcher(text);
        while (xpathMatcher.find()) {
            String xpath = xpathMatcher.group(1) != null ? xpathMatcher.group(1) : xpathMatcher.group(2);
            entities.add("xpath:" + xpath);
        }
        
        // Extract CSS selectors
        Pattern cssPattern = Pattern.compile("(?i)css\\s*=\\s*(?:\"([^\"]+)\"|'([^']+)')");
        Matcher cssMatcher = cssPattern.matcher(text);
        while (cssMatcher.find()) {
            String css = cssMatcher.group(1) != null ? cssMatcher.group(1) : cssMatcher.group(2);
            entities.add("css:" + css);
        }
        
        // Extract IDs
        Pattern idPattern = Pattern.compile("(?i)id\\s*=\\s*(?:\"([^\"]+)\"|'([^']+)')");
        Matcher idMatcher = idPattern.matcher(text);
        while (idMatcher.find()) {
            String id = idMatcher.group(1) != null ? idMatcher.group(1) : idMatcher.group(2);
            entities.add("id:" + id);
        }
    }
    
    /**
     * Generates a cache key for text
     */
    private String generateCacheKey(String text) {
        if (text == null) return "";
        
        // Use a simple hash as the key to avoid storing full text
        int hash = text.hashCode();
        return String.valueOf(hash);
    }
    
    /**
     * Analyzes test logs for sentiment and patterns
     */
    public TestLogAnalysisResult analyzeTestLogs(String testId, String logContent) {
        if (!enabled || logContent == null || logContent.isEmpty()) {
            return new TestLogAnalysisResult(testId, 0.0, Collections.emptyMap(), 
                                           Collections.emptyList(), Collections.emptyMap());
        }
        
        try {
            // Analyze overall sentiment
            SentimentAnalysisResult sentiment = analyzeSentiment(logContent);
            
            // Find error patterns
            Map<String, Integer> errorCounts = sentiment.getDetectedPatterns();
            
            // Extract entities
            List<String> entities = sentiment.getEntities();
            
            // Calculate pattern scores
            Map<String, Double> patternScores = calculatePatternScores(errorCounts);
            
            // Create result
            return new TestLogAnalysisResult(testId, sentiment.getSentimentScore(), 
                                           errorCounts, entities, patternScores);
        } catch (Exception e) {
            logger.error("Error analyzing test logs: " + e.getMessage(), e);
            return new TestLogAnalysisResult(testId, 0.0, Collections.emptyMap(), 
                                           Collections.emptyList(), Collections.emptyMap());
        }
    }
    
    /**
     * Calculates scores for detected patterns based on weights
     */
    private Map<String, Double> calculatePatternScores(Map<String, Integer> patternCounts) {
        Map<String, Double> scores = new HashMap<>();
        
        for (Map.Entry<String, Integer> entry : patternCounts.entrySet()) {
            String pattern = entry.getKey();
            int count = entry.getValue();
            
            // Get weight for this pattern
            double weight = patternWeights.getOrDefault(pattern, 0.5);
            
            // Calculate score based on count and weight
            double score = count * weight;
            
            scores.put(pattern, score);
        }
        
        return scores;
    }
    
    /**
     * Analyzes build logs for patterns and sentiment
     */
    public BuildLogAnalysisResult analyzeBuildLogs(String buildId, List<String> logFiles) {
        if (!enabled || logFiles == null || logFiles.isEmpty()) {
            return new BuildLogAnalysisResult(buildId, 0.0, Collections.emptyMap(), 
                                            Collections.emptyList(), Collections.emptyMap());
        }
        
        try {
            List<Future<SentimentAnalysisResult>> futures = new ArrayList<>();
            
            // Submit analysis tasks for each log file
            for (String logFile : logFiles) {
                futures.add(executorService.submit(() -> {
                    String content = readLogFile(logFile);
                    return analyzeSentiment(content);
                }));
            }
            
            // Aggregate results
            double totalSentiment = 0.0;
            Map<String, Integer> aggregatedPatterns = new HashMap<>();
            Set<String> aggregatedEntities = new HashSet<>();
            
            for (Future<SentimentAnalysisResult> future : futures) {
                SentimentAnalysisResult result = future.get();
                
                // Sum sentiment scores
                totalSentiment += result.getSentimentScore();
                
                // Merge patterns
                for (Map.Entry<String, Integer> entry : result.getDetectedPatterns().entrySet()) {
                    String pattern = entry.getKey();
                    int count = entry.getValue();
                    
                    aggregatedPatterns.merge(pattern, count, Integer::sum);
                }
                
                // Merge entities
                aggregatedEntities.addAll(result.getEntities());
            }
            
            // Calculate average sentiment
            double avgSentiment = totalSentiment / logFiles.size();
            
            // Calculate pattern scores
            Map<String, Double> patternScores = calculatePatternScores(aggregatedPatterns);
            
            // Create result
            return new BuildLogAnalysisResult(buildId, avgSentiment, aggregatedPatterns,
                                            new ArrayList<>(aggregatedEntities), patternScores);
        } catch (Exception e) {
            logger.error("Error analyzing build logs: " + e.getMessage(), e);
            return new BuildLogAnalysisResult(buildId, 0.0, Collections.emptyMap(), 
                                            Collections.emptyList(), Collections.emptyMap());
        }
    }
    
    /**
     * Reads a log file's content
     */
    private String readLogFile(String filePath) throws IOException {
        if (filePath == null || filePath.isEmpty()) {
            return "";
        }
        
        Path path = Paths.get(filePath);
        if (!Files.exists(path)) {
            logger.warn("Log file does not exist: " + filePath);
            return "";
        }
        
        // Check file size and limit if needed
        long fileSize = Files.size(path);
        if (fileSize > maxLogSize) {
            // Read only the first and last parts of large files
            byte[] firstPart = new byte[maxLogSize / 2];
            byte[] lastPart = new byte[maxLogSize / 2];
            
            try (RandomAccessFile raf = new RandomAccessFile(filePath, "r")) {
                // Read first part
                raf.read(firstPart);
                
                // Read last part
                raf.seek(fileSize - (maxLogSize / 2));
                raf.read(lastPart);
            }
            
            return new String(firstPart) + "\n[...]\n" + new String(lastPart);
        } else {
            // Read entire file for smaller files
            return new String(Files.readAllBytes(path));
        }
    }
    
    /**
     * Analyzes multiple test runs to identify patterns
     */
    public TestRunPatternAnalysisResult analyzeTestRunPatterns(List<String> testIds, List<String> logFiles) {
        if (!enabled || testIds == null || testIds.isEmpty() || logFiles == null || logFiles.isEmpty()) {
            return new TestRunPatternAnalysisResult(Collections.emptyMap(), Collections.emptyMap(), 
                                                 Collections.emptyMap(), Collections.emptyList());
        }
        
        try {
            // Analyze each test log
            List<TestLogAnalysisResult> testResults = new ArrayList<>();
            
            for (int i = 0; i < testIds.size() && i < logFiles.size(); i++) {
                String testId = testIds.get(i);
                String logFile = logFiles.get(i);
                
                String content = readLogFile(logFile);
                TestLogAnalysisResult result = analyzeTestLogs(testId, content);
                
                testResults.add(result);
            }
            
            // Calculate frequency of patterns across tests
            Map<String, Integer> patternFrequency = calculatePatternFrequency(testResults);
            
            // Calculate correlation between patterns and test failures
            Map<String, Double> patternFailureCorrelation = calculatePatternFailureCorrelation(testResults);
            
            // Cluster tests by common patterns
            Map<String, List<String>> testClusters = clusterTestsByPatterns(testResults);
            
            // Identify common entities across tests
            List<String> commonEntities = findCommonEntities(testResults);
            
            // Create result
            return new TestRunPatternAnalysisResult(patternFrequency, patternFailureCorrelation,
                                                 testClusters, commonEntities);
        } catch (Exception e) {
            logger.error("Error analyzing test run patterns: " + e.getMessage(), e);
            return new TestRunPatternAnalysisResult(Collections.emptyMap(), Collections.emptyMap(), 
                                                 Collections.emptyMap(), Collections.emptyList());
        }
    }
    
    /**
     * Calculates frequency of patterns across test results
     */
    private Map<String, Integer> calculatePatternFrequency(List<TestLogAnalysisResult> testResults) {
        Map<String, Integer> frequency = new HashMap<>();
        
        for (TestLogAnalysisResult result : testResults) {
            for (String pattern : result.getErrorCounts().keySet()) {
                frequency.merge(pattern, 1, Integer::sum);
            }
        }
        
        return frequency;
    }
    
    /**
     * Calculates correlation between patterns and test failures
     */
    private Map<String, Double> calculatePatternFailureCorrelation(List<TestLogAnalysisResult> testResults) {
        Map<String, Double> correlation = new HashMap<>();
        
        // Count occurrences of each pattern in failed tests
        Map<String, Integer> patternInFailedTests = new HashMap<>();
        
        // Count total failed tests and total occurrences of each pattern
        int failedTestCount = 0;
        
        for (TestLogAnalysisResult result : testResults) {
            // Consider strongly negative sentiment as failure indicator
            boolean isFailure = result.getSentimentScore() < -0.3;
            
            if (isFailure) {
                failedTestCount++;
                
                for (String pattern : result.getErrorCounts().keySet()) {
                    patternInFailedTests.merge(pattern, 1, Integer::sum);
                }
            }
        }
        
        // Calculate correlation for each pattern
        Map<String, Integer> patternFrequency = calculatePatternFrequency(testResults);
        
        for (Map.Entry<String, Integer> entry : patternFrequency.entrySet()) {
            String pattern = entry.getKey();
            int totalOccurrences = entry.getValue();
            
            int occurrencesInFailures = patternInFailedTests.getOrDefault(pattern, 0);
            
            // No failures or no occurrences in failures
            if (failedTestCount == 0 || occurrencesInFailures == 0) {
                correlation.put(pattern, 0.0);
                continue;
            }
            
            // Calculate correlation coefficient
            double failureRatio = (double) occurrencesInFailures / failedTestCount;
            double totalRatio = (double) totalOccurrences / testResults.size();
            
            double correlationValue = failureRatio / totalRatio;
            
            // Normalize correlation to -1 to 1 range
            correlationValue = Math.min(1.0, correlationValue);
            
            correlation.put(pattern, correlationValue);
        }
        
        return correlation;
    }
    
    /**
     * Clusters tests by common error patterns
     */
    private Map<String, List<String>> clusterTestsByPatterns(List<TestLogAnalysisResult> testResults) {
        Map<String, List<String>> clusters = new HashMap<>();
        
        // Find significant patterns (occurring in multiple tests)
        Map<String, Integer> patternFrequency = calculatePatternFrequency(testResults);
        Set<String> significantPatterns = patternFrequency.entrySet().stream()
            .filter(e -> e.getValue() > 1) // Only patterns in multiple tests
            .map(Map.Entry::getKey)
            .collect(Collectors.toSet());
        
        // Create clusters for each significant pattern
        for (String pattern : significantPatterns) {
            List<String> clusterTests = new ArrayList<>();
            
            for (TestLogAnalysisResult result : testResults) {
                if (result.getErrorCounts().containsKey(pattern)) {
                    clusterTests.add(result.getTestId());
                }
            }
            
            if (!clusterTests.isEmpty()) {
                clusters.put(pattern, clusterTests);
            }
        }
        
        return clusters;
    }
    
    /**
     * Finds common entities across test results
     */
    private List<String> findCommonEntities(List<TestLogAnalysisResult> testResults) {
        if (testResults.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Count entity occurrences
        Map<String, Integer> entityCounts = new HashMap<>();
        
        for (TestLogAnalysisResult result : testResults) {
            for (String entity : result.getEntities()) {
                entityCounts.merge(entity, 1, Integer::sum);
            }
        }
        
        // Find entities that appear in multiple tests
        int threshold = Math.max(2, testResults.size() / 3); // At least 2 or 1/3 of tests
        
        return entityCounts.entrySet().stream()
            .filter(e -> e.getValue() >= threshold)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
    
    /**
     * Analyzes a test failure and provides recommendations
     */
    public FailureAnalysisResult analyzeFailure(String testId, String logContent) {
        if (!enabled || logContent == null || logContent.isEmpty()) {
            return new FailureAnalysisResult(testId, Collections.emptyList(), Collections.emptyList(),
                                          Collections.emptyMap(), 0.0);
        }
        
        try {
            // Analyze test logs for sentiment and patterns
            TestLogAnalysisResult logAnalysis = analyzeTestLogs(testId, logContent);
            
            // Determine possible root causes
            List<String> rootCauses = identifyRootCauses(logAnalysis);
            
            // Generate recommendations
            List<String> recommendations = generateRecommendations(logAnalysis, rootCauses);
            
            // Calculate confidence scores for each root cause
            Map<String, Double> confidenceScores = calculateConfidenceScores(logAnalysis, rootCauses);
            
            // Overall confidence score
            double overallConfidence = calculateOverallConfidence(confidenceScores);
            
            return new FailureAnalysisResult(testId, rootCauses, recommendations,
                                          confidenceScores, overallConfidence);
        } catch (Exception e) {
            logger.error("Error analyzing failure: " + e.getMessage(), e);
            return new FailureAnalysisResult(testId, Collections.emptyList(), Collections.emptyList(),
                                          Collections.emptyMap(), 0.0);
        }
    }
    
    /**
     * Identifies potential root causes from test analysis
     */
    private List<String> identifyRootCauses(TestLogAnalysisResult analysis) {
        List<String> causes = new ArrayList<>();
        
        // Get patterns sorted by score
        List<Map.Entry<String, Double>> sortedPatterns = new ArrayList<>(analysis.getPatternScores().entrySet());
        sortedPatterns.sort(Map.Entry.<String, Double>comparingByValue().reversed());
        
        // Top patterns are likely causes
        for (int i = 0; i < Math.min(3, sortedPatterns.size()); i++) {
            String pattern = sortedPatterns.get(i).getKey();
            double score = sortedPatterns.get(i).getValue();
            
            // Only include if score is significant
            if (score >= sentimentThreshold) {
                causes.add(pattern);
            }
        }
        
        // Check for timing issues
        if (analysis.getErrorCounts().containsKey("TimeoutException")) {
            causes.add("TimingIssue");
        }
        
        // Check for element locator issues
        if (analysis.getErrorCounts().containsKey("ElementNotFound") ||
            analysis.getErrorCounts().containsKey("StaleElementReference")) {
            causes.add("ElementLocatorIssue");
        }
        
        // Check for network issues
        if (analysis.getErrorCounts().containsKey("NetworkError") ||
            analysis.getErrorCounts().containsKey("HttpError")) {
            causes.add("NetworkIssue");
        }
        
        // Check for JavaScript errors
        if (analysis.getErrorCounts().containsKey("JavaScriptError")) {
            causes.add("JavaScriptIssue");
        }
        
        // Check for environment issues
        if (analysis.getErrorCounts().containsKey("EnvironmentError") ||
            analysis.getErrorCounts().containsKey("ResourceError")) {
            causes.add("EnvironmentIssue");
        }
        
        return causes;
    }
    
    /**
     * Generates recommendations based on analysis and root causes
     */
    private List<String> generateRecommendations(TestLogAnalysisResult analysis, List<String> rootCauses) {
        List<String> recommendations = new ArrayList<>();
        
        // Generate specific recommendations based on root causes
        for (String cause : rootCauses) {
            switch (cause) {
                case "ElementNotFound":
                    recommendations.add("Check if element selectors are correct");
                    recommendations.add("Verify the element exists in the DOM at the time of interaction");
                    recommendations.add("Consider using explicit waits");
                    break;
                    
                case "StaleElementReference":
                    recommendations.add("Re-locate the element before each interaction");
                    recommendations.add("Avoid storing element references across page navigations");
                    recommendations.add("Consider using the Page Object Model pattern");
                    break;
                    
                case "TimeoutException":
                case "TimingIssue":
                    recommendations.add("Increase timeout duration for slow operations");
                    recommendations.add("Use proper wait conditions instead of sleep/fixed waits");
                    recommendations.add("Verify application performance under test conditions");
                    break;
                    
                case "ElementNotInteractable":
                case "ElementNotVisible":
                    recommendations.add("Ensure the element is visible and not obscured");
                    recommendations.add("Check if the element is in the viewport");
                    recommendations.add("Use JavaScript executor for problematic clicks");
                    break;
                    
                case "NetworkIssue":
                    recommendations.add("Check network connectivity and proxy settings");
                    recommendations.add("Verify URL and endpoint availability");
                    recommendations.add("Consider adding retry mechanisms for network operations");
                    break;
                    
                case "JavaScriptIssue":
                    recommendations.add("Check for JavaScript errors in the browser console");
                    recommendations.add("Verify JavaScript dependencies are loaded correctly");
                    recommendations.add("Consider using browserstack or crossbrowsertesting for browser compatibility issues");
                    break;
                    
                case "ElementLocatorIssue":
                    recommendations.add("Use more robust locators (like ID or name instead of XPath)");
                    recommendations.add("Consider implementing self-healing element locators");
                    recommendations.add("Use relative XPaths instead of absolute paths");
                    break;
                    
                case "EnvironmentIssue":
                    recommendations.add("Verify test environment configuration");
                    recommendations.add("Check system resources (memory, CPU, disk space)");
                    recommendations.add("Ensure browser and driver versions are compatible");
                    break;
                    
                default:
                    // Generic recommendations for unknown causes
                    recommendations.add("Review test logs for detailed error messages");
                    recommendations.add("Check for recent application changes that might affect this test");
                    recommendations.add("Consider refactoring the test for better stability");
            }
        }
        
        // Add general recommendations if we have few specific ones
        if (recommendations.size() < 3) {
            recommendations.add("Implement proper logging to capture more detailed diagnostic information");
            recommendations.add("Consider using explicit waits for dynamic elements");
            recommendations.add("Review the test data prerequisites");
        }
        
        return recommendations;
    }
    
    /**
     * Calculates confidence scores for root causes
     */
    private Map<String, Double> calculateConfidenceScores(TestLogAnalysisResult analysis, List<String> rootCauses) {
        Map<String, Double> confidenceScores = new HashMap<>();
        
        for (String cause : rootCauses) {
            // Base confidence from pattern scores if available
            double baseConfidence = analysis.getPatternScores().getOrDefault(cause, 0.5);
            
            // Adjust based on additional factors
            double adjustedConfidence = baseConfidence;
            
            // Higher confidence for exact pattern matches
            if (analysis.getErrorCounts().containsKey(cause)) {
                adjustedConfidence *= 1.2;
            }
            
            // Adjust based on sentiment score (more negative = more confident in error)
            double sentimentFactor = 1.0 - ((analysis.getSentimentScore() + 1.0) / 2.0);
            adjustedConfidence *= (0.8 + (sentimentFactor * 0.4)); // 0.8 to 1.2 adjustment
            
            // Normalize confidence score to 0-1
            confidenceScores.put(cause, Math.min(1.0, adjustedConfidence));
        }
        
        return confidenceScores;
    }
    
    /**
     * Calculates overall confidence from individual confidence scores
     */
    private double calculateOverallConfidence(Map<String, Double> confidenceScores) {
        if (confidenceScores.isEmpty()) {
            return 0.0;
        }
        
        // Calculate weighted average of confidence scores
        double sum = 0.0;
        double weightSum = 0.0;
        
        // Sort scores in descending order for weighting
        List<Map.Entry<String, Double>> sortedScores = new ArrayList<>(confidenceScores.entrySet());
        sortedScores.sort(Map.Entry.<String, Double>comparingByValue().reversed());
        
        // Apply weights (higher confidence gets higher weight)
        double weight = 1.0;
        double weightDecay = 0.7; // Decay factor for weights
        
        for (Map.Entry<String, Double> entry : sortedScores) {
            sum += entry.getValue() * weight;
            weightSum += weight;
            weight *= weightDecay; // Reduce weight for next item
        }
        
        return sum / weightSum;
    }
    
    /**
     * Analyzes historical patterns for a specific test
     */
    public HistoricalPatternResult analyzeHistoricalPatterns(String testId, List<String> logFiles) {
        if (!enabled || testId == null || logFiles == null || logFiles.isEmpty()) {
            return new HistoricalPatternResult(testId, Collections.emptyMap(), Collections.emptyMap(), 
                                             0.0, Collections.emptyList());
        }
        
        try {
            List<TestLogAnalysisResult> analysisResults = new ArrayList<>();
            
            // Analyze each log file
            for (String logFile : logFiles) {
                String content = readLogFile(logFile);
                TestLogAnalysisResult result = analyzeTestLogs(testId, content);
                analysisResults.add(result);
            }
            
            // Track pattern frequency over time
            Map<String, List<Integer>> patternHistory = new HashMap<>();
            
            // Track sentiment score over time
            List<Double> sentimentHistory = new ArrayList<>();
            
            // Process each result in chronological order
            for (TestLogAnalysisResult result : analysisResults) {
                // Add sentiment score
                sentimentHistory.add(result.getSentimentScore());
                
                // Add pattern counts
                for (Map.Entry<String, Integer> entry : result.getErrorCounts().entrySet()) {
                    String pattern = entry.getKey();
                    int count = entry.getValue();
                    
                    List<Integer> history = patternHistory.computeIfAbsent(pattern, k -> new ArrayList<>());
                    history.add(count);
                }
                
                // Add zeros for patterns not found in this run
                for (Map.Entry<String, List<Integer>> entry : patternHistory.entrySet()) {
                    List<Integer> history = entry.getValue();
                    if (history.size() < sentimentHistory.size()) {
                        history.add(0);
                    }
                }
            }
            
            // Calculate trend scores for each pattern
            Map<String, Double> patternTrends = calculatePatternTrends(patternHistory);
            
            // Calculate overall sentiment trend
            double sentimentTrend = calculateSentimentTrend(sentimentHistory);
            
            // Identify recurring entities
            List<String> recurringEntities = identifyRecurringEntities(analysisResults);
            
            return new HistoricalPatternResult(testId, patternHistory, patternTrends, 
                                             sentimentTrend, recurringEntities);
        } catch (Exception e) {
            logger.error("Error analyzing historical patterns: " + e.getMessage(), e);
            return new HistoricalPatternResult(testId, Collections.emptyMap(), Collections.emptyMap(), 
                                             0.0, Collections.emptyList());
        }
    }
    
    /**
     * Calculates trends in pattern occurrence over time
     */
    private Map<String, Double> calculatePatternTrends(Map<String, List<Integer>> patternHistory) {
        Map<String, Double> trends = new HashMap<>();
        
        for (Map.Entry<String, List<Integer>> entry : patternHistory.entrySet()) {
            String pattern = entry.getKey();
            List<Integer> history = entry.getValue();
            
            if (history.size() < 2) {
                trends.put(pattern, 0.0); // Not enough data
                continue;
            }
            
            // Calculate simple linear regression slope
            double slope = calculateSlope(history);
            
            // Normalize trend to -1 to 1 range
            double maxSlope = 0.5; // Maximum expected slope
            double trend = Math.max(-1.0, Math.min(1.0, slope / maxSlope));
            
            trends.put(pattern, trend);
        }
        
        return trends;
    }
    
    /**
     * Calculates trend in sentiment scores over time
     */
    private double calculateSentimentTrend(List<Double> sentimentHistory) {
        if (sentimentHistory.size() < 2) {
            return 0.0; // Not enough data
        }
        
        // Calculate simple linear regression slope
        double slope = calculateSlope(sentimentHistory);
        
        // Normalize trend to -1 to 1 range
        double maxSlope = 0.2; // Maximum expected slope
        return Math.max(-1.0, Math.min(1.0, slope / maxSlope));
    }
    
    /**
     * Calculates linear regression slope for a list of values
     */
    private double calculateSlope(List<? extends Number> values) {
        int n = values.size();
        
        // X values are just the indices (0, 1, 2, ...)
        double sumX = 0;
        double sumY = 0;
        double sumXY = 0;
        double sumXX = 0;
        
        for (int i = 0; i < n; i++) {
            double x = i;
            double y = values.get(i).doubleValue();
            
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
        }
        
        // Calculate slope: (n*sumXY - sumX*sumY) / (n*sumXX - sumX*sumX)
        double denominator = (n * sumXX) - (sumX * sumX);
        if (Math.abs(denominator) < 1e-10) {
            return 0.0; // Avoid division by zero
        }
        
        return ((n * sumXY) - (sumX * sumY)) / denominator;
    }
    
    /**
     * Identifies entities that appear in multiple test runs
     */
    private List<String> identifyRecurringEntities(List<TestLogAnalysisResult> results) {
        if (results.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Count entity occurrences
        Map<String, Integer> entityCounts = new HashMap<>();
        
        for (TestLogAnalysisResult result : results) {
            for (String entity : result.getEntities()) {
                entityCounts.merge(entity, 1, Integer::sum);
            }
        }
        
        // Find entities that appear in multiple test runs
        int threshold = Math.max(2, results.size() / 3); // At least 2 or 1/3 of runs
        
        return entityCounts.entrySet().stream()
            .filter(e -> e.getValue() >= threshold)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
    
    /**
     * Stores test run information with analysis results to file system
     */
    public void storeTestRunAnalysis(String testId, TestLogAnalysisResult analysis) {
        if (!enabled || testId == null || analysis == null) {
            return;
        }
        
        try {
            // Create directory if it doesn't exist
            Path directory = Paths.get(logAnalysisPath);
            if (!Files.exists(directory)) {
                Files.createDirectories(directory);
            }
            
            // Create a unique filename based on test ID and timestamp
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String filename = testId.replaceAll("[^a-zA-Z0-9-_]", "_") + "_" + timestamp + ".json";
            
            Path filePath = directory.resolve(filename);
            
            // Convert analysis to JSON and write to file
            String json = convertAnalysisToJson(analysis);
            Files.write(filePath, json.getBytes());
            
            logger.debug("Stored test run analysis for " + testId + " to " + filePath);
        } catch (Exception e) {
            logger.error("Error storing test run analysis: " + e.getMessage(), e);
        }
    }
    
    /**
     * Converts analysis result to JSON string
     */
    private String convertAnalysisToJson(TestLogAnalysisResult analysis) {
        StringBuilder json = new StringBuilder();
        json.append("{");
        
        json.append("\"testId\":\"").append(analysis.getTestId()).append("\",");
        json.append("\"sentimentScore\":").append(analysis.getSentimentScore()).append(",");
        
        // Add error counts
        json.append("\"errorCounts\":{");
        boolean first = true;
        for (Map.Entry<String, Integer> entry : analysis.getErrorCounts().entrySet()) {
            if (!first) json.append(",");
            json.append("\"").append(entry.getKey()).append("\":")
                .append(entry.getValue());
            first = false;
        }
        json.append("},");
        
        // Add entities
        json.append("\"entities\":[");
        first = true;
        for (String entity : analysis.getEntities()) {
            if (!first) json.append(",");
            json.append("\"").append(entity.replace("\"", "\\\"")).append("\"");
            first = false;
        }
        json.append("],");
        
        // Add pattern scores
        json.append("\"patternScores\":{");
        first = true;
        for (Map.Entry<String, Double> entry : analysis.getPatternScores().entrySet()) {
            if (!first) json.append(",");
            json.append("\"").append(entry.getKey()).append("\":")
                .append(entry.getValue());
            first = false;
        }
        json.append("},");
        
        // Add timestamp
        json.append("\"timestamp\":\"").append(
            LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)).append("\"");
        
        json.append("}");
        return json.toString();
    }
    
    /**
     * Loads historical analysis for a test
     */
    public List<TestLogAnalysisResult> loadTestHistory(String testId, int limit) {
        List<TestLogAnalysisResult> results = new ArrayList<>();
        
        if (!enabled || testId == null) {
            return results;
        }
        
        try {
            // Create sanitized test ID for filename matching
            String sanitizedTestId = testId.replaceAll("[^a-zA-Z0-9-_]", "_");
            
            // Get all matching files
            Path directory = Paths.get(logAnalysisPath);
            if (!Files.exists(directory)) {
                return results;
            }
            
            List<Path> matchingFiles = Files.list(directory)
                .filter(path -> path.getFileName().toString().startsWith(sanitizedTestId + "_"))
                .sorted((p1, p2) -> p2.getFileName().toString().compareTo(p1.getFileName().toString())) // Sort desc
                .limit(limit)
                .collect(Collectors.toList());
            
            // Parse each file
            for (Path filePath : matchingFiles) {
                try {
                    String content = new String(Files.readAllBytes(filePath));
                    TestLogAnalysisResult result = parseAnalysisFromJson(content);
                    if (result != null) {
                        results.add(result);
                    }
                } catch (Exception e) {
                    logger.debug("Error parsing analysis file: " + filePath, e);
                }
            }
        } catch (Exception e) {
            logger.error("Error loading test history: " + e.getMessage(), e);
        }
        
        return results;
    }
    
    /**
     * Parses analysis result from JSON string
     */
    private TestLogAnalysisResult parseAnalysisFromJson(String json) {
        try {
            // Extract test ID
            Pattern testIdPattern = Pattern.compile("\"testId\"\\s*:\\s*\"([^\"]+)\"");
            Matcher matcher = testIdPattern.matcher(json);
            if (!matcher.find()) {
                return null;
            }
            String testId = matcher.group(1);
            
            // Extract sentiment score
            Pattern scorePattern = Pattern.compile("\"sentimentScore\"\\s*:\\s*(-?\\d+(\\.\\d+)?)");
            matcher = scorePattern.matcher(json);
            double sentimentScore = matcher.find() ? Double.parseDouble(matcher.group(1)) : 0.0;
            
            // Extract error counts
            Map<String, Integer> errorCounts = parseMapFromJson(json, "errorCounts", Integer.class);
            
            // Extract entities
            List<String> entities = parseStringListFromJson(json, "entities");
            
            // Extract pattern scores
            Map<String, Double> patternScores = parseMapFromJson(json, "patternScores", Double.class);
            
            return new TestLogAnalysisResult(testId, sentimentScore, errorCounts, entities, patternScores);
        } catch (Exception e) {
            logger.debug("Error parsing analysis JSON: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a list of strings from a JSON object field
     */
    private List<String> parseStringListFromJson(String json, String fieldName) {
        List<String> result = new ArrayList<>();
        
        try {
            String pattern = "\"" + fieldName + "\"\\s*:\\s*\\[(.*?)\\]";
            Pattern p = Pattern.compile(pattern, Pattern.DOTALL);
            Matcher m = p.matcher(json);
            
            if (m.find()) {
                String arrayContent = m.group(1);
                Pattern itemPattern = Pattern.compile("\"([^\"]*)\"");
                Matcher itemMatcher = itemPattern.matcher(arrayContent);
                
                while (itemMatcher.find()) {
                    result.add(itemMatcher.group(1));
                }
            }
        } catch (Exception e) {
            logger.debug("Error parsing string list from JSON: " + e.getMessage());
        }
        
        return result;
    }
    
    /**
     * Parses a map from a JSON object field
     */
    private <T extends Number> Map<String, T> parseMapFromJson(String json, String fieldName, Class<T> valueType) {
        Map<String, T> result = new HashMap<>();
        
        try {
            String pattern = "\"" + fieldName + "\"\\s*:\\s*\\{(.*?)\\}";
            Pattern p = Pattern.compile(pattern, Pattern.DOTALL);
            Matcher m = p.matcher(json);
            
            if (m.find()) {
                String mapContent = m.group(1);
                Pattern entryPattern = Pattern.compile("\"([^\"]+)\"\\s*:\\s*(-?\\d+(\\.\\d+)?)");
                Matcher entryMatcher = entryPattern.matcher(mapContent);
                
                while (entryMatcher.find()) {
                    String key = entryMatcher.group(1);
                    String valueStr = entryMatcher.group(2);
                    
                    if (valueType == Integer.class) {
                        result.put(key, valueType.cast(Integer.parseInt(valueStr)));
                    } else if (valueType == Double.class) {
                        result.put(key, valueType.cast(Double.parseDouble(valueStr)));
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Error parsing map from JSON: " + e.getMessage());
        }
        
        return result;
    }
    
    /**
     * Shutdown the sentiment analysis engine
     */
    public void shutdown() {
        if (executorService != null) {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
    
    /**
     * Result class for sentiment analysis
     */
    public static class SentimentAnalysisResult {
        private final double sentimentScore;
        private final Map<String, Integer> detectedPatterns;
        private final List<String> entities;
        
        public SentimentAnalysisResult(double sentimentScore, Map<String, Integer> detectedPatterns, 
                                      List<String> entities) {
            this.sentimentScore = sentimentScore;
            this.detectedPatterns = detectedPatterns;
            this.entities = entities;
        }
        
        public double getSentimentScore() { return sentimentScore; }
        public Map<String, Integer> getDetectedPatterns() { return detectedPatterns; }
        public List<String> getEntities() { return entities; }
    }
    
    /**
     * Result class for test log analysis
     */
    public static class TestLogAnalysisResult {
        private final String testId;
        private final double sentimentScore;
        private final Map<String, Integer> errorCounts;
        private final List<String> entities;
        private final Map<String, Double> patternScores;
        
        public TestLogAnalysisResult(String testId, double sentimentScore, Map<String, Integer> errorCounts, 
                                     List<String> entities, Map<String, Double> patternScores) {
            this.testId = testId;
            this.sentimentScore = sentimentScore;
            this.errorCounts = errorCounts;
            this.entities = entities;
            this.patternScores = patternScores;
        }
        
        public String getTestId() { return testId; }
        public double getSentimentScore() { return sentimentScore; }
        public Map<String, Integer> getErrorCounts() { return errorCounts; }
        public List<String> getEntities() { return entities; }
        public Map<String, Double> getPatternScores() { return patternScores; }
    }
    
    /**
     * Result class for build log analysis
     */
    public static class BuildLogAnalysisResult {
        private final String buildId;
        private final double sentimentScore;
        private final Map<String, Integer> errorCounts;
        private final List<String> entities;
        private final Map<String, Double> patternScores;
        
        public BuildLogAnalysisResult(String buildId, double sentimentScore, Map<String, Integer> errorCounts, 
                                     List<String> entities, Map<String, Double> patternScores) {
            this.buildId = buildId;
            this.sentimentScore = sentimentScore;
            this.errorCounts = errorCounts;
            this.entities = entities;
            this.patternScores = patternScores;
        }
        
        public String getBuildId() { return buildId; }
        public double getSentimentScore() { return sentimentScore; }
        public Map<String, Integer> getErrorCounts() { return errorCounts; }
        public List<String> getEntities() { return entities; }
        public Map<String, Double> getPatternScores() { return patternScores; }
    }
    
    /**
     * Result class for test run pattern analysis
     */
    public static class TestRunPatternAnalysisResult {
        private final Map<String, Integer> patternFrequency;
        private final Map<String, Double> patternFailureCorrelation;
        private final Map<String, List<String>> testClusters;
        private final List<String> commonEntities;
        
        public TestRunPatternAnalysisResult(Map<String, Integer> patternFrequency, 
                                          Map<String, Double> patternFailureCorrelation,
                                          Map<String, List<String>> testClusters,
                                          List<String> commonEntities) {
            this.patternFrequency = patternFrequency;
            this.patternFailureCorrelation = patternFailureCorrelation;
            this.testClusters = testClusters;
            this.commonEntities = commonEntities;
        }
        
        public Map<String, Integer> getPatternFrequency() { return patternFrequency; }
        public Map<String, Double> getPatternFailureCorrelation() { return patternFailureCorrelation; }
        public Map<String, List<String>> getTestClusters() { return testClusters; }
        public List<String> getCommonEntities() { return commonEntities; }
    }
    
    /**
     * Result class for failure analysis
     */
    public static class FailureAnalysisResult {
        private final String testId;
        private final List<String> rootCauses;
        private final List<String> recommendations;
        private final Map<String, Double> confidenceScores;
        private final double overallConfidence;
        
        public FailureAnalysisResult(String testId, List<String> rootCauses, List<String> recommendations,
                                   Map<String, Double> confidenceScores, double overallConfidence) {
            this.testId = testId;
            this.rootCauses = rootCauses;
            this.recommendations = recommendations;
            this.confidenceScores = confidenceScores;
            this.overallConfidence = overallConfidence;
        }
        
        public String getTestId() { return testId; }
        public List<String> getRootCauses() { return rootCauses; }
        public List<String> getRecommendations() { return recommendations; }
        public Map<String, Double> getConfidenceScores() { return confidenceScores; }
        public double getOverallConfidence() { return overallConfidence; }
    }
    
    /**
     * Result class for historical pattern analysis
     */
    public static class HistoricalPatternResult {
        private final String testId;
        private final Map<String, List<Integer>> patternHistory;
        private final Map<String, Double> patternTrends;
        private final double sentimentTrend;
        private final List<String> recurringEntities;
        
        public HistoricalPatternResult(String testId, Map<String, List<Integer>> patternHistory,
                                      Map<String, Double> patternTrends, double sentimentTrend,
                                      List<String> recurringEntities) {
            this.testId = testId;
            this.patternHistory = patternHistory;
            this.patternTrends = patternTrends;
            this.sentimentTrend = sentimentTrend;
            this.recurringEntities = recurringEntities;
        }
        
        public String getTestId() { return testId; }
        public Map<String, List<Integer>> getPatternHistory() { return patternHistory; }
        public Map<String, Double> getPatternTrends() { return patternTrends; }
        public double getSentimentTrend() { return sentimentTrend; }
        public List<String> getRecurringEntities() { return recurringEntities; }
    }
}


package com.cssmart.framework.utils;

import java.text.Normalizer;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Utility class for string processing and text analysis
 * Used for natural language processing operations
 */
public class StringUtils {
    
    // Common English stop words (words with little semantic value)
    private static final Set<String> STOP_WORDS = new HashSet<>(Arrays.asList(
        "a", "an", "the", "and", "or", "but", "is", "are", "was", "were", "be", "been", "being",
        "in", "on", "at", "to", "for", "with", "by", "about", "against", "between", "into", 
        "through", "during", "before", "after", "above", "below", "from", "up", "down", "of", 
        "off", "over", "under", "again", "further", "then", "once", "here", "there", "when", 
        "where", "why", "how", "all", "any", "both", "each", "few", "more", "most", "other", 
        "some", "such", "no", "nor", "not", "only", "own", "same", "so", "than", "too", "very", 
        "s", "t", "can", "will", "just", "don", "should", "now"
    ));
    
    /**
     * Calculates similarity between two strings
     * Returns value between 0 (completely different) and 1 (identical)
     */
    public static double calculateSimilarity(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return 0.0;
        }
        
        if (str1.equals(str2)) {
            return 1.0;
        }
        
        // Convert strings to lowercase for comparison
        String s1 = str1.toLowerCase();
        String s2 = str2.toLowerCase();
        
        // Use Levenshtein distance for short strings
        if (s1.length() < 50 || s2.length() < 50) {
            int distance = calculateLevenshteinDistance(s1, s2);
            int maxLength = Math.max(s1.length(), s2.length());
            
            // Convert distance to similarity score
            return Math.max(0.0, 1.0 - ((double) distance / maxLength));
        } else {
            // Use cosine similarity for longer texts
            return calculateCosineSimilarity(s1, s2);
        }
    }
    
    /**
     * Calculates Levenshtein distance between two strings
     * (minimum number of single-character edits to change one string into the other)
     */
    public static int calculateLevenshteinDistance(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return 0;
        }
        
        int len1 = str1.length();
        int len2 = str2.length();
        
        // Handle empty strings
        if (len1 == 0) return len2;
        if (len2 == 0) return len1;
        
        // Create distance matrix
        int[][] distance = new int[len1 + 1][len2 + 1];
        
        // Initialize first row and column
        for (int i = 0; i <= len1; i++) {
            distance[i][0] = i;
        }
        for (int j = 0; j <= len2; j++) {
            distance[0][j] = j;
        }
        
        // Fill in the rest of the matrix
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                int cost = (str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1;
                distance[i][j] = Math.min(
                    Math.min(distance[i - 1][j] + 1, distance[i][j - 1] + 1),
                    distance[i - 1][j - 1] + cost
                );
            }
        }
        
        return distance[len1][len2];
    }
    
    /**
     * Calculates cosine similarity between two strings
     * based on term frequency vectors
     */
    public static double calculateCosineSimilarity(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return 0.0;
        }
        
        // Tokenize strings into words
        List<String> tokens1 = tokenize(str1);
        List<String> tokens2 = tokenize(str2);
        
        // Create term frequency maps
        Map<String, Integer> freqMap1 = calculateTermFrequency(tokens1);
        Map<String, Integer> freqMap2 = calculateTermFrequency(tokens2);
        
        // Find unique terms from both strings
        Set<String> uniqueTerms = new HashSet<>(freqMap1.keySet());
        uniqueTerms.addAll(freqMap2.keySet());
        
        // Calculate dot product
        double dotProduct = 0.0;
        for (String term : uniqueTerms) {
            int freq1 = freqMap1.getOrDefault(term, 0);
            int freq2 = freqMap2.getOrDefault(term, 0);
            dotProduct += freq1 * freq2;
        }
        
        // Calculate magnitudes
        double magnitude1 = calculateMagnitude(freqMap1);
        double magnitude2 = calculateMagnitude(freqMap2);
        
        // Avoid division by zero
        if (magnitude1 == 0.0 || magnitude2 == 0.0) {
            return 0.0;
        }
        
        // Return cosine similarity
        return dotProduct / (magnitude1 * magnitude2);
    }
    
    /**
     * Tokenizes a string into words
     */
    public static List<String> tokenize(String text) {
        if (text == null || text.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Convert to lowercase and normalize
        String normalized = Normalizer.normalize(text.toLowerCase(), Normalizer.Form.NFD);
        normalized = normalized.replaceAll("[^\\p{ASCII}]", ""); // Remove non-ASCII characters
        
        // Split by non-word characters
        String[] tokens = normalized.split("[\\W_]+");
        
        // Filter out empty tokens and stop words
        List<String> result = new ArrayList<>();
        for (String token : tokens) {
            if (!token.isEmpty() && !STOP_WORDS.contains(token)) {
                result.add(token);
            }
        }
        
        return result;
    }
    
    /**
     * Calculates term frequency map from a list of tokens
     */
    private static Map<String, Integer> calculateTermFrequency(List<String> tokens) {
        Map<String, Integer> frequencyMap = new HashMap<>();
        
        for (String token : tokens) {
            frequencyMap.merge(token, 1, Integer::sum);
        }
        
        return frequencyMap;
    }
    
    /**
     * Calculates the magnitude of a term frequency vector
     */
    private static double calculateMagnitude(Map<String, Integer> termFrequency) {
        double sumOfSquares = 0.0;
        
        for (int frequency : termFrequency.values()) {
            sumOfSquares += frequency * frequency;
        }
        
        return Math.sqrt(sumOfSquares);
    }
    
    /**
     * Extracts keywords from text based on term frequency
     */
    public static List<String> extractKeywords(String text, int maxKeywords) {
        if (text == null || text.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Tokenize text
        List<String> tokens = tokenize(text);
        
        // Calculate term frequency
        Map<String, Integer> termFrequency = calculateTermFrequency(tokens);
        
        // Sort terms by frequency
        List<Map.Entry<String, Integer>> sortedTerms = new ArrayList<>(termFrequency.entrySet());
        sortedTerms.sort(Map.Entry.<String, Integer>comparingByValue().reversed());
        
        // Extract top keywords
        List<String> keywords = new ArrayList<>();
        int count = 0;
        
        for (Map.Entry<String, Integer> entry : sortedTerms) {
            if (count >= maxKeywords) {
                break;
            }
            
            // Only include terms with at least 3 characters and occurring more than once
            if (entry.getKey().length() >= 3 && entry.getValue() > 1) {
                keywords.add(entry.getKey());
                count++;
            }
        }
        
        return keywords;
    }
    
    /**
     * Finds the longest common substring between two strings
     */
    public static String findLongestCommonSubstring(String str1, String str2) {
        if (str1 == null || str2 == null || str1.isEmpty() || str2.isEmpty()) {
            return "";
        }
        
        int len1 = str1.length();
        int len2 = str2.length();
        
        // Create a table to store lengths of longest common suffixes
        int[][] table = new int[len1 + 1][len2 + 1];
        
        // Variables to keep track of maximum length and ending position
        int maxLength = 0;
        int endPosition = 0;
        
        // Fill the table
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    table[i][j] = table[i - 1][j - 1] + 1;
                    
                    if (table[i][j] > maxLength) {
                        maxLength = table[i][j];
                        endPosition = i;
                    }
                }
            }
        }
        
        // Extract the longest common substring
        if (maxLength > 0) {
            return str1.substring(endPosition - maxLength, endPosition);
        }
        
        return "";
    }
    
    /**
     * Checks if a string contains any of the given keywords
     */
    public static boolean containsAny(String text, List<String> keywords) {
        if (text == null || keywords == null || keywords.isEmpty()) {
            return false;
        }
        
        String lowerText = text.toLowerCase();
        
        for (String keyword : keywords) {
            if (keyword != null && !keyword.isEmpty() && lowerText.contains(keyword.toLowerCase())) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Checks if a string contains all of the given keywords
     */
    public static boolean containsAll(String text, List<String> keywords) {
        if (text == null || keywords == null || keywords.isEmpty()) {
            return false;
        }
        
        String lowerText = text.toLowerCase();
        
        for (String keyword : keywords) {
            if (keyword != null && !keyword.isEmpty() && !lowerText.contains(keyword.toLowerCase())) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Checks if two strings are similar above a threshold
     */
    public static boolean isSimilar(String str1, String str2, double threshold) {
        return calculateSimilarity(str1, str2) >= threshold;
    }
    
    /**
     * Finds the most similar string in a list to a target string
     */
    public static String findMostSimilar(String target, List<String> candidates) {
        if (target == null || candidates == null || candidates.isEmpty()) {
            return null;
        }
        
        String mostSimilar = null;
        double highestSimilarity = -1;
        
        for (String candidate : candidates) {
            double similarity = calculateSimilarity(target, candidate);
            
            if (similarity > highestSimilarity) {
                highestSimilarity = similarity;
                mostSimilar = candidate;
            }
        }
        
        return mostSimilar;
    }
    
    /**
     * Splits text into sentences
     */
    public static List<String> splitSentences(String text) {
        if (text == null || text.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Pattern to match sentence boundaries
        // Matches periods, question marks, and exclamation marks followed by space or end of string
        // But considers common abbreviations and numeric patterns to avoid false splits
        Pattern pattern = Pattern.compile("(?<![A-Z][a-z]\\.)(?<![0-9]\\.)(?<=\\.|\\?|\\!)\\s+(?=[A-Z])");
        
        String[] sentences = pattern.split(text);
        
        // Clean up sentences
        List<String> result = new ArrayList<>();
        for (String sentence : sentences) {
            String trimmed = sentence.trim();
            if (!trimmed.isEmpty()) {
                result.add(trimmed);
            }
        }
        
        return result;
    }
    
    /**
     * Removes HTML tags from text
     */
    public static String removeHtmlTags(String html) {
        if (html == null || html.isEmpty()) {
            return "";
        }
        
        // Remove all HTML tags
        String noTags = html.replaceAll("<[^>]*>", "");
        
        // Replace special HTML entities
        noTags = noTags.replaceAll("&amp;", "&")
                      .replaceAll("&lt;", "<")
                      .replaceAll("&gt;", ">")
                      .replaceAll("&quot;", "\"")
                      .replaceAll("&apos;", "'")
                      .replaceAll("&nbsp;", " ")
                      .replaceAll("&#[0-9]+;", "");
        
        // Normalize whitespace
        noTags = noTags.replaceAll("\\s+", " ").trim();
        
        return noTags;
    }
    
    /**
     * Truncates a string to a maximum length, adding ellipsis if truncated
     */
    public static String truncate(String text, int maxLength) {
        if (text == null || text.length() <= maxLength) {
            return text;
        }
        
        return text.substring(0, maxLength - 3) + "...";
    }
}



package com.cssmart.framework.utils;

import java.util.*;

/**
 * Utility class for statistical calculations
 * Used by AI components for data analysis
 */
public class StatisticsUtil {

    /**
     * Calculates the mean (average) of a list of numbers
     */
    public static double calculateMean(List<? extends Number> values) {
        if (values == null || values.isEmpty()) {
            return 0.0;
        }
        
        double sum = 0.0;
        for (Number value : values) {
            sum += value.doubleValue();
        }
        
        return sum / values.size();
    }
    
    /**
     * Calculates the median of a list of numbers
     */
    public static double calculateMedian(List<? extends Number> values) {
        if (values == null || values.isEmpty()) {
            return 0.0;
        }
        
        // Create a copy of the list as doubles
        List<Double> doubleValues = new ArrayList<>(values.size());
        for (Number value : values) {
            doubleValues.add(value.doubleValue());
        }
        
        // Sort the values
        Collections.sort(doubleValues);
        
        int size = doubleValues.size();
        int middle = size / 2;
        
        if (size % 2 == 1) {
            // Odd number of values, return the middle one
            return doubleValues.get(middle);
        } else {
            // Even number of values, return the average of the two middle ones
            return (doubleValues.get(middle - 1) + doubleValues.get(middle)) / 2.0;
        }
    }
    
    /**
     * Calculates the mode (most frequent value) of a list of numbers
     */
    public static double calculateMode(List<? extends Number> values) {
        if (values == null || values.isEmpty()) {
            return 0.0;
        }
        
        // Count occurrences of each value
        Map<Double, Integer> countMap = new HashMap<>();
        
        for (Number value : values) {
            double doubleValue = value.doubleValue();
            countMap.merge(doubleValue, 1, Integer::sum);
        }
        
        // Find the value with the highest count
        double mode = 0.0;
        int maxCount = 0;
        
        for (Map.Entry<Double, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                mode = entry.getKey();
            }
        }
        
        return mode;
    }
    
    /**
     * Calculates the standard deviation of a list of numbers
     */
    public static double calculateStandardDeviation(List<? extends Number> values) {
        if (values == null || values.size() <= 1) {
            return 0.0;
        }
        
        double mean = calculateMean(values);
        double sumOfSquaredDifferences = 0.0;
        
        for (Number value : values) {
            double difference = value.doubleValue() - mean;
            sumOfSquaredDifferences += difference * difference;
        }
        
        return Math.sqrt(sumOfSquaredDifferences / values.size());
    }
    
    /**
     * Calculates the correlation coefficient between two lists of numbers
     */
    public static double calculateCorrelation(List<? extends Number> xValues, List<? extends Number> yValues) {
        if (xValues == null || yValues == null || xValues.isEmpty() || yValues.isEmpty() || 
            xValues.size() != yValues.size()) {
            return 0.0;
        }
        
        int n = xValues.size();
        
        double sumX = 0.0;
        double sumY = 0.0;
        double sumXY = 0.0;
        double sumXX = 0.0;
        double sumYY = 0.0;
        
        for (int i = 0; i < n; i++) {
            double x = xValues.get(i).doubleValue();
            double y = yValues.get(i).doubleValue();
            
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
            sumYY += y * y;
        }
        
        // Calculate correlation coefficient using Pearson's formula
        double numerator = (n * sumXY) - (sumX * sumY);
        double denominator = Math.sqrt(((n * sumXX) - (sumX * sumX)) * ((n * sumYY) - (sumY * sumY)));
        
        if (Math.abs(denominator) < 1e-10) {
            return 0.0; // Avoid division by zero
        }
        
        return numerator / denominator;
    }
    
    /**
     * Normalizes a list of numbers to a 0-1 range
     */
    public static List<Double> normalizeValues(List<? extends Number> values) {
        if (values == null || values.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Find min and max values
        double min = Double.MAX_VALUE;
        double max = Double.MIN_VALUE;
        
        for (Number value : values) {
            double doubleValue = value.doubleValue();
            min = Math.min(min, doubleValue);
            max = Math.max(max, doubleValue);
        }
        
        double range = max - min;
        if (range == 0.0) {
            // All values are the same, return a list of 0.5
            List<Double> result = new ArrayList<>(values.size());
            for (int i = 0; i < values.size(); i++) {
                result.add(0.5);
            }
            return result;
        }
        
        // Normalize values to 0-1 range
        List<Double> normalizedValues = new ArrayList<>(values.size());
        
        for (Number value : values) {
            double normalized = (value.doubleValue() - min) / range;
            normalizedValues.add(normalized);
        }
        
        return normalizedValues;
    }
    
    /**
     * Z-score normalization (standardization) of a list of numbers
     */
    public static List<Double> standardizeValues(List<? extends Number> values) {
        if (values == null || values.isEmpty()) {
            return Collections.emptyList();
        }
        
        double mean = calculateMean(values);
        double stdDev = calculateStandardDeviation(values);
        
        if (Math.abs(stdDev) < 1e-10) {
            // Standard deviation is effectively zero, return a list of zeros
            List<Double> result = new ArrayList<>(values.size());
            for (int i = 0; i < values.size(); i++) {
                result.add(0.0);
            }
            return result;
        }
        
        // Calculate z-scores
        List<Double> standardizedValues = new ArrayList<>(values.size());
        
        for (Number value : values) {
            double standardized = (value.doubleValue() - mean) / stdDev;
            standardizedValues.add(standardized);
        }
        
        return standardizedValues;
    }
    
    /**
     * Calculates the variance of a list of numbers
     */
    public static double calculateVariance(List<? extends Number> values) {
        if (values == null || values.size() <= 1) {
            return 0.0;
        }
        
        double mean = calculateMean(values);
        double sumOfSquaredDifferences = 0.0;
        
        for (Number value : values) {
            double difference = value.doubleValue() - mean;
            sumOfSquaredDifferences += difference * difference;
        }
        
        return sumOfSquaredDifferences / values.size();
    }
    
    /**
     * Calculates the covariance between two lists of numbers
     */
    public static double calculateCovariance(List<? extends Number> xValues, List<? extends Number> yValues) {
        if (xValues == null || yValues == null || xValues.isEmpty() || yValues.isEmpty() || 
            xValues.size() != yValues.size()) {
            return 0.0;
        }
        
        int n = xValues.size();
        double meanX = calculateMean(xValues);
        double meanY = calculateMean(yValues);
        
        double sumOfProducts = 0.0;
        
        for (int i = 0; i < n; i++) {
            double xDiff = xValues.get(i).doubleValue() - meanX;
            double yDiff = yValues.get(i).doubleValue() - meanY;
            sumOfProducts += xDiff * yDiff;
        }
        
        return sumOfProducts / n;
    }
    
    /**
     * Performs a linear regression on two lists of numbers (x and y values)
     * and returns the slope and intercept as a double array [slope, intercept]
     */
    public static double[] calculateLinearRegression(List<? extends Number> xValues, List<? extends Number> yValues) {
        if (xValues == null || yValues == null || xValues.isEmpty() || yValues.isEmpty() || 
            xValues.size() != yValues.size()) {
            return new double[] {0.0, 0.0};
        }
        
        int n = xValues.size();
        
        double sumX = 0.0;
        double sumY = 0.0;
        double sumXY = 0.0;
        double sumXX = 0.0;
        
        for (int i = 0; i < n; i++) {
            double x = xValues.get(i).doubleValue();
            double y = yValues.get(i).doubleValue();
            
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
        }
        
        // Calculate slope
        double numerator = (n * sumXY) - (sumX * sumY);
        double denominator = (n * sumXX) - (sumX * sumX);
        
        if (Math.abs(denominator) < 1e-10) {
            return new double[] {0.0, 0.0}; // Avoid division by zero
        }
        
        double slope = numerator / denominator;
        
        // Calculate intercept
        double intercept = (sumY - (slope * sumX)) / n;
        
        return new double[] {slope, intercept};
    }
    
    /**
     * Calculates the coefficient of determination (R-squared) for a linear regression
     */
    public static double calculateRSquared(List<? extends Number> xValues, List<? extends Number> yValues) {
        if (xValues == null || yValues == null || xValues.isEmpty() || yValues.isEmpty() || 
            xValues.size() != yValues.size()) {
            return 0.0;
        }
        
        double[] regression = calculateLinearRegression(xValues, yValues);
        double slope = regression[0];
        double intercept = regression[1];
        
        double meanY = calculateMean(yValues);
        
        double totalSumOfSquares = 0.0;
        double residualSumOfSquares = 0.0;
        
        int n = xValues.size();
        
        for (int i = 0; i < n; i++) {
            double x = xValues.get(i).doubleValue();
            double y = yValues.get(i).doubleValue();
            
            double predicted = (slope * x) + intercept;
            
            double residual = y - predicted;
            double deviation = y - meanY;
            
            residualSumOfSquares += residual * residual;
            totalSumOfSquares += deviation * deviation;
        }
        
        if (Math.abs(totalSumOfSquares) < 1e-10) {
            return 0.0; // Avoid division by zero
        }
        
        return 1.0 - (residualSumOfSquares / totalSumOfSquares);
    }
    
    /**
     * Calculates percentiles for a list of numbers
     * @param values The list of values
     * @param percentiles Array of percentiles to calculate (0-100)
     * @return Array of values at the specified percentiles
     */
    public static double[] calculatePercentiles(List<? extends Number> values, double[] percentiles) {
        if (values == null || values.isEmpty() || percentiles == null || percentiles.length == 0) {
            return new double[0];
        }
        
        // Create a copy of the list as doubles and sort it
        List<Double> sortedValues = new ArrayList<>(values.size());
        for (Number value : values) {
            sortedValues.add(value.doubleValue());
        }
        Collections.sort(sortedValues);
        
        int size = sortedValues.size();
        double[] result = new double[percentiles.length];
        
        for (int i = 0; i < percentiles.length; i++) {
            double percentile = percentiles[i];
            
            if (percentile < 0 || percentile > 100) {
                throw new IllegalArgumentException("Percentile must be between 0 and 100");
            }
            
            if (size == 1) {
                result[i] = sortedValues.get(0);
                continue;
            }
            
            // Calculate the index (could be fractional)
            double index = (percentile / 100.0) * (size - 1);
            
            // Integer part of index
            int lowerIndex = (int) Math.floor(index);
            int upperIndex = (int) Math.ceil(index);
            
            if (lowerIndex == upperIndex) {
                result[i] = sortedValues.get(lowerIndex);
            } else {
                // Interpolate between the two values
                double lowerValue = sortedValues.get(lowerIndex);
                double upperValue = sortedValues.get(upperIndex);
                double fraction = index - lowerIndex;
                
                result[i] = lowerValue + (fraction * (upperValue - lowerValue));
            }
        }
        
        return result;
    }
    
    /**
     * Calculates the moving average of a list of numbers
     * @param values The list of values
     * @param windowSize The size of the moving window
     * @return List of moving averages
     */
    public static List<Double> calculateMovingAverage(List<? extends Number> values, int windowSize) {
        if (values == null || values.isEmpty() || windowSize <= 0) {
            return Collections.emptyList();
        }
        
        int size = values.size();
        if (windowSize > size) {
            windowSize = size;
        }
        
        List<Double> result = new ArrayList<>(size - windowSize + 1);
        
        // Calculate first window sum
        double sum = 0.0;
        for (int i = 0; i < windowSize; i++) {
            sum += values.get(i).doubleValue();
        }
        
        // First moving average
        result.add(sum / windowSize);
        
        // Calculate remaining moving averages
        for (int i = windowSize; i < size; i++) {
            sum -= values.get(i - windowSize).doubleValue();
            sum += values.get(i).doubleValue();
            result.add(sum / windowSize);
        }
        
        return result;
    }
    
    /**
     * Calculates the exponential moving average of a list of numbers
     * @param values The list of values
     * @param alpha The smoothing factor (0 < alpha < 1)
     * @return List of exponential moving averages
     */
    public static List<Double> calculateExponentialMovingAverage(List<? extends Number> values, double alpha) {
        if (values == null || values.isEmpty() || alpha <= 0 || alpha >= 1) {
            return Collections.emptyList();
        }
        
        int size = values.size();
        List<Double> result = new ArrayList<>(size);
        
        // First value is just the first value in the list
        double ema = values.get(0).doubleValue();
        result.add(ema);
        
        // Calculate remaining EMAs
        for (int i = 1; i < size; i++) {
            double value = values.get(i).doubleValue();
            ema = (alpha * value) + ((1 - alpha) * ema);
            result.add(ema);
        }
        
        return result;
    }
    
    /**
     * Detects outliers in a list of numbers using the interquartile range (IQR) method
     * Values beyond Q1 - k*IQR and Q3 + k*IQR are considered outliers
     * @param values The list of values
     * @param k The multiplier for IQR (typically 1.5)
     * @return List of indices of the outliers
     */
    public static List<Integer> detectOutliers(List<? extends Number> values, double k) {
        if (values == null || values.isEmpty() || k <= 0) {
            return Collections.emptyList();
        }
        
        int size = values.size();
        if (size <= 3) {
            return Collections.emptyList(); // Not enough data to detect outliers
        }
        
        // Calculate quartiles
        double[] quartiles = calculatePercentiles(values, new double[] {25, 75});
        double q1 = quartiles[0];
        double q3 = quartiles[1];
        double iqr = q3 - q1;
        
        // Calculate bounds
        double lowerBound = q1 - (k * iqr);
        double upperBound = q3 + (k * iqr);
        
        // Find outliers
        List<Integer> outlierIndices = new ArrayList<>();
        
        for (int i = 0; i < size; i++) {
            double value = values.get(i).doubleValue();
            if (value < lowerBound || value > upperBound) {
                outlierIndices.add(i);
            }
        }
        
        return outlierIndices;
    }
    
    /**
     * Performs a t-test to determine if two samples have significantly different means
     * @param sample1 First sample values
     * @param sample2 Second sample values
     * @return t-value (higher absolute value indicates more significant difference)
     */
    public static double calculateTTest(List<? extends Number> sample1, List<? extends Number> sample2) {
        if (sample1 == null || sample2 == null || sample1.isEmpty() || sample2.isEmpty()) {
            return 0.0;
        }
        
        double mean1 = calculateMean(sample1);
        double mean2 = calculateMean(sample2);
        
        double var1 = calculateVariance(sample1);
        double var2 = calculateVariance(sample2);
        
        int n1 = sample1.size();
        int n2 = sample2.size();
        
        // Calculate pooled standard error
        double se = Math.sqrt((var1 / n1) + (var2 / n2));
        
        if (Math.abs(se) < 1e-10) {
            return 0.0; // Avoid division by zero
        }
        
        // Calculate t-value
        return (mean1 - mean2) / se;
    }
    
    /**
     * Performs kernel density estimation on a list of numbers
     * @param values The list of values
     * @param points The points at which to evaluate the density
     * @param bandwidth The bandwidth parameter (controls smoothness)
     * @return Array of density values at the specified points
     */
    public static double[] calculateKernelDensity(List<? extends Number> values, double[] points, double bandwidth) {
        if (values == null || values.isEmpty() || points == null || points.length == 0 || bandwidth <= 0) {
            return new double[0];
        }
        
        int n = values.size();
        int m = points.length;
        double[] result = new double[m];
        
        // Calculate density at each point
        for (int i = 0; i < m; i++) {
            double point = points[i];
            double sum = 0.0;
            
            for (Number value : values) {
                double x = value.doubleValue();
                double z = (point - x) / bandwidth;
                sum += Math.exp(-0.5 * z * z);
            }
            
            result[i] = sum / (n * bandwidth * Math.sqrt(2 * Math.PI));
        }
        
        return result;
    }
}




