################################################################################
# CSSmartFramework Configuration
# This file contains all the configuration properties for the framework
################################################################################

# General Settings
cssmart.env=default
cssmart.report.dir=target/cssmart-reports

# Browser Configuration
browser.type=chrome
browser.maximize=true
browser.width=1366
browser.height=768
browser.timeout=30
browser.implicit.wait=10
browser.headless=false
driver.autoCreate=true

# Screenshot Configuration
screenshot.onSuccess=false
screenshot.onFailure=true
screenshot.onEveryStep=false

# Logging Configuration
log.level=INFO
log.pattern=%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n
log.file=target/cssmart.log
log.console=true

# Test Execution Configuration
test.retry.count=0
test.parallel.enabled=false
test.parallel.threads=2
test.timeout=300

# AI Feature Configuration
ai.self.healing=true
ai.smart.locators=true
ai.test.recommendations=false
ai.context.analysis=true

# Database Configuration
db.default.url=jdbc:h2:mem:testdb
db.default.username=sa
db.default.password=
db.default.pool.size=10
db.default.pool.idle=5
db.default.pool.idleTimeout=30000

# API Testing Configuration
api.request.timeout=30
api.response.log=true
api.schema.validation=true

# BDD Configuration
bdd.features.path=src/test/resources/features
bdd.step.definitions.package=com.cssmart.stepdefs
bdd.hooks.package=com.cssmart.hooks
bdd.report.enabled=true

# ADO Integration Configuration
ado.enabled=false
ado.url=https://dev.azure.com/YOUR_ORGANIZATION
ado.project=YOUR_PROJECT
ado.token=YOUR_PERSONAL_ACCESS_TOKEN
ado.testplan.id=YOUR_TEST_PLAN_ID
ado.sync.mode=MANUAL
ado.update.results=true
ado.upload.screenshots=true
ado.upload.report=true

################################################################################
# Custom Properties
# Add your custom properties below
################################################################################


/**
 * LoginPage.java
 * Example page object for login page
 */
package com.cssmart.examples.web.pages;

import com.cssmart.base.CSSmartBasePage;
import com.cssmart.driver.CSSmartDriver;
import com.cssmart.driver.CSSmartFindBy;
import com.cssmart.driver.CSSmartWebElement;

public class LoginPage extends CSSmartBasePage {
    
    @CSSmartFindBy(id = "username")
    private CSSmartWebElement usernameField;
    
    @CSSmartFindBy(id = "password")
    private CSSmartWebElement passwordField;
    
    @CSSmartFindBy(xpath = "//button[@type='submit']")
    private CSSmartWebElement loginButton;
    
    @CSSmartFindBy(css = ".error-message")
    private CSSmartWebElement errorMessage;
    
    @CSSmartFindBy(description = "Login help link", linkText = "Need help?")
    private CSSmartWebElement helpLink;
    
    /**
     * Constructor
     * @param driver the driver
     */
    public LoginPage(CSSmartDriver driver) {
        super(driver, "Login Page");
    }
    
    /**
     * Enter username
     * @param username the username
     * @return this page for chaining
     */
    public LoginPage enterUsername(String username) {
        usernameField.clear();
        usernameField.sendKeys(username);
        return this;
    }
    
    /**
     * Enter password
     * @param password the password
     * @return this page for chaining
     */
    public LoginPage enterPassword(String password) {
        passwordField.clear();
        passwordField.sendKeys(password);
        return this;
    }
    
    /**
     * Click login button
     * @return the home page
     */
    public HomePage clickLogin() {
        loginButton.click();
        return new HomePage(driver);
    }
    
    /**
     * Login with credentials
     * @param username the username
     * @param password the password
     * @return the home page
     */
    public HomePage login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        return clickLogin();
    }
    
    /**
     * Get error message
     * @return the error message
     */
    public String getErrorMessage() {
        return errorMessage.isDisplayed() ? errorMessage.getText() : "";
    }
    
    /**
     * Click help link
     */
    public void clickHelpLink() {
        helpLink.click();
    }
    
    /**
     * Check if page is loaded
     */
    @Override
    public boolean isPageLoaded() {
        return usernameField.isDisplayed() && passwordField.isDisplayed() && loginButton.isDisplayed();
    }
}

/**
 * HomePage.java
 * Example page object for home page
 */
package com.cssmart.examples.web.pages;

import com.cssmart.base.CSSmartBasePage;
import com.cssmart.driver.CSSmartDriver;
import com.cssmart.driver.CSSmartFindBy;
import com.cssmart.driver.CSSmartWebElement;

public class HomePage extends CSSmartBasePage {
    
    @CSSmartFindBy(id = "welcome-message")
    private CSSmartWebElement welcomeMessage;
    
    @CSSmartFindBy(linkText = "Logout")
    private CSSmartWebElement logoutLink;
    
    @CSSmartFindBy(css = ".dashboard-menu")
    private CSSmartWebElement dashboardMenu;
    
    /**
     * Constructor
     * @param driver the driver
     */
    public HomePage(CSSmartDriver driver) {
        super(driver, "Home Page");
    }
    
    /**
     * Get welcome message
     * @return the welcome message
     */
    public String getWelcomeMessage() {
        return welcomeMessage.getText();
    }
    
    /**
     * Click logout link
     * @return the login page
     */
    public LoginPage clickLogout() {
        logoutLink.click();
        return new LoginPage(driver);
    }
    
    /**
     * Check if user is logged in
     * @return true if logged in
     */
    public boolean isLoggedIn() {
        return welcomeMessage.isDisplayed() && logoutLink.isDisplayed();
    }
    
    /**
     * Check if page is loaded
     */
    @Override
    public boolean isPageLoaded() {
        return welcomeMessage.isDisplayed() && dashboardMenu.isDisplayed();
    }
}

/**
 * LoginTest.java
 * Example test for login functionality
 */
package com.cssmart.examples.web.tests;

import com.cssmart.annotations.CSSmartADOTest;
import com.cssmart.annotations.CSSmartDataProvider;
import com.cssmart.annotations.CSSmartTestStep;
import com.cssmart.base.CSSmartBaseTest;
import com.cssmart.examples.web.pages.HomePage;
import com.cssmart.examples.web.pages.LoginPage;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.util.Map;

public class LoginTest extends CSSmartBaseTest {
    
    /**
     * Test successful login
     */
    @Test(description = "Test login with valid credentials")
    @CSSmartADOTest(testCaseId = "12345", description = "Verify that user can login with valid credentials")
    public void testSuccessfulLogin() {
        // Navigate to login page
        driver.get("https://example.com/login");
        
        // Create page objects
        LoginPage loginPage = new LoginPage(driver);
        
        // Verify page is loaded
        Assert.assertTrue(loginPage.isPageLoaded(), "Login page is not loaded");
        
        // Perform login
        HomePage homePage = loginPage.login("testuser", "password");
        
        // Verify login successful
        Assert.assertTrue(homePage.isPageLoaded(), "Home page is not loaded");
        Assert.assertTrue(homePage.isLoggedIn(), "User is not logged in");
        Assert.assertTrue(homePage.getWelcomeMessage().contains("Welcome"), "Welcome message not displayed");
    }
    
    /**
     * Test failed login
     */
    @Test(description = "Test login with invalid credentials")
    @CSSmartADOTest(testCaseId = "12346", description = "Verify that login fails with invalid credentials")
    public void testFailedLogin() {
        // Steps to navigate to login page
        navigateToLoginPage();
        
        // Create page objects
        LoginPage loginPage = new LoginPage(driver);
        
        // Enter invalid credentials and click login
        loginPage.enterUsername("wronguser")
                 .enterPassword("wrongpassword")
                 .clickLogin();
        
        // Verify error message
        Assert.assertTrue(loginPage.getErrorMessage().contains("Invalid"), "Error message not displayed");
    }
    
    /**
     * Test login with data provider
     * @param testData the test data
     */
    @Test(dataProvider = "CSSmartDataProvider", description = "Test login with data provider")
    @CSSmartDataProvider(type = CSSmartDataProvider.DataSourceType.JSON, path = "test-data/login-data.json")
    public void testLoginWithDataProvider(Map<String, Object> testData) {
        // Navigate to login page
        driver.get("https://example.com/login");
        
        // Create page objects
        LoginPage loginPage = new LoginPage(driver);
        
        // Get test data
        String username = (String) testData.get("username");
        String password = (String) testData.get("password");
        boolean shouldSucceed = (boolean) testData.get("shouldSucceed");
        
        // Perform login
        if (shouldSucceed) {
            HomePage homePage = loginPage.login(username, password);
            Assert.assertTrue(homePage.isLoggedIn(), "User is not logged in");
        } else {
            loginPage.enterUsername(username)
                     .enterPassword(password)
                     .clickLogin();
            Assert.assertTrue(loginPage.getErrorMessage().contains("Invalid"), "Error message not displayed");
        }
    }
    
    /**
     * Navigate to login page
     * This is a test step that can be reused
     */
    @CSSmartTestStep(description = "Navigate to login page", takeScreenshot = true)
    private void navigateToLoginPage() {
        driver.get("https://example.com/login");
    }
}

/**
 * APITestExample.java
 * Example test for API testing
 */
package com.cssmart.examples.api;

import com.cssmart.api.CSSmartAPIAssertion;
import com.cssmart.api.CSSmartAPIChaining;
import com.cssmart.api.CSSmartAPIClient;
import com.cssmart.api.CSSmartAPIRequest;
import com.cssmart.api.CSSmartAPIResponse;
import com.cssmart.api.CSSmartAPIValidator;
import com.cssmart.base.CSSmartBaseTest;
import org.testng.annotations.Test;

public class APITestExample extends CSSmartBaseTest {
    
    private static final String BASE_URL = "https://api.example.com";
    
    /**
     * Test GET request
     */
    @Test(description = "Test GET request to users API")
    public void testGetUsers() {
        // Create API client
        CSSmartAPIClient client = CSSmartAPIClient.getInstance(BASE_URL);
        
        // Create and execute request
        CSSmartAPIResponse response = client.createRequest()
            .get()
            .endpoint("/users")
            .execute();
        
        // Assertions
        CSSmartAPIAssertion.assertStatusCode(response, 200);
        CSSmartAPIAssertion.assertContentType(response, "application/json");
        CSSmartAPIAssertion.assertJsonPathExists(response, "data");
        CSSmartAPIAssertion.assertJsonSchema(response, "schemas/users-schema.json");
    }
    
    /**
     * Test POST request
     */
    @Test(description = "Test POST request to create user")
    public void testCreateUser() {
        // Create API client
        CSSmartAPIClient client = CSSmartAPIClient.getInstance(BASE_URL);
        
        // Create request body
        UserRequest user = new UserRequest("John Doe", "Software Engineer");
        
        // Create and execute request
        CSSmartAPIResponse response = client.createRequest()
            .post()
            .endpoint("/users")
            .body(user)
            .execute();
        
        // Assertions
        CSSmartAPIAssertion.assertStatusCode(response, 201);
        CSSmartAPIAssertion.assertJsonPathExists(response, "id");
        CSSmartAPIAssertion.assertJsonPathValue(response, "name", "John Doe");
    }
    
    /**
     * Test API chaining
     */
    @Test(description = "Test API request chaining")
    public void testApiChaining() {
        // Create API chaining
        CSSmartAPIChaining chaining = new CSSmartAPIChaining(BASE_URL);
        
        // Create a user and extract ID
        chaining.post("/users", new UserRequest("Jane Smith", "Product Manager"))
                .extractVariable("id", "userId");
        
        // Get the created user
        chaining.get("/users/${userId}")
                .extractVariable("name", "userName");
        
        // Update the user
        chaining.put("/users/${userId}", new UserRequest("${userName}", "Senior Product Manager"))
                .extractVariable("job", "userJob");
        
        // Delete the user
        chaining.delete("/users/${userId}");
        
        // Final assertions
        CSSmartAPIResponse lastResponse = chaining.getLastResponse();
        CSSmartAPIAssertion.assertStatusCode(lastResponse, 204);
    }
    
    /**
     * Inner class for user request
     */
    private static class UserRequest {
        private String name;
        private String job;
        
        public UserRequest(String name, String job) {
            this.name = name;
            this.job = job;
        }
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getJob() {
            return job;
        }
        
        public void setJob(String job) {
            this.job = job;
        }
    }
}

/**
 * StepDefinitions.java
 * Example BDD step definitions
 */
package com.cssmart.examples.bdd;

import com.cssmart.bdd.CSSmartBDDScanner.Given;
import com.cssmart.bdd.CSSmartBDDScanner.When;
import com.cssmart.bdd.CSSmartBDDScanner.Then;
import com.cssmart.bdd.CSSmartBDDScanner.And;
import com.cssmart.bdd.CSSmartBDDContext;
import com.cssmart.driver.CSSmartDriver;
import com.cssmart.examples.web.pages.HomePage;
import com.cssmart.examples.web.pages.LoginPage;
import org.testng.Assert;

public class StepDefinitions {
    
    /**
     * Navigate to login page
     * @param context the BDD context
     */
    @Given("I am on the login page")
    public void givenIAmOnLoginPage(CSSmartBDDContext context) {
        CSSmartDriver driver = context.getDriver();
        driver.get("https://example.com/login");
        
        LoginPage loginPage = new LoginPage(driver);
        Assert.assertTrue(loginPage.isPageLoaded(), "Login page is not loaded");
        
        // Store page in context
        context.set("loginPage", loginPage);
    }
    
    /**
     * Enter credentials
     * @param username the username
     * @param password the password
     * @param context the BDD context
     */
    @When("I enter username {string} and password {string}")
    public void whenIEnterCredentials(String username, String password, CSSmartBDDContext context) {
        LoginPage loginPage = (LoginPage) context.get("loginPage");
        loginPage.enterUsername(username);
        loginPage.enterPassword(password);
    }
    
    /**
     * Click login button
     * @param context the BDD context
     */
    @And("I click the login button")
    public void andIClickLoginButton(CSSmartBDDContext context) {
        LoginPage loginPage = (LoginPage) context.get("loginPage");
        HomePage homePage = loginPage.clickLogin();
        context.set("homePage", homePage);
    }
    
    /**
     * Verify successful login
     * @param context the BDD context
     */
    @Then("I should be logged in successfully")
    public void thenIShouldBeLoggedIn(CSSmartBDDContext context) {
        HomePage homePage = (HomePage) context.get("homePage");
        Assert.assertTrue(homePage.isPageLoaded(), "Home page is not loaded");
        Assert.assertTrue(homePage.isLoggedIn(), "User is not logged in");
    }
    
    /**
     * Verify failed login
     * @param context the BDD context
     */
    @Then("I should see an error message")
    public void thenIShouldSeeErrorMessage(CSSmartBDDContext context) {
        LoginPage loginPage = (LoginPage) context.get("loginPage");
        Assert.assertTrue(loginPage.getErrorMessage().contains("Invalid"), "Error message not displayed");
    }
}

/**
 * login.feature
 * Example feature file
 */
/* 
Feature: Login Functionality
  As a user
  I want to be able to login to the application
  So that I can access my account

  Scenario: Successful login
    Given I am on the login page
    When I enter username "testuser" and password "password"
    And I click the login button
    Then I should be logged in successfully

  Scenario: Failed login
    Given I am on the login page
    When I enter username "wronguser" and password "wrongpassword"
    And I click the login button
    Then I should see an error message

  @TestDataProvider(type="JSON", path="test-data/login-data.json")
  Scenario Outline: Login with different credentials
    Given I am on the login page
    When I enter username "<username>" and password "<password>"
    And I click the login button
    Then I should <result>

    Examples:
      | username  | password  | result                     |
      | testuser  | password  | be logged in successfully  |
      | wronguser | wrongpass | see an error message       |
*/

/**
 * testng.xml
 * Example TestNG XML file
 */
/*
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="CSSmartFramework Test Suite">
    <test name="Web Tests">
        <classes>
            <class name="com.cssmart.examples.web.tests.LoginTest" />
        </classes>
    </test>
    <test name="API Tests">
        <classes>
            <class name="com.cssmart.examples.api.APITestExample" />
        </classes>
    </test>
    <test name="BDD Tests">
        <parameter name="featureFiles" value="src/test/resources/features/login.feature" />
        <parameter name="stepDefinitionPackages" value="com.cssmart.examples.bdd" />
        <classes>
            <class name="com.cssmart.bdd.CSSmartCodelessRunner" />
        </classes>
    </test>
</suite>
*/



package com.cssmart.framework.element;

import com.cssmart.framework.annotation.CSSmartFindBy;
import com.cssmart.framework.annotation.AlternateLocator;
import com.cssmart.framework.enums.LocatorStrategy;
import com.cssmart.framework.enums.FailureHandling;
import com.cssmart.framework.exception.ElementNotFoundException;
import com.cssmart.framework.fingerprint.ElementFingerprint;
import com.cssmart.framework.healing.HealingContext;
import com.cssmart.framework.healing.HealingResult;
import com.cssmart.framework.healing.HealingStrategy;
import com.cssmart.framework.healing.impl.SemanticHealingStrategy;
import com.cssmart.framework.healing.impl.DomHealingStrategy;
import com.cssmart.framework.healing.impl.VisualHealingStrategy;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Implementation of a self-healing web element that can recover from locator changes
 * by using multiple strategies to find elements when the primary locator fails.
 */
public class CSSmartWebElement implements WebElement {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartWebElement.class);
    private static final Map<String, ElementFingerprint> elementFingerprints = new ConcurrentHashMap<>();
    private static final Map<String, List<HealingResult>> healingHistory = new ConcurrentHashMap<>();
    
    private final WebDriver driver;
    private final String elementName;
    private final CSSmartFindBy smartFindBy;
    private final By primaryLocator;
    private final List<By> alternateLocators;
    private final List<HealingStrategy> healingStrategies;
    private ElementFingerprint fingerprint;
    private WebElement wrappedElement;
    private String elementId;
    
    /**
     * Creates a CSSmartWebElement with self-healing capabilities
     */
    public CSSmartWebElement(WebDriver driver, String elementName, CSSmartFindBy smartFindBy, By primaryLocator) {
        this.driver = driver;
        this.elementName = elementName;
        this.smartFindBy = smartFindBy;
        this.primaryLocator = primaryLocator;
        this.alternateLocators = createAlternateLocators(smartFindBy);
        this.healingStrategies = initializeHealingStrategies(smartFindBy);
        this.elementId = UUID.randomUUID().toString();
    }
    
    /**
     * Initializes healing strategies based on the priorities specified in the annotation
     */
    private List<HealingStrategy> initializeHealingStrategies(CSSmartFindBy smartFindBy) {
        List<HealingStrategy> strategies = new ArrayList<>();
        
        // Default priority if not specified
        LocatorStrategy[] priorities = smartFindBy.priority().length > 0 ? 
                                      smartFindBy.priority() : 
                                      new LocatorStrategy[]{
                                          LocatorStrategy.SEMANTIC, 
                                          LocatorStrategy.DOM, 
                                          LocatorStrategy.VISUAL
                                      };
        
        // Initialize strategies based on priorities
        for (LocatorStrategy strategy : priorities) {
            switch (strategy) {
                case SEMANTIC:
                    strategies.add(new SemanticHealingStrategy(smartFindBy.description()));
                    break;
                case DOM:
                    strategies.add(new DomHealingStrategy());
                    break;
                case VISUAL:
                    strategies.add(new VisualHealingStrategy());
                    break;
                default:
                    // For other strategies, default to DOM
                    strategies.add(new DomHealingStrategy());
            }
        }
        
        return strategies;
    }
    
    /**
     * Creates a list of alternate locators from the annotation
     */
    private List<By> createAlternateLocators(CSSmartFindBy smartFindBy) {
        List<By> locators = new ArrayList<>();
        
        if (smartFindBy.alternateLocators() != null) {
            for (AlternateLocator alternateLocator : smartFindBy.alternateLocators()) {
                if (!alternateLocator.id().isEmpty()) {
                    locators.add(By.id(alternateLocator.id()));
                } else if (!alternateLocator.css().isEmpty()) {
                    locators.add(By.cssSelector(alternateLocator.css()));
                } else if (!alternateLocator.xpath().isEmpty()) {
                    locators.add(By.xpath(alternateLocator.xpath()));
                } else if (!alternateLocator.name().isEmpty()) {
                    locators.add(By.name(alternateLocator.name()));
                }
            }
        }
        
        return locators;
    }
    
    /**
     * Finds the element using primary locator first, then tries self-healing if needed
     */
    private WebElement findElement() {
        try {
            // Try primary locator first
            WebElement element = driver.findElement(primaryLocator);
            if (element != null) {
                // If fingerprinting is enabled, create/update fingerprint
                if (smartFindBy.fingerprint()) {
                    createOrUpdateFingerprint(element);
                }
                return element;
            }
        } catch (NoSuchElementException | StaleElementReferenceException e) {
            // Primary locator failed, try self-healing
            if (smartFindBy.failureHandling() == FailureHandling.SELF_HEAL) {
                WebElement healedElement = attemptSelfHealing(e);
                if (healedElement != null) {
                    return healedElement;
                }
            } else if (smartFindBy.failureHandling() == FailureHandling.CONTINUE) {
                logger.warning("Element not found with primary locator for: " + elementName);
            } else {
                throw new ElementNotFoundException("Failed to find element: " + elementName, e);
            }
        }
        
        throw new ElementNotFoundException("Could not find element: " + elementName);
    }
    
    /**
     * Attempts to heal the element by trying alternate locators and healing strategies
     */
    private WebElement attemptSelfHealing(Exception originalException) {
        HealingContext context = new HealingContext(driver, elementName, smartFindBy.description(), originalException);
        logger.info("Attempting self-healing for element: " + elementName);
        
        // First try alternate locators
        WebElement element = findWithAlternateLocators();
        if (element != null) {
            recordHealingSuccess("ALTERNATE_LOCATOR", "Found element using alternate locator");
            return element;
        }
        
        // If fingerprint exists, try finding by fingerprint
        if (fingerprint != null) {
            element = fingerprint.findElement(driver);
            if (element != null) {
                recordHealingSuccess("FINGERPRINT", "Found element using fingerprint");
                return element;
            }
        }
        
        // Try each healing strategy in priority order
        for (HealingStrategy strategy : healingStrategies) {
            try {
                logger.info("Trying healing strategy: " + strategy.getClass().getSimpleName());
                HealingResult result = strategy.heal(context);
                
                if (result.isSuccess() && result.getElement() != null) {
                    // Record successful strategy for future optimization
                    recordHealingSuccess(strategy.getClass().getSimpleName(), result.getMessage());
                    
                    // Update fingerprint for future use
                    if (smartFindBy.fingerprint()) {
                        createOrUpdateFingerprint(result.getElement());
                    }
                    
                    return result.getElement();
                }
            } catch (Exception e) {
                logger.error("Error in healing strategy: " + strategy.getClass().getSimpleName(), e);
            }
        }
        
        // All healing strategies failed
        recordHealingFailure("All healing strategies failed for element: " + elementName);
        return null;
    }
    
    /**
     * Tries to find the element using the alternate locators
     */
    private WebElement findWithAlternateLocators() {
        for (By locator : alternateLocators) {
            try {
                logger.info("Trying alternate locator: " + locator);
                WebElement element = driver.findElement(locator);
                if (element != null && element.isDisplayed()) {
                    return element;
                }
            } catch (Exception e) {
                // Continue with next locator
            }
        }
        return null;
    }
    
    /**
     * Creates or updates the element fingerprint
     */
    private void createOrUpdateFingerprint(WebElement element) {
        try {
            if (fingerprint == null) {
                fingerprint = new ElementFingerprint(element, elementId);
                elementFingerprints.put(elementId, fingerprint);
            } else {
                fingerprint.update(element);
            }
        } catch (Exception e) {
            logger.error("Failed to create element fingerprint", e);
        }
    }
    
    /**
     * Records successful healing for future strategy optimization
     */
    private void recordHealingSuccess(String strategy, String message) {
        HealingResult result = new HealingResult(true, strategy, message, null);
        recordHealingResult(result);
        logger.info("Self-healing succeeded using strategy: " + strategy + " - " + message);
    }
    
    /**
     * Records healing failure for analysis
     */
    private void recordHealingFailure(String message) {
        HealingResult result = new HealingResult(false, "ALL", message, null);
        recordHealingResult(result);
        logger.warning("Self-healing failed: " + message);
    }
    
    /**
     * Records healing result to history
     */
    private void recordHealingResult(HealingResult result) {
        healingHistory.computeIfAbsent(elementName, k -> new ArrayList<>()).add(result);
    }
    
    /**
     * Gets healing history statistics
     */
    public static Map<String, Map<String, Integer>> getHealingStats() {
        Map<String, Map<String, Integer>> stats = new HashMap<>();
        
        healingHistory.forEach((element, results) -> {
            Map<String, Integer> elementStats = new HashMap<>();
            // Count successes by strategy
            results.stream()
                  .filter(HealingResult::isSuccess)
                  .collect(Collectors.groupingBy(HealingResult::getStrategy, Collectors.counting()))
                  .forEach((strategy, count) -> elementStats.put(strategy, count.intValue()));
            
            // Add failure count
            long failures = results.stream().filter(r -> !r.isSuccess()).count();
            elementStats.put("FAILURES", (int) failures);
            
            stats.put(element, elementStats);
        });
        
        return stats;
    }
    
    /**
     * Analyzes healing history to optimize strategy order
     */
    public void optimizeHealingStrategies() {
        List<HealingResult> history = healingHistory.get(elementName);
        if (history == null || history.size() < 5) {
            // Not enough data to optimize
            return;
        }
        
        // Create frequency map of successful strategies
        Map<String, Long> successCounts = history.stream()
            .filter(HealingResult::isSuccess)
            .collect(Collectors.groupingBy(HealingResult::getStrategy, Collectors.counting()));
        
        // Sort healing strategies by success rate
        healingStrategies.sort((s1, s2) -> {
            String name1 = s1.getClass().getSimpleName();
            String name2 = s2.getClass().getSimpleName();
            Long count1 = successCounts.getOrDefault(name1, 0L);
            Long count2 = successCounts.getOrDefault(name2, 0L);
            return count2.compareTo(count1); // Descending order
        });
        
        logger.info("Optimized healing strategies for " + elementName + ": " + 
            healingStrategies.stream()
                .map(s -> s.getClass().getSimpleName())
                .collect(Collectors.joining(", ")));
    }
    
    /**
     * Ensures the element is found and wrapped before any operation
     */
    private WebElement getWrappedElement() {
        if (wrappedElement == null) {
            wrappedElement = findElement();
        }
        return wrappedElement;
    }
    
    /**
     * Clears the wrapped element reference to force finding it again
     */
    public void refresh() {
        wrappedElement = null;
    }
    
    // WebElement implementation methods that delegate to the wrapped element
    
    @Override
    public void click() {
        try {
            getWrappedElement().click();
        } catch (StaleElementReferenceException e) {
            // Element became stale, refresh and retry
            refresh();
            getWrappedElement().click();
        }
    }
    
    @Override
    public void submit() {
        try {
            getWrappedElement().submit();
        } catch (StaleElementReferenceException e) {
            refresh();
            getWrappedElement().submit();
        }
    }
    
    @Override
    public void sendKeys(CharSequence... keysToSend) {
        try {
            getWrappedElement().sendKeys(keysToSend);
        } catch (StaleElementReferenceException e) {
            refresh();
            getWrappedElement().sendKeys(keysToSend);
        }
    }
    
    @Override
    public void clear() {
        try {
            getWrappedElement().clear();
        } catch (StaleElementReferenceException e) {
            refresh();
            getWrappedElement().clear();
        }
    }
    
    @Override
    public String getTagName() {
        try {
            return getWrappedElement().getTagName();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getTagName();
        }
    }
    
    @Override
    public String getAttribute(String name) {
        try {
            return getWrappedElement().getAttribute(name);
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getAttribute(name);
        }
    }
    
    @Override
    public boolean isSelected() {
        try {
            return getWrappedElement().isSelected();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().isSelected();
        }
    }
    
    @Override
    public boolean isEnabled() {
        try {
            return getWrappedElement().isEnabled();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().isEnabled();
        }
    }
    
    @Override
    public String getText() {
        try {
            return getWrappedElement().getText();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getText();
        }
    }
    
    @Override
    public List<WebElement> findElements(By by) {
        try {
            return getWrappedElement().findElements(by);
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().findElements(by);
        }
    }
    
    @Override
    public WebElement findElement(By by) {
        try {
            return getWrappedElement().findElement(by);
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().findElement(by);
        }
    }
    
    @Override
    public boolean isDisplayed() {
        try {
            return getWrappedElement().isDisplayed();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().isDisplayed();
        }
    }
    
    @Override
    public Point getLocation() {
        try {
            return getWrappedElement().getLocation();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getLocation();
        }
    }
    
    @Override
    public Dimension getSize() {
        try {
            return getWrappedElement().getSize();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getSize();
        }
    }
    
    @Override
    public Rectangle getRect() {
        try {
            return getWrappedElement().getRect();
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getRect();
        }
    }
    
    @Override
    public String getCssValue(String propertyName) {
        try {
            return getWrappedElement().getCssValue(propertyName);
        } catch (StaleElementReferenceException e) {
            refresh();
            return getWrappedElement().getCssValue(propertyName);
        }
    }
    
    /**
     * Performs a smart action on the element based on its type
     */
    public void smartSet(Object value) {
        WebElement element = getWrappedElement();
        String tagName = element.getTagName().toLowerCase();
        
        if (value == null) {
            return;
        }
        
        String valueStr = value.toString();
        
        switch (tagName) {
            case "input":
                String type = element.getAttribute("type");
                if (type == null) type = "text";
                
                switch (type.toLowerCase()) {
                    case "checkbox":
                        boolean check = Boolean.parseBoolean(valueStr);
                        if (element.isSelected() != check) {
                            element.click();
                        }
                        break;
                    case "radio":
                        if (valueStr.equalsIgnoreCase("true") || valueStr.equals("1")) {
                            if (!element.isSelected()) {
                                element.click();
                            }
                        }
                        break;
                    case "date":
                    case "datetime-local":
                    case "month":
                    case "week":
                    case "time":
                        element.clear();
                        element.sendKeys(valueStr);
                        break;
                    default:
                        element.clear();
                        element.sendKeys(valueStr);
                }
                break;
                
            case "select":
                // Handle select element differently - need to implement proper select handling
                try {
                    org.openqa.selenium.support.ui.Select select = 
                        new org.openqa.selenium.support.ui.Select(element);
                    
                    // Try by visible text first
                    try {
                        select.selectByVisibleText(valueStr);
                    } catch (NoSuchElementException e) {
                        // Try by value
                        try {
                            select.selectByValue(valueStr);
                        } catch (NoSuchElementException e2) {
                            // Try by semantic meaning - this would use our NLP capabilities
                            selectByMeaning(select, valueStr);
                        }
                    }
                } catch (Exception e) {
                    logger.error("Failed to select option in dropdown", e);
                }
                break;
                
            case "textarea":
                element.clear();
                element.sendKeys(valueStr);
                break;
                
            default:
                // For any other element, just click or set value based on context
                if (valueStr.equals("click")) {
                    element.click();
                } else {
                    try {
                        element.clear();
                        element.sendKeys(valueStr);
                    } catch (Exception e) {
                        // If sending keys fails, try click as fallback
                        element.click();
                    }
                }
        }
    }
    
    /**
     * Select an option by semantic meaning instead of exact text match
     */
    private void selectByMeaning(org.openqa.selenium.support.ui.Select select, String meaning) {
        List<WebElement> options = select.getOptions();
        WebElement bestMatch = null;
        double bestScore = 0;
        
        for (WebElement option : options) {
            String text = option.getText().trim().toLowerCase();
            String value = option.getAttribute("value");
            
            double score = calculateSimilarity(text, meaning.toLowerCase());
            double valueScore = calculateSimilarity(value, meaning.toLowerCase());
            
            // Use the better of the two scores
            score = Math.max(score, valueScore);
            
            if (score > bestScore && score > 0.6) { // Threshold for acceptance
                bestScore = score;
                bestMatch = option;
            }
        }
        
        if (bestMatch != null) {
            // Click the option directly rather than using select methods
            bestMatch.click();
        } else {
            throw new NoSuchElementException("No option found matching semantic meaning: " + meaning);
        }
    }
    
    /**
     * Calculate text similarity using a simple algorithm
     * This is a basic implementation that could be replaced with more sophisticated NLP
     */
    private double calculateSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        
        // Check for direct containment
        if (text1.contains(text2) || text2.contains(text1)) {
            return 0.8; // High score for substring matches
        }
        
        // Calculate word overlap
        Set<String> words1 = new HashSet<>(Arrays.asList(text1.split("\\s+")));
        Set<String> words2 = new HashSet<>(Arrays.asList(text2.split("\\s+")));
        
        Set<String> intersection = new HashSet<>(words1);
        intersection.retainAll(words2);
        
        Set<String> union = new HashSet<>(words1);
        union.addAll(words2);
        
        if (union.isEmpty()) {
            return 0;
        }
        
        // Jaccard similarity: intersection size / union size
        return (double) intersection.size() / union.size();
    }
    
    /**
     * Assert the element is in a specific state
     */
    public void assertState(ElementState expectedState) {
        boolean result = false;
        WebElement element = getWrappedElement();
        
        switch (expectedState) {
            case VISIBLE:
                result = element.isDisplayed();
                break;
            case INVISIBLE:
                try {
                    result = !element.isDisplayed();
                } catch (StaleElementReferenceException | NoSuchElementException e) {
                    result = true; // Element not in DOM means it's invisible
                }
                break;
            case ENABLED:
                result = element.isEnabled();
                break;
            case DISABLED:
                result = !element.isEnabled();
                break;
            case SELECTED:
                result = element.isSelected();
                break;
            case UNSELECTED:
                result = !element.isSelected();
                break;
        }
        
        if (!result) {
            throw new AssertionError("Element " + elementName + " is not in expected state: " + expectedState);
        }
    }
    
    /**
     * Assert the element's text has a specific semantic meaning
     */
    public void assertMeaning(Object expectedMeaning) {
        WebElement element = getWrappedElement();
        String actualText = element.getText().trim();
        
        if (expectedMeaning == null) {
            throw new IllegalArgumentException("Expected meaning cannot be null");
        }
        
        String expectedText = expectedMeaning.toString();
        double similarity = calculateSimilarity(actualText.toLowerCase(), expectedText.toLowerCase());
        
        // Use a threshold for semantic matching
        if (similarity < 0.6) {
            throw new AssertionError("Element " + elementName + " text '" + actualText + 
                "' does not match expected meaning '" + expectedText + "' (similarity: " + similarity + ")");
        }
    }
    
    /**
     * Wait for the element using smart wait strategy
     */
    public CSSmartWebElement smartWait() {
        // This would be implemented with the smart wait strategy
        // For now, just refresh to ensure latest element
        refresh();
        return this;
    }
}


package com.cssmart.framework.fingerprint;

import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.*;

import java.util.*;

/**
 * ElementFingerprint creates a unique identity for an element based on its
 * properties and surrounding context in the DOM, enabling the framework to
 * find the element even when common locators change.
 */
public class ElementFingerprint {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(ElementFingerprint.class);
    
    // Properties stored in the fingerprint
    private final String elementId;
    private String tagName;
    private Map<String, String> attributes;
    private String innerText;
    private String className;
    private List<String> cssProperties;
    private Map<String, Double> relativePositions;
    private DomContext domContext;
    private Map<String, Integer> attributeWeights;
    
    /**
     * Creates a new fingerprint for the specified element
     */
    public ElementFingerprint(WebElement element, String elementId) {
        this.elementId = elementId;
        this.attributeWeights = initializeAttributeWeights();
        captureFingerprint(element);
    }
    
    /**
     * Initialize the weighting system for different attributes
     * These weights determine how important each attribute is in matching
     */
    private Map<String, Integer> initializeAttributeWeights() {
        Map<String, Integer> weights = new HashMap<>();
        weights.put("id", 100);          // ID is highest priority
        weights.put("name", 90);         // Name is next highest
        weights.put("class", 60);        // Class is important but changes more often
        weights.put("type", 70);         // Type is fairly stable
        weights.put("value", 40);        // Value can change
        weights.put("href", 50);         // Links are somewhat stable
        weights.put("text", 80);         // Text content is very useful for identifying elements
        weights.put("placeholder", 65);  // Placeholder text is useful
        weights.put("title", 55);        // Title attribute is helpful
        weights.put("tagName", 75);      // Tag name is very stable
        weights.put("position", 30);     // Position is less reliable
        weights.put("size", 20);         // Size can vary
        weights.put("domContext", 85);   // DOM context is very valuable
        return weights;
    }
    
    /**
     * Captures all the properties of the element to form a fingerprint
     */
    private void captureFingerprint(WebElement element) {
        try {
            // Capture basic element properties
            this.tagName = element.getTagName().toLowerCase();
            this.attributes = captureAttributes(element);
            this.innerText = element.getText();
            this.className = element.getAttribute("class");
            
            // Capture CSS properties that might be useful
            this.cssProperties = captureCssProperties(element);
            
            // Capture relative positions to nearby elements
            this.relativePositions = captureRelativePositions(element);
            
            // Capture DOM context (parent and sibling structure)
            this.domContext = captureDomContext(element);
            
        } catch (Exception e) {
            logger.error("Error capturing element fingerprint", e);
        }
    }
    
    /**
     * Captures all attributes of the element
     */
    private Map<String, String> captureAttributes(WebElement element) {
        Map<String, String> attrs = new HashMap<>();
        
        // Common attributes to capture
        String[] commonAttributes = {
            "id", "name", "class", "type", "value", "href", "src", "alt", 
            "title", "placeholder", "role", "aria-label", "data-testid"
        };
        
        for (String attr : commonAttributes) {
            try {
                String value = element.getAttribute(attr);
                if (value != null && !value.isEmpty()) {
                    attrs.put(attr, value);
                }
            } catch (Exception e) {
                // Ignore errors for specific attributes
            }
        }
        
        // Also try to capture any data-* attributes
        try {
            // This would normally use JavaScript to get all attributes
            // Here we're just capturing some common ones
            String[] dataAttrs = {"data-id", "data-name", "data-value", "data-target"};
            for (String attr : dataAttrs) {
                String value = element.getAttribute(attr);
                if (value != null && !value.isEmpty()) {
                    attrs.put(attr, value);
                }
            }
        } catch (Exception e) {
            logger.debug("Error capturing data attributes", e);
        }
        
        return attrs;
    }
    
    /**
     * Captures important CSS properties
     */
    private List<String> captureCssProperties(WebElement element) {
        List<String> properties = new ArrayList<>();
        String[] cssProps = {
            "display", "position", "width", "height", "color", 
            "background-color", "font-size", "text-align", "margin", "padding"
        };
        
        for (String prop : cssProps) {
            try {
                String value = element.getCssValue(prop);
                if (value != null && !value.isEmpty() && !value.equals("none")) {
                    properties.add(prop + ":" + value);
                }
            } catch (Exception e) {
                // Ignore errors for specific properties
            }
        }
        
        return properties;
    }
    
    /**
     * Captures relative positions to nearby elements
     */
    private Map<String, Double> captureRelativePositions(WebElement element) {
        Map<String, Double> positions = new HashMap<>();
        
        try {
            Point location = element.getLocation();
            Dimension size = element.getSize();
            
            // Center point of the element
            int centerX = location.getX() + size.getWidth() / 2;
            int centerY = location.getY() + size.getHeight() / 2;
            
            // Store center coordinates
            positions.put("centerX", (double) centerX);
            positions.put("centerY", (double) centerY);
            
            // HTML element dimensions for relative positioning
            WebElement html = element.findElement(By.tagName("html"));
            Dimension htmlSize = html.getSize();
            
            // Calculate relative positions
            positions.put("relativeX", (double) centerX / htmlSize.getWidth());
            positions.put("relativeY", (double) centerY / htmlSize.getHeight());
            
            // Add size information
            positions.put("width", (double) size.getWidth());
            positions.put("height", (double) size.getHeight());
            positions.put("relativeWidth", (double) size.getWidth() / htmlSize.getWidth());
            positions.put("relativeHeight", (double) size.getHeight() / htmlSize.getHeight());
            
        } catch (Exception e) {
            logger.debug("Error capturing relative positions", e);
        }
        
        return positions;
    }
    
    /**
     * Captures the DOM context surrounding the element
     */
    private DomContext captureDomContext(WebElement element) {
        DomContext context = new DomContext();
        
        try {
            // Get information about the element's parent
            WebElement parent = findParent(element);
            if (parent != null) {
                context.setParentTag(parent.getTagName().toLowerCase());
                context.setParentClass(parent.getAttribute("class"));
                context.setParentId(parent.getAttribute("id"));
            }
            
            // Get information about siblings
            List<WebElement> siblings = findSiblings(element, parent);
            for (WebElement sibling : siblings) {
                if (sibling.equals(element)) continue;
                
                SiblingInfo info = new SiblingInfo();
                info.setTag(sibling.getTagName().toLowerCase());
                info.setClassName(sibling.getAttribute("class"));
                info.setId(sibling.getAttribute("id"));
                info.setText(sibling.getText());
                
                context.addSibling(info);
            }
            
            // Get the path from the root to this element (simplified XPath)
            context.setDomPath(generateSimplifiedXPath(element));
            
        } catch (Exception e) {
            logger.debug("Error capturing DOM context", e);
        }
        
        return context;
    }
    
    /**
     * Finds the parent element
     */
    private WebElement findParent(WebElement element) {
        try {
            // We would normally use JavaScript for this
            // This is a simplified version using XPath
            return element.findElement(By.xpath(".."));
        } catch (Exception e) {
            logger.debug("Error finding parent element", e);
            return null;
        }
    }
    
    /**
     * Finds sibling elements
     */
    private List<WebElement> findSiblings(WebElement element, WebElement parent) {
        if (parent == null) return Collections.emptyList();
        
        try {
            // Find all children of the parent element
            return parent.findElements(By.xpath("./*"));
        } catch (Exception e) {
            logger.debug("Error finding sibling elements", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Generates a simplified XPath for the element
     */
    private String generateSimplifiedXPath(WebElement element) {
        // In a real implementation, this would create a full XPath
        // Here we'll just create a simplified representation
        try {
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                return "//*[@id='" + id + "']";
            }
            
            // For this example, return a default value
            // In a real implementation, this would analyze the DOM tree
            return "//simplified-xpath-representation";
            
        } catch (Exception e) {
            logger.debug("Error generating simplified XPath", e);
            return "unknown";
        }
    }
    
    /**
     * Updates the fingerprint with current element properties
     */
    public void update(WebElement element) {
        captureFingerprint(element);
    }
    
    /**
     * Finds an element matching the fingerprint
     */
    public WebElement findElement(WebDriver driver) {
        if (driver == null) return null;
        
        List<WebElement> candidates = new ArrayList<>();
        Map<WebElement, Double> scores = new HashMap<>();
        
        try {
            // First try most reliable strategies
            // 1. Try by ID if available
            if (attributes.containsKey("id")) {
                try {
                    WebElement element = driver.findElement(By.id(attributes.get("id")));
                    double score = calculateMatchScore(element);
                    if (score > 0.9) { // Very high confidence
                        return element;
                    }
                    candidates.add(element);
                    scores.put(element, score);
                } catch (Exception e) {
                    // ID changed or element not found
                }
            }
            
            // 2. Try by name if available
            if (attributes.containsKey("name")) {
                try {
                    WebElement element = driver.findElement(By.name(attributes.get("name")));
                    if (!candidates.contains(element)) {
                        double score = calculateMatchScore(element);
                        candidates.add(element);
                        scores.put(element, score);
                    }
                } catch (Exception e) {
                    // Name changed or element not found
                }
            }
            
            // 3. Try by class name
            if (className != null && !className.isEmpty()) {
                // Split multiple classes and use the most specific one
                String[] classes = className.split("\\s+");
                for (String cls : classes) {
                    if (cls.isEmpty() || cls.contains(" ")) continue;
                    
                    try {
                        List<WebElement> elements = driver.findElements(By.className(cls));
                        for (WebElement element : elements) {
                            if (!candidates.contains(element)) {
                                double score = calculateMatchScore(element);
                                candidates.add(element);
                                scores.put(element, score);
                            }
                        }
                    } catch (Exception e) {
                        // Class name invalid or not found
                    }
                }
            }
            
            // 4. Try by tag and text content
            if (innerText != null && !innerText.isEmpty()) {
                String xpathExpression = "//" + tagName + "[contains(text(),'" + 
                                      innerText.replace("'", "\\'") + "')]";
                try {
                    List<WebElement> elements = driver.findElements(By.xpath(xpathExpression));
                    for (WebElement element : elements) {
                        if (!candidates.contains(element)) {
                            double score = calculateMatchScore(element);
                            candidates.add(element);
                            scores.put(element, score);
                        }
                    }
                } catch (Exception e) {
                    // XPath invalid or no matches
                }
            }
            
            // 5. Try by DOM context
            if (domContext != null && domContext.getParentId() != null && !domContext.getParentId().isEmpty()) {
                try {
                    WebElement parent = driver.findElement(By.id(domContext.getParentId()));
                    List<WebElement> children = parent.findElements(By.tagName(tagName));
                    for (WebElement element : children) {
                        if (!candidates.contains(element)) {
                            double score = calculateMatchScore(element);
                            candidates.add(element);
                            scores.put(element, score);
                        }
                    }
                } catch (Exception e) {
                    // Parent ID changed or not found
                }
            }
            
            // 6. Try by CSS selector with multiple attribute combinations
            for (Map.Entry<String, String> attr : attributes.entrySet()) {
                if ("id".equals(attr.getKey()) || "name".equals(attr.getKey()) || 
                    "class".equals(attr.getKey())) {
                    // We already tried these
                    continue;
                }
                
                String cssSelector = tagName + "[" + attr.getKey() + "='" + 
                                    attr.getValue().replace("'", "\\'") + "']";
                try {
                    List<WebElement> elements = driver.findElements(By.cssSelector(cssSelector));
                    for (WebElement element : elements) {
                        if (!candidates.contains(element)) {
                            double score = calculateMatchScore(element);
                            candidates.add(element);
                            scores.put(element, score);
                        }
                    }
                } catch (Exception e) {
                    // CSS selector invalid or no matches
                }
            }
            
            // Find the element with the highest match score above our threshold
            WebElement bestMatch = null;
            double bestScore = 0.7; // Minimum threshold for a match
            
            for (Map.Entry<WebElement, Double> entry : scores.entrySet()) {
                if (entry.getValue() > bestScore) {
                    bestScore = entry.getValue();
                    bestMatch = entry.getKey();
                }
            }
            
            if (bestMatch != null) {
                logger.info("Found element match with confidence score: " + bestScore);
                return bestMatch;
            }
            
        } catch (Exception e) {
            logger.error("Error finding element by fingerprint", e);
        }
        
        return null;
    }
    
    /**
     * Calculates how well an element matches this fingerprint
     */
    private double calculateMatchScore(WebElement element) {
        if (element == null) return 0;
        
        double totalScore = 0;
        double maxPossibleScore = 0;
        
        try {
            // Check tag name
            int tagWeight = attributeWeights.getOrDefault("tagName", 75);
            maxPossibleScore += tagWeight;
            if (tagName.equals(element.getTagName().toLowerCase())) {
                totalScore += tagWeight;
            }
            
            // Check attributes
            for (Map.Entry<String, String> attr : attributes.entrySet()) {
                String attrName = attr.getKey();
                String expectedValue = attr.getValue();
                int weight = attributeWeights.getOrDefault(attrName, 50);
                
                maxPossibleScore += weight;
                String actualValue = element.getAttribute(attrName);
                
                if (expectedValue.equals(actualValue)) {
                    totalScore += weight;
                } else if (actualValue != null && !actualValue.isEmpty()) {
                    // Partial match for some attributes
                    if (expectedValue.contains(actualValue) || actualValue.contains(expectedValue)) {
                        totalScore += weight * 0.7; // 70% credit for partial match
                    }
                }
            }
            
            // Check inner text
            int textWeight = attributeWeights.getOrDefault("text", 80);
            maxPossibleScore += textWeight;
            String elementText = element.getText();
            
            if (innerText != null && elementText != null) {
                if (innerText.equals(elementText)) {
                    totalScore += textWeight;
                } else if (innerText.contains(elementText) || elementText.contains(innerText)) {
                    // Partial text match
                    double ratio = (double) Math.min(innerText.length(), elementText.length()) / 
                                  Math.max(innerText.length(), elementText.length());
                    totalScore += textWeight * ratio;
                }
            }
            
            // Check DOM context
            if (domContext != null) {
                int domWeight = attributeWeights.getOrDefault("domContext", 85);
                maxPossibleScore += domWeight;
                
                WebElement parent = findParent(element);
                if (parent != null) {
                    double contextScore = 0;
                    
                    // Check parent tag
                    if (domContext.getParentTag() != null && 
                        domContext.getParentTag().equals(parent.getTagName().toLowerCase())) {
                        contextScore += 0.25;
                    }
                    
                    // Check parent class
                    String parentClass = parent.getAttribute("class");
                    if (domContext.getParentClass() != null && parentClass != null && 
                        (domContext.getParentClass().equals(parentClass) || 
                         parentClass.contains(domContext.getParentClass()))) {
                        contextScore += 0.25;
                    }
                    
                    // Check parent ID
                    String parentId = parent.getAttribute("id");
                    if (domContext.getParentId() != null && parentId != null && 
                        domContext.getParentId().equals(parentId)) {
                        contextScore += 0.5;
                    }
                    
                    totalScore += domWeight * contextScore;
                }
            }
            
            // Check position in viewport
            if (relativePositions != null && !relativePositions.isEmpty()) {
                int posWeight = attributeWeights.getOrDefault("position", 30);
                maxPossibleScore += posWeight;
                
                try {
                    Point location = element.getLocation();
                    Dimension size = element.getSize();
                    
                    // Center point of the element
                    int centerX = location.getX() + size.getWidth() / 2;
                    int centerY = location.getY() + size.getHeight() / 2;
                    
                    // HTML element dimensions
                    WebElement html = element.findElement(By.tagName("html"));
                    Dimension htmlSize = html.getSize();
                    
                    // Calculate current relative positions
                    double currentRelX = (double) centerX / htmlSize.getWidth();
                    double currentRelY = (double) centerY / htmlSize.getHeight();
                    
                    // Compare with stored values
                    double expectedRelX = relativePositions.getOrDefault("relativeX", 0.0);
                    double expectedRelY = relativePositions.getOrDefault("relativeY", 0.0);
                    
                    // Calculate position difference
                    double xDiff = Math.abs(currentRelX - expectedRelX);
                    double yDiff = Math.abs(currentRelY - expectedRelY);
                    
                    // If within 10% of original position, give full credit, otherwise partial
                    double positionScore = 0;
                    if (xDiff < 0.1 && yDiff < 0.1) {
                        positionScore = 1.0;
                    } else if (xDiff < 0.2 && yDiff < 0.2) {
                        positionScore = 0.7;
                    } else if (xDiff < 0.3 && yDiff < 0.3) {
                        positionScore = 0.3;
                    }
                    
                    totalScore += posWeight * positionScore;
                    
                } catch (Exception e) {
                    // Error calculating position, skip this check
                }
            }
            
        } catch (Exception e) {
            logger.error("Error calculating match score", e);
            return 0;
        }
        
        // Return a normalized score
        return maxPossibleScore > 0 ? (totalScore / maxPossibleScore) : 0;
    }
    
    // Nested classes for DOM context tracking
    
    /**
     * Represents the DOM context of an element
     */
    public static class DomContext {
        private String parentTag;
        private String parentClass;
        private String parentId;
        private List<SiblingInfo> siblings = new ArrayList<>();
        private String domPath;
        
        public String getParentTag() {
            return parentTag;
        }
        
        public void setParentTag(String parentTag) {
            this.parentTag = parentTag;
        }
        
        public String getParentClass() {
            return parentClass;
        }
        
        public void setParentClass(String parentClass) {
            this.parentClass = parentClass;
        }
        
        public String getParentId() {
            return parentId;
        }
        
        public void setParentId(String parentId) {
            this.parentId = parentId;
        }
        
        public List<SiblingInfo> getSiblings() {
            return siblings;
        }
        
        public void addSibling(SiblingInfo sibling) {
            this.siblings.add(sibling);
        }
        
        public String getDomPath() {
            return domPath;
        }
        
        public void setDomPath(String domPath) {
            this.domPath = domPath;
        }
    }
    
    /**
     * Information about a sibling element
     */
    public static class SiblingInfo {
        private String tag;
        private String className;
        private String id;
        private String text;
        
        public String getTag() {
            return tag;
        }
        
        public void setTag(String tag) {
            this.tag = tag;
        }
        
        public String getClassName() {
            return className;
        }
        
        public void setClassName(String className) {
            this.className = className;
        }
        
        public String getId() {
            return id;
        }
        
        public void setId(String id) {
            this.id = id;
        }
        
        public String getText() {
            return text;
        }
        
        public void setText(String text) {
            this.text = text;
        }
    }
}


package com.cssmart.framework.healing.impl;

import com.cssmart.framework.healing.HealingContext;
import com.cssmart.framework.healing.HealingResult;
import com.cssmart.framework.healing.HealingStrategy;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Semantic healing strategy uses natural language processing principles
 * to locate elements based on their textual description and semantic meaning.
 */
public class SemanticHealingStrategy implements HealingStrategy {
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(SemanticHealingStrategy.class);
    
    // Description used for semantic matching
    private final String elementDescription;
    
    // Cache of common terms and synonyms
    private static final Map<String, List<String>> synonymDictionary = initializeSynonymDictionary();
    
    // Common button text patterns
    private static final List<Pattern> buttonPatterns = initializeButtonPatterns();
    
    // Common form field patterns
    private static final List<Pattern> formFieldPatterns = initializeFormFieldPatterns();
    
    public SemanticHealingStrategy(String elementDescription) {
        this.elementDescription = elementDescription != null ? elementDescription : "";
    }
    
    @Override
    public HealingResult heal(HealingContext context) {
        if (elementDescription.isEmpty()) {
            return new HealingResult(false, "SEMANTIC", "No element description available for semantic healing", null);
        }
        
        logger.info("Attempting semantic healing for: " + elementDescription);
        
        WebDriver driver = context.getDriver();
        if (driver == null) {
            return new HealingResult(false, "SEMANTIC", "WebDriver is null", null);
        }
        
        // Parse the description to extract key information
        Map<String, String> semanticInfo = parseDescription(elementDescription);
        String elementType = semanticInfo.getOrDefault("elementType", "");
        String elementPurpose = semanticInfo.getOrDefault("elementPurpose", "");
        String elementLocation = semanticInfo.getOrDefault("elementLocation", "");
        
        // Choose search strategy based on extracted information
        if (!elementType.isEmpty()) {
            // Try to find by element type and other extracted information
            WebElement element = findByTypeAndPurpose(driver, elementType, elementPurpose, elementLocation);
            
            if (element != null) {
                return new HealingResult(true, "SEMANTIC", 
                    "Element found by semantic type '" + elementType + "' and purpose '" + elementPurpose + "'", element);
            }
        }
        
        // If no specific type extracted or type-based search failed, try keyword-based search
        List<String> keywords = extractKeywords(elementDescription);
        WebElement element = findByKeywords(driver, keywords);
        
        if (element != null) {
            return new HealingResult(true, "SEMANTIC", 
                "Element found by semantic keywords: " + String.join(", ", keywords), element);
        }
        
        // Try finding by expanded synonyms if direct keywords failed
        List<String> expandedKeywords = expandWithSynonyms(keywords);
        element = findByKeywords(driver, expandedKeywords);
        
        if (element != null) {
            return new HealingResult(true, "SEMANTIC", 
                "Element found by expanded semantic keywords with synonyms", element);
        }
        
        // All semantic approaches failed
        return new HealingResult(false, "SEMANTIC", 
            "Semantic healing failed to locate element matching '" + elementDescription + "'", null);
    }
    
    /**
     * Parses a natural language description to extract semantic information
     */
    private Map<String, String> parseDescription(String description) {
        Map<String, String> result = new HashMap<>();
        description = description.toLowerCase();
        
        // Extract element type
        if (description.contains("button") || description.contains("btn")) {
            result.put("elementType", "button");
        } else if (description.contains("input") || description.contains("field") || 
                  description.contains("textbox") || description.contains("text box")) {
            result.put("elementType", "input");
        } else if (description.contains("checkbox") || description.contains("check box")) {
            result.put("elementType", "checkbox");
        } else if (description.contains("radio") || description.contains("option")) {
            result.put("elementType", "radio");
        } else if (description.contains("dropdown") || description.contains("drop down") || 
                  description.contains("select") || description.contains("combobox")) {
            result.put("elementType", "select");
        } else if (description.contains("link")) {
            result.put("elementType", "link");
        } else if (description.contains("image") || description.contains("img") || 
                  description.contains("icon")) {
            result.put("elementType", "image");
        } else if (description.contains("header") || description.contains("heading") || 
                  description.matches(".*(h1|h2|h3|h4|h5|h6).*")) {
            result.put("elementType", "heading");
        }
        
        // Extract element purpose (e.g., "login", "submit", "search")
        List<String> commonPurposes = Arrays.asList(
            "login", "logout", "sign in", "signup", "sign up", "register", 
            "submit", "save", "cancel", "delete", "remove", "add", "create", 
            "edit", "update", "search", "find", "filter", "sort", "download", 
            "upload", "send", "share", "like", "follow", "comment", "accept", 
            "confirm", "ok", "agree", "disagree", "next", "previous", "back"
        );
        
        for (String purpose : commonPurposes) {
            if (description.contains(purpose)) {
                result.put("elementPurpose", purpose);
                break;
            }
        }
        
        // Extract position/location references
        if (description.contains("top") || description.contains("upper") || 
            description.contains("above") || description.contains("header")) {
            result.put("elementLocation", "top");
        } else if (description.contains("bottom") || description.contains("lower") || 
                  description.contains("below") || description.contains("footer")) {
            result.put("elementLocation", "bottom");
        } else if (description.contains("left") || description.contains("beginning") || 
                  description.contains("start")) {
            result.put("elementLocation", "left");
        } else if (description.contains("right") || description.contains("end")) {
            result.put("elementLocation", "right");
        } else if (description.contains("middle") || description.contains("center")) {
            result.put("elementLocation", "center");
        }
        
        return result;
    }
    
    /**
     * Extracts relevant keywords from the description
     */
    private List<String> extractKeywords(String description) {
        // Convert to lowercase and tokenize
        String normalized = description.toLowerCase();
        String[] words = normalized.split("\\s+");
        
        // Remove stop words and keep important keywords
        Set<String> stopWords = new HashSet<>(Arrays.asList(
            "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", 
            "with", "by", "about", "of", "from", "as", "this", "that", "these", 
            "those", "is", "are", "was", "were", "be", "been", "being"
        ));
        
        List<String> keywords = new ArrayList<>();
        for (String word : words) {
            // Clean word of punctuation
            word = word.replaceAll("[^a-zA-Z0-9]", "");
            if (!word.isEmpty() && !stopWords.contains(word) && word.length() > 2) {
                keywords.add(word);
            }
        }
        
        return keywords;
    }
    
    /**
     * Expand keywords with synonyms
     */
    private List<String> expandWithSynonyms(List<String> keywords) {
        Set<String> expanded = new HashSet<>(keywords);
        
        for (String keyword : keywords) {
            List<String> synonyms = synonymDictionary.getOrDefault(keyword, Collections.emptyList());
            expanded.addAll(synonyms);
        }
        
        return new ArrayList<>(expanded);
    }
    
    /**
     * Finds an element by its type and purpose
     */
    private WebElement findByTypeAndPurpose(WebDriver driver, String elementType, String elementPurpose, 
                                          String elementLocation) {
        try {
            switch (elementType) {
                case "button":
                    return findButton(driver, elementPurpose, elementLocation);
                    
                case "input":
                    return findInput(driver, elementPurpose, elementLocation);
                    
                case "checkbox":
                    return findCheckbox(driver, elementPurpose, elementLocation);
                    
                case "radio":
                    return findRadio(driver, elementPurpose, elementLocation);
                    
                case "select":
                    return findSelect(driver, elementPurpose, elementLocation);
                    
                case "link":
                    return findLink(driver, elementPurpose, elementLocation);
                    
                case "image":
                    return findImage(driver, elementPurpose, elementLocation);
                    
                case "heading":
                    return findHeading(driver, elementPurpose, elementLocation);
                    
                default:
                    return null;
            }
        } catch (Exception e) {
            logger.error("Error in findByTypeAndPurpose", e);
            return null;
        }
    }
    
    /**
     * Finds a button element based on purpose and location
     */
    private WebElement findButton(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for button elements
            candidates.addAll(driver.findElements(By.tagName("button")));
            
            // Look for input elements of type button or submit
            candidates.addAll(driver.findElements(By.cssSelector("input[type='button'], input[type='submit']")));
            
            // Look for anchor tags that look like buttons
            candidates.addAll(driver.findElements(By.cssSelector("a.btn, a.button")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                // Create expanded purpose keywords
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                // Filter by text content, value, or other attributes
                candidates = candidates.stream()
                    .filter(e -> {
                        String text = e.getText().toLowerCase();
                        String value = e.getAttribute("value");
                        value = (value != null) ? value.toLowerCase() : "";
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            text.contains(keyword) || value.contains(keyword) || 
                            ariaLabel.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding input", e);
            return null;
        }
    }
    
    /**
     * Finds a checkbox based on purpose and location
     */
    private WebElement findCheckbox(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for checkbox inputs
            candidates.addAll(driver.findElements(By.cssSelector("input[type='checkbox']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Look for associated label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        // Check attributes
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            labelText.contains(keyword) || name.contains(keyword) || id.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding checkbox", e);
            return null;
        }
    }
    
    /**
     * Finds a radio button based on purpose and location
     */
    private WebElement findRadio(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for radio inputs
            candidates.addAll(driver.findElements(By.cssSelector("input[type='radio']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Look for associated label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        // Check attributes
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        String value = e.getAttribute("value");
                        value = (value != null) ? value.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            labelText.contains(keyword) || name.contains(keyword) || 
                            id.contains(keyword) || value.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding radio button", e);
            return null;
        }
    }
    
    /**
     * Finds a select/dropdown element based on purpose and location
     */
    private WebElement findSelect(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for select elements
            candidates.addAll(driver.findElements(By.tagName("select")));
            
            // Also look for div elements that might be custom dropdowns
            candidates.addAll(driver.findElements(By.cssSelector(
                "div[role='listbox'], div[class*='dropdown'], div[class*='select'], " + 
                "div[class*='combobox'], div[aria-haspopup='listbox']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Look for associated label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        // Check attributes
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        // For select elements, check option values
                        boolean hasMatchingOption = false;
                        if ("select".equals(e.getTagName().toLowerCase())) {
                            List<WebElement> options = e.findElements(By.tagName("option"));
                            for (WebElement option : options) {
                                String optionText = option.getText().toLowerCase();
                                if (purposeKeywords.stream().anyMatch(optionText::contains)) {
                                    hasMatchingOption = true;
                                    break;
                                }
                            }
                        }
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            labelText.contains(keyword) || name.contains(keyword) || 
                            id.contains(keyword) || ariaLabel.contains(keyword)) || 
                            hasMatchingOption;
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding select/dropdown", e);
            return null;
        }
    }
    
    /**
     * Finds a link element based on purpose and location
     */
    private WebElement findLink(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for anchor tags
            candidates.addAll(driver.findElements(By.tagName("a")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        String text = e.getText().toLowerCase();
                        String href = e.getAttribute("href");
                        href = (href != null) ? href.toLowerCase() : "";
                        
                        String title = e.getAttribute("title");
                        title = (title != null) ? title.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            text.contains(keyword) || title.contains(keyword) || 
                            ariaLabel.contains(keyword) || href.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding link", e);
            return null;
        }
    }
    
    /**
     * Finds an image element based on purpose and location
     */
    private WebElement findImage(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for image elements
            candidates.addAll(driver.findElements(By.tagName("img")));
            
            // Also look for SVG elements
            candidates.addAll(driver.findElements(By.tagName("svg")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        String alt = e.getAttribute("alt");
                        alt = (alt != null) ? alt.toLowerCase() : "";
                        
                        String title = e.getAttribute("title");
                        title = (title != null) ? title.toLowerCase() : "";
                        
                        String src = e.getAttribute("src");
                        src = (src != null) ? src.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            alt.contains(keyword) || title.contains(keyword) || 
                            src.contains(keyword) || ariaLabel.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding image", e);
            return null;
        }
    }
    
    /**
     * Finds a heading element based on purpose and location
     */
    private WebElement findHeading(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for heading elements h1 through h6
            candidates.addAll(driver.findElements(By.cssSelector("h1, h2, h3, h4, h5, h6")));
            
            // Also look for elements with heading roles
            candidates.addAll(driver.findElements(By.cssSelector("[role='heading']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        String text = e.getText().toLowerCase();
                        
                        return purposeKeywords.stream().anyMatch(text::contains);
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding heading", e);
            return null;
        }
    }
    
    /**
     * Finds the text of a label associated with an element
     */
    private String findAssociatedLabelText(WebDriver driver, WebElement element) {
        try {
            // Check for the id attribute
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                // Look for a label with a matching 'for' attribute
                try {
                    WebElement label = driver.findElement(By.cssSelector("label[for='" + id + "']"));
                    if (label != null) {
                        return label.getText().toLowerCase();
                    }
                } catch (Exception e) {
                    // No label found, continue with other methods
                }
            }
            
            // Look for a parent label element
            try {
                WebElement parent = element.findElement(By.xpath("./ancestor::label"));
                if (parent != null) {
                    String labelText = parent.getText().toLowerCase();
                    // Remove the text of the element itself if it's a text input
                    String elementValue = element.getAttribute("value");
                    if (elementValue != null && !elementValue.isEmpty()) {
                        labelText = labelText.replace(elementValue.toLowerCase(), "").trim();
                    }
                    return labelText;
                }
            } catch (Exception e) {
                // No parent label found, continue with other methods
            }
            
            // Look for a label element immediately preceding the element
            try {
                WebElement previousLabel = element.findElement(By.xpath("./preceding::label[1]"));
                if (previousLabel != null && isNearby(element, previousLabel)) {
                    return previousLabel.getText().toLowerCase();
                }
            } catch (Exception e) {
                // No preceding label found or not nearby
            }
            
            // Look for any text node nearby that might serve as a label
            try {
                List<WebElement> nearbyTexts = driver.findElements(By.xpath(
                    "//*[not(self::script or self::style)][text()[normalize-space()]]"));
                
                for (WebElement textElement : nearbyTexts) {
                    if (isNearby(element, textElement)) {
                        return textElement.getText().toLowerCase();
                    }
                }
            } catch (Exception e) {
                // Error finding nearby text
            }
            
            // If no label found, return empty string
            return "";
        } catch (Exception e) {
            logger.error("Error finding associated label", e);
            return "";
        }
    }
    
    /**
     * Checks if two elements are physically near each other on the page
     */
    private boolean isNearby(WebElement element1, WebElement element2) {
        try {
            // Get the locations of both elements
            org.openqa.selenium.Rectangle rect1 = element1.getRect();
            org.openqa.selenium.Rectangle rect2 = element2.getRect();
            
            // Define a proximity threshold (in pixels)
            int threshold = 150;
            
            // Calculate distances
            int horizontalDistance = Math.min(
                Math.abs(rect1.x - (rect2.x + rect2.width)),
                Math.abs(rect2.x - (rect1.x + rect1.width))
            );
            
            int verticalDistance = Math.min(
                Math.abs(rect1.y - (rect2.y + rect2.height)),
                Math.abs(rect2.y - (rect1.y + rect1.height))
            );
            
            // If distance is negative, the elements overlap
            horizontalDistance = Math.max(0, horizontalDistance);
            verticalDistance = Math.max(0, verticalDistance);
            
            // Elements are nearby if they're close either horizontally or vertically
            return horizontalDistance < threshold || verticalDistance < threshold;
            
        } catch (Exception e) {
            // If we can't determine positions, assume they're not nearby
            return false;
        }
    }
    
    /**
     * Filters a list of elements by their location on the page
     */
    private List<WebElement> filterByLocation(List<WebElement> elements, String location) {
        if (elements.isEmpty() || location.isEmpty()) {
            return elements;
        }
        
        List<WebElement> filtered = new ArrayList<>();
        
        try {
            // Get the dimensions of the viewport
            WebElement html = elements.get(0).findElement(By.tagName("html"));
            Dimension viewportSize = html.getSize();
            int viewportWidth = viewportSize.getWidth();
            int viewportHeight = viewportSize.getHeight();
            
            // Define regions of the page
            int topThreshold = viewportHeight / 3;
            int bottomThreshold = viewportHeight * 2 / 3;
            int leftThreshold = viewportWidth / 3;
            int rightThreshold = viewportWidth * 2 / 3;
            
            for (WebElement element : elements) {
                org.openqa.selenium.Rectangle rect = element.getRect();
                
                // Calculate the center point of the element
                int centerX = rect.x + rect.width / 2;
                int centerY = rect.y + rect.height / 2;
                
                boolean matches = false;
                
                switch (location.toLowerCase()) {
                    case "top":
                        matches = centerY < topThreshold;
                        break;
                    case "bottom":
                        matches = centerY > bottomThreshold;
                        break;
                    case "left":
                        matches = centerX < leftThreshold;
                        break;
                    case "right":
                        matches = centerX > rightThreshold;
                        break;
                    case "center":
                        matches = centerY >= topThreshold && centerY <= bottomThreshold &&
                                  centerX >= leftThreshold && centerX <= rightThreshold;
                        break;
                }
                
                if (matches) {
                    filtered.add(element);
                }
            }
            
            if (!filtered.isEmpty()) {
                return filtered;
            }
            
        } catch (Exception e) {
            logger.error("Error filtering elements by location", e);
        }
        
        // If filtering failed or no elements matched, return the original list
        return elements;
    }
    
    /**
     * Finds an element by keyword matching against all elements on the page
     */
    private WebElement findByKeywords(WebDriver driver, List<String> keywords) {
        if (keywords.isEmpty()) {
            return null;
        }
        
        Map<WebElement, Integer> scores = new HashMap<>();
        
        try {
            // Find all visible elements that might be interactive
            List<WebElement> allElements = driver.findElements(By.cssSelector(
                "button, input, select, textarea, a, [role='button'], [role='link'], " +
                "[role='checkbox'], [role='radio'], [role='menuitem'], [role='tab'], " +
                "[tabindex], [class*='btn'], [class*='button']"));
            
            for (WebElement element : allElements) {
                int score = calculateKeywordMatchScore(element, keywords);
                if (score > 0) {
                    scores.put(element, score);
                }
            }
            
            // Find the element with the highest score
            WebElement bestMatch = null;
            int highestScore = 0;
            
            for (Map.Entry<WebElement, Integer> entry : scores.entrySet()) {
                if (entry.getValue() > highestScore) {
                    highestScore = entry.getValue();
                    bestMatch = entry.getKey();
                }
            }
            
            // Only return if the score is above a minimum threshold
            if (highestScore >= 2) {
                return bestMatch;
            }
            
        } catch (Exception e) {
            logger.error("Error in findByKeywords", e);
        }
        
        return null;
    }
    
    /**
     * Calculates a match score between an element and a list of keywords
     */
    private int calculateKeywordMatchScore(WebElement element, List<String> keywords) {
        int score = 0;
        
        try {
            // Check text content
            String text = element.getText().toLowerCase();
            for (String keyword : keywords) {
                if (text.contains(keyword.toLowerCase())) {
                    score += 3; // Text content is highly relevant
                }
            }
            
            // Check various attributes
            String[] attributes = {"id", "name", "class", "placeholder", "value", 
                                  "title", "aria-label", "alt", "data-testid"};
            
            for (String attribute : attributes) {
                String value = element.getAttribute(attribute);
                if (value != null && !value.isEmpty()) {
                    value = value.toLowerCase();
                    for (String keyword : keywords) {
                        if (value.contains(keyword.toLowerCase())) {
                            score += 2; // Attribute matches are relevant
                        }
                    }
                }
            }
            
            // Check for associated label text
            String labelText = findAssociatedLabelText(element.findElement(By.xpath("ancestor::body[1]")).getWrappedDriver(), element);
            for (String keyword : keywords) {
                if (labelText.contains(keyword.toLowerCase())) {
                    score += 3; // Label matches are highly relevant
                }
            }
            
        } catch (Exception e) {
            // Ignore errors and return current score
        }
        
        return score;
    }
    
    /**
     * Initialize a dictionary of common synonyms for UI terms
     */
    private static Map<String, List<String>> initializeSynonymDictionary() {
        Map<String, List<String>> synonyms = new HashMap<>();
        
        // Button-related terms
        synonyms.put("button", Arrays.asList("btn", "submit", "cancel", "ok", "confirm"));
        synonyms.put("submit", Arrays.asList("save", "confirm", "ok", "apply", "send"));
        synonyms.put("cancel", Arrays.asList("close", "exit", "back", "return"));
        
        // Login-related terms
        synonyms.put("login", Arrays.asList("signin", "sign-in", "log-in", "authenticate"));
        synonyms.put("logout", Arrays.asList("signout", "sign-out", "log-out", "exit"));
        synonyms.put("register", Arrays.asList("signup", "sign-up", "create account", "join"));
        
        // Navigation terms
        synonyms.put("next", Arrays.asList("continue", "forward", "proceed"));
        synonyms.put("previous", Arrays.asList("back", "prev", "return"));
        
        // Form field terms
        synonyms.put("email", Arrays.asList("e-mail", "mail", "email address"));
        synonyms.put("password", Arrays.asList("pwd", "pass", "passphrase"));
        synonyms.put("username", Arrays.asList("user", "login", "userid", "user id"));
        synonyms.put("firstname", Arrays.asList("first name", "given name", "forename"));
        synonyms.put("lastname", Arrays.asList("last name", "surname", "family name"));
        
        // Common action terms
        synonyms.put("search", Arrays.asList("find", "lookup", "query"));
        synonyms.put("add", Arrays.asList("create", "new", "insert", "plus"));
        synonyms.put("remove", Arrays.asList("delete", "erase", "trash", "minus"));
        synonyms.put("edit", Arrays.asList("modify", "change", "update"));
        
        return synonyms;
    }
    
    /**
     * Initialize common button text patterns
     */
    private static List<Pattern> initializeButtonPatterns() {
        List<Pattern> patterns = new ArrayList<>();
        
        // Common button text patterns
        patterns.add(Pattern.compile("(?i)log[ -]?in|sign[ -]?in|authenticate"));
        patterns.add(Pattern.compile("(?i)log[ -]?out|sign[ -]?out"));
        patterns.add(Pattern.compile("(?i)register|sign[ -]?up|create account"));
        patterns.add(Pattern.compile("(?i)submit|save|confirm|ok|apply|send"));
        patterns.add(Pattern.compile("(?i)cancel|close|exit|back|return"));
        patterns.add(Pattern.compile("(?i)search|find|lookup|query"));
        patterns.add(Pattern.compile("(?i)add|create|new|insert"));
        patterns.add(Pattern.compile("(?i)remove|delete|erase|trash"));
        patterns.add(Pattern.compile("(?i)edit|modify|change|update"));
        patterns.add(Pattern.compile("(?i)next|continue|forward|proceed"));
        patterns.add(Pattern.compile("(?i)previous|prev|back|return"));
        
        return patterns;
    }
    
    /**
     * Initialize common form field patterns
     */
    private static List<Pattern> initializeFormFieldPatterns() {
        List<Pattern> patterns = new ArrayList<>();
        
        // Common form field patterns
        patterns.add(Pattern.compile("(?i)email|e-mail|mail"));
        patterns.add(Pattern.compile("(?i)password|pwd|pass"));
        patterns.add(Pattern.compile("(?i)username|user|userid|login"));
        patterns.add(Pattern.compile("(?i)first[ -]?name|given[ -]?name|forename"));
        patterns.add(Pattern.compile("(?i)last[ -]?name|surname|family[ -]?name"));
        patterns.add(Pattern.compile("(?i)address|street|location"));
        patterns.add(Pattern.compile("(?i)city|town"));
        patterns.add(Pattern.compile("(?i)state|province|region"));
        patterns.add(Pattern.compile("(?i)zip|zipcode|postal[ -]?code"));
        patterns.add(Pattern.compile("(?i)country|nation"));
        patterns.add(Pattern.compile("(?i)phone|telephone|mobile"));
        
        return patterns;
    }
});
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding button", e);
            return null;
        }
    }
    
    /**
     * Finds an input field based on purpose and location
     */
    private WebElement findInput(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for input elements of type text, email, password, etc.
            candidates.addAll(driver.findElements(By.cssSelector(
                "input[type='text'], input[type='email'], input[type='password'], " +
                "input[type='search'], input[type='tel'], input[type='url'], " +
                "input[type='number'], input:not([type]), textarea")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                // Create expanded purpose keywords
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Check various attributes that might indicate purpose
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        String placeholder = e.getAttribute("placeholder");
                        placeholder = (placeholder != null) ? placeholder.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        // Check nearby label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            name.contains(keyword) || id.contains(keyword) || 
                            placeholder.contains(keyword) || ariaLabel.contains(keyword) ||
                            labelText.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location


package com.cssmart.framework.healing.impl;

import com.cssmart.framework.healing.HealingContext;
import com.cssmart.framework.healing.HealingResult;
import com.cssmart.framework.healing.HealingStrategy;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.*;

import java.util.*;
import java.util.stream.Collectors;

/**
 * DomHealingStrategy uses structural analysis of the DOM to locate elements
 * based on their relationships, structure, and proximity to other elements.
 */
public class DomHealingStrategy implements HealingStrategy {
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(DomHealingStrategy.class);
    
    // Maximum depth to traverse up the DOM tree
    private static final int MAX_ANCESTOR_DEPTH = 5;
    
    // Maximum number of siblings to consider
    private static final int MAX_SIBLINGS = 10;
    
    @Override
    public HealingResult heal(HealingContext context) {
        logger.info("Attempting DOM healing for element: " + context.getElementName());
        
        WebDriver driver = context.getDriver();
        if (driver == null) {
            return new HealingResult(false, "DOM", "WebDriver is null", null);
        }
        
        Exception originalException = context.getOriginalException();
        if (!(originalException instanceof NoSuchElementException) && 
            !(originalException instanceof StaleElementReferenceException)) {
            // This strategy is primarily for finding elements that don't exist or are stale
            return new HealingResult(false, "DOM", "Original exception is not related to element finding", null);
        }
        
        // Try to extract information from the original exception
        By originalLocator = extractLocatorFromException(originalException);
        if (originalLocator == null) {
            logger.warning("Could not extract original locator from exception");
        }
        
        // Build DOM context from whatever information we have
        DomContext domContext = buildDomContext(driver, originalLocator, context.getElementName());
        
        // If we couldn't build any context, we can't proceed
        if (domContext == null || (domContext.getAncestors().isEmpty() && domContext.getNearbyElements().isEmpty())) {
            return new HealingResult(false, "DOM", "Could not build DOM context", null);
        }
        
        // Try healing strategies in order of reliability
        WebElement element = findElementByAncestorAndPosition(driver, domContext);
        if (element != null) {
            return new HealingResult(true, "DOM", "Element found by ancestor and position", element);
        }
        
        element = findElementBySiblingRelationship(driver, domContext);
        if (element != null) {
            return new HealingResult(true, "DOM", "Element found by sibling relationship", element);
        }
        
        element = findElementByStructuralSimilarity(driver, domContext);
        if (element != null) {
            return new HealingResult(true, "DOM", "Element found by structural similarity", element);
        }
        
        element = findElementByCommonAncestor(driver, domContext);
        if (element != null) {
            return new HealingResult(true, "DOM", "Element found by common ancestor", element);
        }
        
        // All DOM healing approaches failed
        return new HealingResult(false, "DOM", "DOM healing failed to locate the element", null);
    }
    
    /**
     * Extracts the original locator from the exception message if possible
     */
    private By extractLocatorFromException(Exception exception) {
        if (exception == null) {
            return null;
        }
        
        String message = exception.getMessage();
        if (message == null || message.isEmpty()) {
            return null;
        }
        
        try {
            // Common patterns in Selenium exception messages
            if (message.contains("By.id:")) {
                String id = message.substring(message.indexOf("By.id:") + 7).trim();
                id = id.split("\\s+")[0].replace(")", ""); // Extract the ID value
                return By.id(id);
            } else if (message.contains("By.cssSelector:")) {
                String css = message.substring(message.indexOf("By.cssSelector:") + 15).trim();
                css = css.split("\\s+")[0].replace(")", ""); // Extract the CSS value
                return By.cssSelector(css);
            } else if (message.contains("By.xpath:")) {
                String xpath = message.substring(message.indexOf("By.xpath:") + 10).trim();
                xpath = xpath.split("\\)")[0]; // Extract the XPath value
                return By.xpath(xpath);
            } else if (message.contains("By.name:")) {
                String name = message.substring(message.indexOf("By.name:") + 9).trim();
                name = name.split("\\s+")[0].replace(")", ""); // Extract the name value
                return By.name(name);
            }
        } catch (Exception e) {
            logger.error("Error extracting locator from exception", e);
        }
        
        return null;
    }
    
    /**
     * Builds a DOM context based on available information
     */
    private DomContext buildDomContext(WebDriver driver, By originalLocator, String elementName) {
        DomContext context = new DomContext();
        context.setElementName(elementName);
        
        try {
            // If we have the original locator, try to find similar elements
            if (originalLocator != null) {
                try {
                    // For id locators, try finding by partial id
                    if (originalLocator.toString().contains("By.id:")) {
                        String id = originalLocator.toString().split("By.id:\\s*")[1].trim();
                        
                        // If ID contains non-alphanumeric characters, they might be separators
                        String idPattern = "[id*='" + id.replaceAll("[^a-zA-Z0-9]", "") + "']";
                        List<WebElement> elements = driver.findElements(By.cssSelector("*" + idPattern));
                        
                        if (!elements.isEmpty()) {
                            context.addNearbyElements(elements.stream()
                                .limit(MAX_SIBLINGS)
                                .collect(Collectors.toList()));
                            
                            // Try to find ancestors
                            if (!elements.isEmpty()) {
                                List<WebElement> ancestors = findAncestors(elements.get(0), MAX_ANCESTOR_DEPTH);
                                context.setAncestors(ancestors);
                            }
                        }
                    }
                    // For other locator types, try to adapt based on type
                    else {
                        adaptLocatorAndFindContext(driver, originalLocator, context);
                    }
                } catch (Exception e) {
                    logger.debug("Error building context from original locator", e);
                }
            }
            
            // If we still don't have context, try to find elements by name hints
            if (context.getNearbyElements().isEmpty() && elementName != null && !elementName.isEmpty()) {
                // Extract potential identifiers from the element name
                String[] parts = elementName.split("(?<=[a-z])(?=[A-Z])|_");
                
                for (String part : parts) {
                    if (part.length() < 3) continue; // Skip short parts
                    
                    try {
                        // Try to find elements containing this part in various attributes
                        String pattern = "*[id*='" + part.toLowerCase() + "'], " +
                                       "*[name*='" + part.toLowerCase() + "'], " +
                                       "*[class*='" + part.toLowerCase() + "'], " +
                                       "*[data-testid*='" + part.toLowerCase() + "']";
                        
                        List<WebElement> elements = driver.findElements(By.cssSelector(pattern));
                        
                        if (!elements.isEmpty()) {
                            context.addNearbyElements(elements.stream()
                                .limit(MAX_SIBLINGS)
                                .collect(Collectors.toList()));
                            
                            // Once we have some elements, also find their ancestors
                            if (!elements.isEmpty()) {
                                List<WebElement> ancestors = findAncestors(elements.get(0), MAX_ANCESTOR_DEPTH);
                                context.setAncestors(ancestors);
                                break; // We have enough context, stop searching
                            }
                        }
                    } catch (Exception e) {
                        // Continue with next part
                    }
                }
            }
            
            // If we still have no context, get some form elements or interactive elements
            if (context.getNearbyElements().isEmpty()) {
                try {
                    // Find forms and form fields
                    List<WebElement> forms = driver.findElements(By.tagName("form"));
                    for (WebElement form : forms) {
                        try {
                            List<WebElement> fields = form.findElements(
                                By.cssSelector("input, select, textarea, button"));
                            context.addNearbyElements(fields.stream()
                                .limit(MAX_SIBLINGS)
                                .collect(Collectors.toList()));
                            
                            // Add form itself as an ancestor
                            context.addAncestor(form);
                            
                            // Add form's ancestors
                            List<WebElement> ancestors = findAncestors(form, MAX_ANCESTOR_DEPTH - 1);
                            context.addAncestors(ancestors);
                        } catch (Exception e) {
                            // Continue with next form
                        }
                    }
                } catch (Exception e) {
                    logger.debug("Error finding form elements", e);
                }
            }
            
            // If still empty, find common interactive elements
            if (context.getNearbyElements().isEmpty()) {
                try {
                    List<WebElement> interactiveElements = driver.findElements(
                        By.cssSelector("button, a, input, select, [role='button'], [role='link']"));
                    
                    context.addNearbyElements(interactiveElements.stream()
                        .limit(MAX_SIBLINGS)
                        .collect(Collectors.toList()));
                } catch (Exception e) {
                    logger.debug("Error finding interactive elements", e);
                }
            }
            
            return context;
            
        } catch (Exception e) {
            logger.error("Error building DOM context", e);
            return null;
        }
    }
    
    /**
     * Adapts the original locator to find similar elements for context
     */
    private void adaptLocatorAndFindContext(WebDriver driver, By originalLocator, DomContext context) {
        String locatorString = originalLocator.toString();
        
        try {
            if (locatorString.contains("By.cssSelector:")) {
                String css = locatorString.split("By.cssSelector:\\s*")[1].trim();
                
                // Simplify CSS selector to find similar elements
                String simplifiedCss = simplifySelector(css);
                if (!simplifiedCss.isEmpty()) {
                    List<WebElement> elements = driver.findElements(By.cssSelector(simplifiedCss));
                    context.addNearbyElements(elements.stream()
                        .limit(MAX_SIBLINGS)
                        .collect(Collectors.toList()));
                    
                    // Find ancestors of the first element
                    if (!elements.isEmpty()) {
                        List<WebElement> ancestors = findAncestors(elements.get(0), MAX_ANCESTOR_DEPTH);
                        context.setAncestors(ancestors);
                    }
                }
            } else if (locatorString.contains("By.xpath:")) {
                String xpath = locatorString.split("By.xpath:\\s*")[1].trim();
                
                // Simplify XPath to find similar elements
                String simplifiedXpath = simplifyXPath(xpath);
                if (!simplifiedXpath.isEmpty()) {
                    List<WebElement> elements = driver.findElements(By.xpath(simplifiedXpath));
                    context.addNearbyElements(elements.stream()
                        .limit(MAX_SIBLINGS)
                        .collect(Collectors.toList()));
                    
                    // Find ancestors of the first element
                    if (!elements.isEmpty()) {
                        List<WebElement> ancestors = findAncestors(elements.get(0), MAX_ANCESTOR_DEPTH);
                        context.setAncestors(ancestors);
                    }
                }
            } else if (locatorString.contains("By.name:")) {
                String name = locatorString.split("By.name:\\s*")[1].trim();
                
                // Try elements with similar names
                String pattern = "[name*='" + name + "']";
                List<WebElement> elements = driver.findElements(By.cssSelector(pattern));
                context.addNearbyElements(elements.stream()
                    .limit(MAX_SIBLINGS)
                    .collect(Collectors.toList()));
                
                // Find ancestors of the first element
                if (!elements.isEmpty()) {
                    List<WebElement> ancestors = findAncestors(elements.get(0), MAX_ANCESTOR_DEPTH);
                    context.setAncestors(ancestors);
                }
            }
        } catch (Exception e) {
            logger.debug("Error adapting locator: " + locatorString, e);
        }
    }
    
    /**
     * Simplifies a CSS selector to match more elements
     */
    private String simplifySelector(String selector) {
        try {
            // Remove specific attribute values
            selector = selector.replaceAll("\\[([^=]+)=[^\\]]+\\]", "[$1]");
            
            // Remove ID selectors which are too specific
            selector = selector.replaceAll("#[^ .>+~]+", "");
            
            // Keep only the tag name and general class information
            if (selector.contains(".")) {
                String[] parts = selector.split("\\.");
                String tagPart = parts[0].trim();
                
                // Take only the tag name and the first class
                if (!tagPart.isEmpty()) {
                    if (parts.length > 1) {
                        String firstClass = parts[1].split("[ .:>+~\\[]")[0];
                        return tagPart + "." + firstClass;
                    }
                    return tagPart;
                }
                
                // If no tag name, use just the first class
                if (parts.length > 1) {
                    String firstClass = parts[1].split("[ .:>+~\\[]")[0];
                    return "*." + firstClass;
                }
            }
            
            // If it's a complex selector, just take the last part
            if (selector.contains(" ")) {
                String[] parts = selector.split("\\s+");
                return parts[parts.length - 1];
            }
            
            // If it's a simple tag selector, return it
            if (selector.matches("^[a-zA-Z][a-zA-Z0-9]*$")) {
                return selector;
            }
            
            return selector;
            
        } catch (Exception e) {
            logger.debug("Error simplifying CSS selector", e);
            return "";
        }
    }
    
    /**
     * Simplifies an XPath to match more elements
     */
    private String simplifyXPath(String xpath) {
        try {
            // If it's a specific ID search, generalize it
            if (xpath.contains("@id=")) {
                // Extract the tag name if present
                String tagName = "*";
                if (xpath.matches("//([a-zA-Z][a-zA-Z0-9]*)\\[.*")) {
                    tagName = xpath.replaceAll("//([a-zA-Z][a-zA-Z0-9]*)\\[.*", "$1");
                }
                
                // Get the ID value
                String idValue = xpath.replaceAll(".*@id=['\"]([^'\"]+)['\"].*", "$1");
                
                // Construct a contains expression instead of exact match
                return "//" + tagName + "[contains(@id, '" + idValue + "')]";
            }
            
            // If it's an exact text match, make it a contains
            if (xpath.contains("text()=")) {
                String textValue = xpath.replaceAll(".*text\\(\\)=['\"]([^'\"]+)['\"].*", "$1");
                // Extract tag name
                String tagName = "*";
                if (xpath.matches("//([a-zA-Z][a-zA-Z0-9]*)\\[.*")) {
                    tagName = xpath.replaceAll("//([a-zA-Z][a-zA-Z0-9]*)\\[.*", "$1");
                }
                return "//" + tagName + "[contains(text(), '" + textValue + "')]";
            }
            
            // If it's a position-based selector, remove the position constraint
            if (xpath.contains("position()")) {
                return xpath.replaceAll("\\[position\\(\\)[^\\]]+\\]", "");
            }
            
            // If it's a complex path, take just the last step
            if (xpath.contains("/")) {
                String[] steps = xpath.split("/+");
                String lastStep = steps[steps.length - 1];
                if (!lastStep.isEmpty()) {
                    return "//" + lastStep;
                }
            }
            
            return xpath;
            
        } catch (Exception e) {
            logger.debug("Error simplifying XPath", e);
            return "";
        }
    }
    
    /**
     * Finds ancestors of an element up to a specified depth
     */
    private List<WebElement> findAncestors(WebElement element, int maxDepth) {
        List<WebElement> ancestors = new ArrayList<>();
        
        try {
            WebElement current = element;
            for (int i = 0; i < maxDepth; i++) {
                WebElement parent = current.findElement(By.xpath(".."));
                if (parent == null || parent.equals(current)) {
                    break; // Reached the top or couldn't find parent
                }
                
                ancestors.add(parent);
                current = parent;
            }
        } catch (Exception e) {
            logger.debug("Error finding ancestors", e);
        }
        
        return ancestors;
    }
    
    /**
     * Finds an element by looking at the same position relative to an ancestor
     */
    private WebElement findElementByAncestorAndPosition(WebDriver driver, DomContext context) {
        List<WebElement> ancestors = context.getAncestors();
        if (ancestors.isEmpty()) {
            return null;
        }
        
        try {
            // Try with each ancestor, starting from the closest one
            for (WebElement ancestor : ancestors) {
                // Get the XPath of the ancestor
                String ancestorXPath = buildXPathForElement(ancestor);
                if (ancestorXPath.isEmpty()) {
                    continue;
                }
                
                // If we have nearby elements, try to find the position pattern
                List<WebElement> nearbyElements = context.getNearbyElements();
                if (!nearbyElements.isEmpty()) {
                    for (int i = 0; i < nearbyElements.size(); i++) {
                        WebElement nearby = nearbyElements.get(i);
                        
                        // Find this element's position relative to the ancestor
                        int[] positionPattern = findPositionPattern(ancestor, nearby);
                        if (positionPattern != null) {
                            // Try to find an element at the same position relative to our ancestor
                            String xpathWithPosition = buildXPathWithPosition(ancestorXPath, positionPattern);
                            try {
                                List<WebElement> candidates = driver.findElements(By.xpath(xpathWithPosition));
                                if (!candidates.isEmpty()) {
                                    // Return the first match
                                    return candidates.get(0);
                                }
                            } catch (Exception e) {
                                // Invalid XPath, continue with next pattern
                            }
                        }
                    }
                }
                
                // If we couldn't find by position pattern, try common child positions
                int[] commonPositions = {1, 2, 3, 4, 5}; // First few children
                for (int pos : commonPositions) {
                    String xpath = ancestorXPath + "/*[" + pos + "]";
                    try {
                        List<WebElement> candidates = driver.findElements(By.xpath(xpath));
                        if (!candidates.isEmpty()) {
                            return candidates.get(0);
                        }
                    } catch (Exception e) {
                        // Continue with next position
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error in findElementByAncestorAndPosition", e);
        }
        
        return null;
    }
    
    /**
     * Finds the position pattern of an element relative to its ancestor
     */
    private int[] findPositionPattern(WebElement ancestor, WebElement element) {
        try {
            // Build XPath to check hierarchy
            String script =
                "function getPathSegments(element, ancestor) {" +
                "  const path = [];" +
                "  let current = element;" +
                "  while (current && current !== ancestor) {" +
                "    let index = 0;" +
                "    let sibling = current;" +
                "    while (sibling) {" +
                "      if (sibling.tagName === current.tagName) index++;" +
                "      sibling = sibling.previousElementSibling;" +
                "    }" +
                "    path.unshift({tag: current.tagName.toLowerCase(), index: index});" +
                "    current = current.parentElement;" +
                "  }" +
                "  return current === ancestor ? path : null;" +
                "};" +
                "return getPathSegments(arguments[0], arguments[1]);";
            
            JavascriptExecutor js = (JavascriptExecutor) ancestor.getWrappedDriver();
            Object result = js.executeScript(script, element, ancestor);
            
            if (result == null) {
                return null; // Element is not a descendant of ancestor
            }
            
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> segments = (List<Map<String, Object>>) result;
            
            if (segments.isEmpty()) {
                return null;
            }
            
            // Convert to a simpler int array of indices
            int[] pattern = new int[segments.size()];
            for (int i = 0; i < segments.size(); i++) {
                pattern[i] = ((Long) segments.get(i).get("index")).intValue();
            }
            
            return pattern;
            
        } catch (Exception e) {
            logger.debug("Error finding position pattern", e);
            return null;
        }
    }
    
    /**
     * Builds an XPath including position information
     */
    private String buildXPathWithPosition(String ancestorXPath, int[] positionPattern) {
        StringBuilder xpath = new StringBuilder(ancestorXPath);
        
        for (int i = 0; i < positionPattern.length; i++) {
            // For each level, use tag index
            xpath.append("/*[").append(positionPattern[i]).append("]");
        }
        
        return xpath.toString();
    }
    
    /**
     * Builds an XPath for a given element
     */
    private String buildXPathForElement(WebElement element) {
        try {
            // Try to build an XPath with ID if available
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                return "//*[@id='" + id + "']";
            }
            
            // Try with a name attribute
            String name = element.getAttribute("name");
            if (name != null && !name.isEmpty()) {
                return "//*[@name='" + name + "']";
            }
            
            // Try with a unique class combination
            String className = element.getAttribute("class");
            if (className != null && !className.isEmpty()) {
                // Use the first class which tends to be most specific
                String[] classes = className.split("\\s+");
                if (classes.length > 0 && !classes[0].isEmpty()) {
                    return "//*[contains(@class, '" + classes[0] + "')]";
                }
            }
            
            // Default to a generic XPath based on tag name
            return "//" + element.getTagName().toLowerCase();
            
        } catch (Exception e) {
            logger.debug("Error building XPath for element", e);
            return "";
        }
    }
    
    /**
     * Finds an element by looking at its relationship to siblings
     */
    private WebElement findElementBySiblingRelationship(WebDriver driver, DomContext context) {
        List<WebElement> nearbyElements = context.getNearbyElements();
        if (nearbyElements.isEmpty()) {
            return null;
        }
        
        try {
            // Try common sibling relationships
            for (WebElement nearby : nearbyElements) {
                // Build XPath for the nearby element
                String nearbyXPath = buildXPathForElement(nearby);
                if (nearbyXPath.isEmpty()) {
                    continue;
                }
                
                // Try common relationships
                String[] relationships = {
                    "following-sibling::*[1]", // Next sibling
                    "preceding-sibling::*[1]", // Previous sibling
                    "following-sibling::input[1]", // Next input
                    "preceding-sibling::input[1]", // Previous input
                    "following-sibling::button[1]", // Next button
                    "preceding-sibling::button[1]", // Previous button
                    "following-sibling::select[1]", // Next select
                    "preceding-sibling::select[1]", // Previous select
                    "following-sibling::a[1]", // Next link
                    "preceding-sibling::a[1]", // Previous link
                    "following-sibling::label[1]/following-sibling::*[1]", // Element after a label
                    "preceding-sibling::label[1]/preceding-sibling::*[1]", // Element before a label
                };
                
                for (String relationship : relationships) {
                    String xpath = nearbyXPath + "/" + relationship;
                    try {
                        List<WebElement> candidates = driver.findElements(By.xpath(xpath));
                        if (!candidates.isEmpty()) {
                            // Found an element with this relationship
                            return candidates.get(0);
                        }
                    } catch (Exception e) {
                        // Invalid XPath, try next relationship
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error in findElementBySiblingRelationship", e);
        }
        
        return null;
    }
    
    /**
     * Finds an element by looking for structurally similar elements
     */
    private WebElement findElementByStructuralSimilarity(WebDriver driver, DomContext context) {
        List<WebElement> nearbyElements = context.getNearbyElements();
        if (nearbyElements.isEmpty()) {
            return null;
        }
        
        try {
            // First, identify common attributes among nearby elements
            Map<String, Integer> attributeFrequency = new HashMap<>();
            for (WebElement nearby : nearbyElements) {
                // Extract attributes
                Map<String, String> attributes = extractAttributes(nearby);
                for (String attrName : attributes.keySet()) {
                    attributeFrequency.put(attrName, 
                        attributeFrequency.getOrDefault(attrName, 0) + 1);
                }
            }
            
            // Find attributes that appear frequently
            List<String> commonAttributes = attributeFrequency.entrySet().stream()
                .filter(e -> e.getValue() > 1) // Must appear at least twice
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
            
            if (commonAttributes.isEmpty()) {
                return null;
            }
            
            // For each common attribute, build patterns
            for (String attribute : commonAttributes) {
                List<String> patterns = new ArrayList<>();
                
                for (WebElement nearby : nearbyElements) {
                    String value = nearby.getAttribute(attribute);
                    if (value != null && !value.isEmpty()) {
                        // Extract pattern (e.g., prefix or suffix)
                        List<String> extractedPatterns = extractPatterns(value);
                        patterns.addAll(extractedPatterns);
                    }
                }
                
                // Try each pattern
                for (String pattern : patterns) {
                    if (pattern.isEmpty()) continue;
                    
                    String xpath = "//*[contains(@" + attribute + ", '" + pattern + "')]";
                    try {
                        List<WebElement> candidates = driver.findElements(By.xpath(xpath));
                        // Filter out elements we already have in our nearby list
                        candidates = candidates.stream()
                            .filter(e -> !nearbyElements.contains(e))
                            .collect(Collectors.toList());
                        
                        if (!candidates.isEmpty()) {
                            return candidates.get(0);
                        }
                    } catch (Exception e) {
                        // Continue with next pattern
                    }
                }
            }
            
            // If no luck with attributes, try tag patterns
            Map<String, Integer> tagFrequency = new HashMap<>();
            for (WebElement nearby : nearbyElements) {
                String tag = nearby.getTagName().toLowerCase();
                tagFrequency.put(tag, tagFrequency.getOrDefault(tag, 0) + 1);
            }
            
            // Find tags that appear frequently
            List<String> commonTags = tagFrequency.entrySet().stream()
                .filter(e -> e.getValue() > 1) // Must appear at least twice
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
            
            // Look for elements with similar structure for each common tag
            for (String tag : commonTags) {
                // Find a container that has these tags
                for (WebElement ancestor : context.getAncestors()) {
                    // Find all elements of this tag under the ancestor
                    String xpath = ".//" + tag;
                    try {
                        List<WebElement> sameTagElements = ancestor.findElements(By.xpath(xpath));
                        // Filter out elements we already have in our nearby list
                        sameTagElements = sameTagElements.stream()
                            .filter(e -> !nearbyElements.contains(e))
                            .collect(Collectors.toList());
                        
                        if (!sameTagElements.isEmpty()) {
                            return sameTagElements.get(0);
                        }
                    } catch (Exception e) {
                        // Continue with next ancestor
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error in findElementByStructuralSimilarity", e);
        }
        
        return null;
    }
    
    /**
     * Extracts attributes from an element
     */
    private Map<String, String> extractAttributes(WebElement element) {
        Map<String, String> attributes = new HashMap<>();
        String[] commonAttributes = {
            "id", "name", "class", "type", "value", "href", "src", "alt", 
            "title", "placeholder", "for", "role", "aria-label"
        };
        
        for (String attr : commonAttributes) {
            try {
                String value = element.getAttribute(attr);
                if (value != null && !value.isEmpty()) {
                    attributes.put(attr, value);
                }
            } catch (Exception e) {
                // Ignore errors for specific attributes
            }
        }
        
        return attributes;
    }
    
    /**
     * Extracts patterns from an attribute value
     */
    private List<String> extractPatterns(String value) {
        List<String> patterns = new ArrayList<>();
        
        // Add the full value
        patterns.add(value);
        
        // Extract prefix (e.g., btn-primary, btn-secondary -> "btn-")
        if (value.contains("-")) {
            String prefix = value.split("-")[0] + "-";
            patterns.add(prefix);
        }
        
        // Extract prefix by camel case (e.g., formSubmit, formCancel -> "form")
        if (value.matches(".*[a-z][A-Z].*")) {
            String[] parts = value.split("(?<=[a-z])(?=[A-Z])");
            if (parts.length > 0) {
                patterns.add(parts[0]);
            }
        }
        
        // Extract suffix (e.g., user-name, user-email -> "-name", "-email")
        if (value.contains("-")) {
            String[] parts = value.split("-");
            if (parts.length > 1) {
                patterns.add("-" + parts[parts.length - 1]);
            }
        }
        
        return patterns;
    }
    
    /**
     * Finds an element by looking at the common ancestor and its children
     */
    private WebElement findElementByCommonAncestor(WebDriver driver, DomContext context) {
        List<WebElement> ancestors = context.getAncestors();
        if (ancestors.isEmpty()) {
            return null;
        }
        
        try {
            // Try with each ancestor
            for (WebElement ancestor : ancestors) {
                // Try common element types within this ancestor
                String[] elementTypes = {
                    "input", "button", "select", "textarea", "a", 
                    "div[class*='btn']", "div[class*='button']",
                    "[role='button']", "[role='textbox']", "[role='combobox']"
                };
                
                for (String type : elementTypes) {
                    String xpath = ".//" + type;
                    try {
                        List<WebElement> candidates = ancestor.findElements(By.xpath(xpath));
                        // Filter out elements we already have in our context
                        candidates = candidates.stream()
                            .filter(e -> !context.getNearbyElements().contains(e))
                            .collect(Collectors.toList());
                        
                        if (!candidates.isEmpty()) {
                            return candidates.get(0);
                        }
                    } catch (Exception e) {
                        // Continue with next type
                    }
                }
                
                // If the ancestor has a small number of children, try them all
                try {
                    List<WebElement> children = ancestor.findElements(By.xpath("./*"));
                    if (children.size() > 0 && children.size() <= 5) {
                        // Filter out elements we already have in our context
                        children = children.stream()
                            .filter(e -> !context.getNearbyElements().contains(e))
                            .collect(Collectors.toList());
                        
                        if (!children.isEmpty()) {
                            return children.get(0);
                        }
                    }
                } catch (Exception e) {
                    // Continue with next ancestor
                }
            }
        } catch (Exception e) {
            logger.error("Error in findElementByCommonAncestor", e);
        }
        
        return null;
    }
    
    /**
     * DomContext class to store information about the DOM structure
     */
    private static class DomContext {
        private String elementName;
        private List<WebElement> ancestors = new ArrayList<>();
        private List<WebElement> nearbyElements = new ArrayList<>();
        
        public String getElementName() {
            return elementName;
        }
        
        public void setElementName(String elementName) {
            this.elementName = elementName;
        }
        
        public List<WebElement> getNearbyElements() {
            return nearbyElements;
        }
        
        public void setNearbyElements(List<WebElement> nearbyElements) {
            this.nearbyElements = nearbyElements;
        }
        
        public void addNearbyElement(WebElement element) {
            if (element != null) {
                this.nearbyElements.add(element);
            }
        }
        
        public void addNearbyElements(List<WebElement> elements) {
            if (elements != null) {
                this.nearbyElements.addAll(elements);
            }
        }
    }
}<WebElement> getAncestors() {
            return ancestors;
        }
        
        public void setAncestors(List<WebElement> ancestors) {
            this.ancestors = ancestors;
        }
        
        public void addAncestor(WebElement ancestor) {
            if (ancestor != null) {
                this.ancestors.add(ancestor);
            }
        }
        
        public void addAncestors(List<WebElement> ancestors) {
            if (ancestors != null) {
                this.ancestors.addAll(ancestors);
            }
        }
        
        public List


package com.cssmart.framework.healing.impl;

import com.cssmart.framework.healing.HealingContext;
import com.cssmart.framework.healing.HealingResult;
import com.cssmart.framework.healing.HealingStrategy;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.*;

import java.util.*;
import java.util.stream.Collectors;

/**
 * VisualHealingStrategy focuses on the visual properties and visual positioning
 * of elements to locate them when other strategies fail.
 */
public class VisualHealingStrategy implements HealingStrategy {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(VisualHealingStrategy.class);
    
    // Threshold for matching visual properties (0.0 - 1.0)
    private static final double VISUAL_SIMILARITY_THRESHOLD = 0.7;
    
    // Maximum candidates to process for detailed visual comparison
    private static final int MAX_CANDIDATES = 10;
    
    @Override
    public HealingResult heal(HealingContext context) {
        logger.info("Attempting visual healing for element: " + context.getElementName());
        
        WebDriver driver = context.getDriver();
        if (driver == null) {
            return new HealingResult(false, "VISUAL", "WebDriver is null", null);
        }
        
        // This strategy requires JavaScript execution
        if (!(driver instanceof JavascriptExecutor)) {
            return new HealingResult(false, "VISUAL", 
                "Driver does not support JavaScript execution", null);
        }
        
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        try {
            // Get viewport size for relative positioning calculations
            Dimension viewportSize = getViewportSize(js);
            
            // Find all visible, interactive elements on the page
            List<WebElement> candidates = findVisibleInteractiveElements(driver);
            
            // Extract visual properties of each candidate
            Map<WebElement, VisualProperties> visualPropertiesMap = 
                extractVisualProperties(js, candidates, viewportSize);
            
            // Limit candidates for detailed analysis
            if (candidates.size() > MAX_CANDIDATES) {
                candidates = candidates.subList(0, MAX_CANDIDATES);
            }
            
            // Try to find a matching element based on spatial relationships
            WebElement matchingElement = findMatchingElementByVisualProperties(
                driver, visualPropertiesMap);
            
            if (matchingElement != null) {
                return new HealingResult(true, "VISUAL", 
                    "Element found based on visual properties", matchingElement);
            }
            
            // If we couldn't find a match, try candidates in common regions
            matchingElement = findElementInCommonRegions(driver, visualPropertiesMap);
            
            if (matchingElement != null) {
                return new HealingResult(true, "VISUAL", 
                    "Element found in common region", matchingElement);
            }
            
            // Try proximity-based search
            matchingElement = findElementByProximity(driver, visualPropertiesMap);
            
            if (matchingElement != null) {
                return new HealingResult(true, "VISUAL", 
                    "Element found by proximity", matchingElement);
            }
            
            // All visual approaches failed
            return new HealingResult(false, "VISUAL", 
                "Visual healing failed to locate the element", null);
            
        } catch (Exception e) {
            logger.error("Error in visual healing strategy", e);
            return new HealingResult(false, "VISUAL", 
                "Error in visual healing: " + e.getMessage(), null);
        }
    }
    
    /**
     * Gets the viewport size using JavaScript
     */
    private Dimension getViewportSize(JavascriptExecutor js) {
        try {
            Long width = (Long) js.executeScript("return window.innerWidth");
            Long height = (Long) js.executeScript("return window.innerHeight");
            return new Dimension(width.intValue(), height.intValue());
        } catch (Exception e) {
            logger.error("Error getting viewport size", e);
            return new Dimension(1024, 768); // Default fallback
        }
    }
    
    /**
     * Finds all visible, interactive elements on the page
     */
    private List<WebElement> findVisibleInteractiveElements(WebDriver driver) {
        List<WebElement> elements = new ArrayList<>();
        
        try {
            // Find all potentially interactive elements
            List<WebElement> candidates = driver.findElements(By.cssSelector(
                "button, input, select, textarea, a, [role='button'], [role='link'], " +
                "[role='checkbox'], [role='radio'], [role='tab'], [role='menuitem'], " +
                "[tabindex], [class*='btn'], [class*='button'], [onclick]"));
            
            // Filter to visible elements only
            elements = candidates.stream()
                .filter(this::isElementVisible)
                .collect(Collectors.toList());
        } catch (Exception e) {
            logger.error("Error finding visible interactive elements", e);
        }
        
        return elements;
    }
    
    /**
     * Checks if an element is visible and has a size
     */
    private boolean isElementVisible(WebElement element) {
        try {
            return element.isDisplayed() && 
                   element.getSize().getWidth() > 0 && 
                   element.getSize().getHeight() > 0;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Extracts visual properties of elements using JavaScript
     */
    private Map<WebElement, VisualProperties> extractVisualProperties(
            JavascriptExecutor js, List<WebElement> elements, Dimension viewportSize) {
        
        Map<WebElement, VisualProperties> result = new HashMap<>();
        
        for (WebElement element : elements) {
            try {
                VisualProperties properties = new VisualProperties();
                
                // Get element dimensions and position
                Rectangle rect = element.getRect();
                properties.setX(rect.getX());
                properties.setY(rect.getY());
                properties.setWidth(rect.getWidth());
                properties.setHeight(rect.getHeight());
                
                // Calculate relative position in viewport
                properties.setRelativeX((double) rect.getX() / viewportSize.getWidth());
                properties.setRelativeY((double) rect.getY() / viewportSize.getHeight());
                
                // Get visual properties using JavaScript
                Map<String, String> visualStyles = getComputedStyles(js, element);
                properties.setBackgroundColor(visualStyles.get("backgroundColor"));
                properties.setColor(visualStyles.get("color"));
                properties.setBorderColor(visualStyles.get("borderColor"));
                properties.setFontSize(visualStyles.get("fontSize"));
                properties.setBorderRadius(visualStyles.get("borderRadius"));
                
                // Get text content
                properties.setTextContent(element.getText());
                
                // Get element tag
                properties.setTagName(element.getTagName().toLowerCase());
                
                result.put(element, properties);
            } catch (Exception e) {
                logger.debug("Error extracting visual properties for element", e);
                // Continue with next element
            }
        }
        
        return result;
    }
    
    /**
     * Gets computed CSS styles for an element using JavaScript
     */
    private Map<String, String> getComputedStyles(JavascriptExecutor js, WebElement element) {
        Map<String, String> styles = new HashMap<>();
        
        try {
            String script = 
                "var style = window.getComputedStyle(arguments[0]);" +
                "return {" +
                "  backgroundColor: style.backgroundColor," +
                "  color: style.color," +
                "  borderColor: style.borderColor," +
                "  fontSize: style.fontSize," +
                "  borderRadius: style.borderRadius," +
                "  display: style.display," +
                "  visibility: style.visibility," +
                "  opacity: style.opacity" +
                "};";
            
            @SuppressWarnings("unchecked")
            Map<String, String> computedStyles = (Map<String, String>) js.executeScript(script, element);
            
            if (computedStyles != null) {
                styles.putAll(computedStyles);
            }
        } catch (Exception e) {
            logger.debug("Error getting computed styles", e);
        }
        
        return styles;
    }
    
    /**
     * Finds matching element based on visual properties
     */
    private WebElement findMatchingElementByVisualProperties(
            WebDriver driver, Map<WebElement, VisualProperties> propertiesMap) {
        
        if (propertiesMap.isEmpty()) {
            return null;
        }
        
        // Find clusters of similar elements
        List<List<WebElement>> visualClusters = clusterElementsByVisualSimilarity(propertiesMap);
        
        // For each cluster, try to find potential missing elements
        for (List<WebElement> cluster : visualClusters) {
            if (cluster.size() < 2) {
                continue; // Need at least 2 elements to detect patterns
            }
            
            // Analyze visual pattern in this cluster
            WebElement missingElement = findMissingElementInPattern(driver, cluster, propertiesMap);
            
            if (missingElement != null) {
                return missingElement;
            }
        }
        
        return null;
    }
    
    /**
     * Clusters elements by visual similarity
     */
    private List<List<WebElement>> clusterElementsByVisualSimilarity(
            Map<WebElement, VisualProperties> propertiesMap) {
        
        List<List<WebElement>> clusters = new ArrayList<>();
        Set<WebElement> processedElements = new HashSet<>();
        
        for (Map.Entry<WebElement, VisualProperties> entry : propertiesMap.entrySet()) {
            WebElement element = entry.getKey();
            
            if (processedElements.contains(element)) {
                continue;
            }
            
            // Start a new cluster with this element
            List<WebElement> cluster = new ArrayList<>();
            cluster.add(element);
            processedElements.add(element);
            
            VisualProperties properties = entry.getValue();
            
            // Find visually similar elements
            for (Map.Entry<WebElement, VisualProperties> otherEntry : propertiesMap.entrySet()) {
                WebElement otherElement = otherEntry.getKey();
                
                if (otherElement.equals(element) || processedElements.contains(otherElement)) {
                    continue;
                }
                
                VisualProperties otherProperties = otherEntry.getValue();
                
                // Calculate visual similarity
                double similarity = calculateVisualSimilarity(properties, otherProperties);
                
                if (similarity >= VISUAL_SIMILARITY_THRESHOLD) {
                    cluster.add(otherElement);
                    processedElements.add(otherElement);
                }
            }
            
            if (!cluster.isEmpty()) {
                clusters.add(cluster);
            }
        }
        
        return clusters;
    }
    
    /**
     * Calculates visual similarity between two elements (0.0 - 1.0)
     */
    private double calculateVisualSimilarity(VisualProperties props1, VisualProperties props2) {
        double score = 0.0;
        double maxScore = 0.0;
        
        // Compare tag names (highest weight)
        if (props1.getTagName() != null && props1.getTagName().equals(props2.getTagName())) {
            score += 0.3;
        }
        maxScore += 0.3;
        
        // Compare dimensions (medium weight)
        double widthDiff = Math.abs(props1.getWidth() - props2.getWidth());
        double heightDiff = Math.abs(props1.getHeight() - props2.getHeight());
        
        if (widthDiff <= 2 && heightDiff <= 2) {
            score += 0.2; // Exact size match
        } else if (widthDiff <= 10 && heightDiff <= 10) {
            score += 0.15; // Close size match
        } else if (widthDiff <= 20 && heightDiff <= 20) {
            score += 0.1; // Similar size
        }
        maxScore += 0.2;
        
        // Compare colors (medium weight)
        if (props1.getBackgroundColor() != null && 
            props1.getBackgroundColor().equals(props2.getBackgroundColor())) {
            score += 0.15;
        }
        maxScore += 0.15;
        
        if (props1.getColor() != null && props1.getColor().equals(props2.getColor())) {
            score += 0.15;
        }
        maxScore += 0.15;
        
        // Compare border radius (lower weight)
        if (props1.getBorderRadius() != null && props1.getBorderRadius().equals(props2.getBorderRadius())) {
            score += 0.05;
        }
        maxScore += 0.05;
        
        // Compare font size (lower weight)
        if (props1.getFontSize() != null && props1.getFontSize().equals(props2.getFontSize())) {
            score += 0.05;
        }
        maxScore += 0.05;
        
        // Text length similarity (lower weight)
        String text1 = props1.getTextContent();
        String text2 = props2.getTextContent();
        
        if (text1 != null && text2 != null) {
            if (text1.equals(text2)) {
                score += 0.1;
            } else if (Math.abs(text1.length() - text2.length()) <= 5) {
                score += 0.05;
            }
        }
        maxScore += 0.1;
        
        return maxScore > 0 ? score / maxScore : 0;
    }
    
    /**
     * Finds a potentially missing element in a visual pattern
     */
    private WebElement findMissingElementInPattern(
            WebDriver driver, List<WebElement> cluster, Map<WebElement, VisualProperties> propertiesMap) {
        
        try {
            // Sort elements by Y position, then X position to understand layout
            cluster.sort(Comparator
                .comparing((WebElement e) -> propertiesMap.get(e).getY())
                .thenComparing(e -> propertiesMap.get(e).getX()));
            
            // Check for grid pattern
            WebElement missingElement = findMissingElementInGrid(driver, cluster, propertiesMap);
            if (missingElement != null) {
                return missingElement;
            }
            
            // Check for list pattern
            missingElement = findMissingElementInList(driver, cluster, propertiesMap);
            if (missingElement != null) {
                return missingElement;
            }
            
            // Check for form pattern
            missingElement = findMissingElementInForm(driver, cluster, propertiesMap);
            if (missingElement != null) {
                return missingElement;
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding missing element in pattern", e);
            return null;
        }
    }
    
    /**
     * Finds missing element in a grid layout pattern
     */
    private WebElement findMissingElementInGrid(
            WebDriver driver, List<WebElement> elements, Map<WebElement, VisualProperties> propertiesMap) {
        
        try {
            // Group elements by Y coordinate (rows)
            Map<Integer, List<WebElement>> rows = new HashMap<>();
            
            for (WebElement element : elements) {
                VisualProperties props = propertiesMap.get(element);
                int yCoord = props.getY();
                
                // Group elements with similar Y coordinates (within 5 pixels)
                int rowKey = -1;
                for (Integer existingY : rows.keySet()) {
                    if (Math.abs(existingY - yCoord) <= 5) {
                        rowKey = existingY;
                        break;
                    }
                }
                
                if (rowKey == -1) {
                    rowKey = yCoord;
                }
                
                rows.computeIfAbsent(rowKey, k -> new ArrayList<>()).add(element);
            }
            
            // Check if we have a grid (multiple rows with similar elements)
            if (rows.size() < 2) {
                return null; // Not a grid
            }
            
            // Sort rows by Y coordinate
            List<Integer> sortedYCoords = new ArrayList<>(rows.keySet());
            Collections.sort(sortedYCoords);
            
            // Find the most common number of elements per row
            Map<Integer, Integer> elementsPerRowFrequency = new HashMap<>();
            int mostCommonElementCount = -1;
            int highestFrequency = 0;
            
            for (Integer y : sortedYCoords) {
                int count = rows.get(y).size();
                int frequency = elementsPerRowFrequency.getOrDefault(count, 0) + 1;
                elementsPerRowFrequency.put(count, frequency);
                
                if (frequency > highestFrequency) {
                    highestFrequency = frequency;
                    mostCommonElementCount = count;
                }
            }
            
            // Look for rows with fewer elements than the most common count
            for (Integer y : sortedYCoords) {
                List<WebElement> row = rows.get(y);
                if (row.size() < mostCommonElementCount) {
                    // This row is missing elements
                    WebElement missingElement = findMissingElementInRow(driver, row, mostCommonElementCount,
                        rows, sortedYCoords, propertiesMap);
                    
                    if (missingElement != null) {
                        return missingElement;
                    }
                }
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding missing element in grid", e);
            return null;
        }
    }
    
    /**
     * Finds a missing element in a row
     */
    private WebElement findMissingElementInRow(
            WebDriver driver, List<WebElement> row, int expectedCount,
            Map<Integer, List<WebElement>> allRows, List<Integer> sortedYCoords,
            Map<WebElement, VisualProperties> propertiesMap) {
        
        try {
            // Sort elements in this row by X coordinate
            row.sort(Comparator.comparing(e -> propertiesMap.get(e).getX()));
            
            // Find a complete row to use as reference
            List<WebElement> referenceRow = null;
            for (Integer y : sortedYCoords) {
                List<WebElement> currentRow = allRows.get(y);
                if (currentRow.size() == expectedCount) {
                    referenceRow = currentRow;
                    break;
                }
            }
            
            if (referenceRow == null) {
                return null;
            }
            
            // Sort reference row by X coordinate
            referenceRow.sort(Comparator.comparing(e -> propertiesMap.get(e).getX()));
            
            // Calculate average spacing in reference row
            List<Integer> xCoordinatesRef = referenceRow.stream()
                .map(e -> propertiesMap.get(e).getX())
                .collect(Collectors.toList());
            
            int totalSpacing = 0;
            int spacingCount = 0;
            
            for (int i = 1; i < xCoordinatesRef.size(); i++) {
                int spacing = xCoordinatesRef.get(i) - xCoordinatesRef.get(i - 1);
                totalSpacing += spacing;
                spacingCount++;
            }
            
            int averageSpacing = spacingCount > 0 ? totalSpacing / spacingCount : 0;
            
            if (averageSpacing <= 0) {
                return null;
            }
            
            // Find gaps in the current row that might indicate missing elements
            List<Integer> xCoordinatesCurrent = row.stream()
                .map(e -> propertiesMap.get(e).getX())
                .collect(Collectors.toList());
            
            for (int i = 0; i < xCoordinatesCurrent.size() - 1; i++) {
                int spacing = xCoordinatesCurrent.get(i + 1) - xCoordinatesCurrent.get(i);
                
                // If spacing is significantly larger than average, there might be a missing element
                if (spacing > averageSpacing * 1.5) {
                    // Calculate the expected X coordinate of the missing element
                    int expectedX = xCoordinatesCurrent.get(i) + averageSpacing;
                    int expectedY = propertiesMap.get(row.get(0)).getY();
                    
                    // Look for elements near this position
                    WebElement missingElement = findElementAtPosition(driver, expectedX, expectedY, 
                        propertiesMap, row);
                    
                    if (missingElement != null) {
                        return missingElement;
                    }
                }
            }
            
            // Check if an element might be missing at the beginning or end of the row
            if (xCoordinatesCurrent.size() < expectedCount) {
                // Check if missing at the beginning
                if (xCoordinatesRef.get(0) < xCoordinatesCurrent.get(0) - averageSpacing / 2) {
                    int expectedX = xCoordinatesRef.get(0);
                    int expectedY = propertiesMap.get(row.get(0)).getY();
                    
                    WebElement missingElement = findElementAtPosition(driver, expectedX, expectedY, 
                        propertiesMap, row);
                    
                    if (missingElement != null) {
                        return missingElement;
                    }
                }
                
                // Check if missing at the end
                if (xCoordinatesRef.get(xCoordinatesRef.size() - 1) > 
                    xCoordinatesCurrent.get(xCoordinatesCurrent.size() - 1) + averageSpacing / 2) {
                    
                    int expectedX = xCoordinatesRef.get(xCoordinatesRef.size() - 1);
                    int expectedY = propertiesMap.get(row.get(0)).getY();
                    
                    WebElement missingElement = findElementAtPosition(driver, expectedX, expectedY, 
                        propertiesMap, row);
                    
                    if (missingElement != null) {
                        return missingElement;
                    }
                }
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding missing element in row", e);
            return null;
        }
    }
    
    /**
     * Finds an element at a specific position
     */
    private WebElement findElementAtPosition(WebDriver driver, int x, int y, 
            Map<WebElement, VisualProperties> propertiesMap, List<WebElement> excludeElements) {
        
        try {
            // Use JavaScript to find element at position
            JavascriptExecutor js = (JavascriptExecutor) driver;
            String script = 
                "return document.elementFromPoint(" + x + ", " + y + ");";
            
            WebElement elementAtPoint = (WebElement) js.executeScript(script);
            
            if (elementAtPoint != null && !excludeElements.contains(elementAtPoint)) {
                return elementAtPoint;
            }
            
            // If nothing found at exact point, search nearby
            List<WebElement> allElements = findVisibleInteractiveElements(driver);
            
            // Filter out elements we already have
            allElements = allElements.stream()
                .filter(e -> !excludeElements.contains(e))
                .collect(Collectors.toList());
            
            // Find element close to the expected position
            for (WebElement element : allElements) {
                VisualProperties props = propertiesMap.get(element);
                
                if (props == null) {
                    Rectangle rect = element.getRect();
                    if (Math.abs(rect.getX() - x) <= 20 && Math.abs(rect.getY() - y) <= 20) {
                        return element;
                    }
                } else if (Math.abs(props.getX() - x) <= 20 && Math.abs(props.getY() - y) <= 20) {
                    return element;
                }
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding element at position", e);
            return null;
        }
    }
    
    /**
     * Finds missing element in a list layout pattern
     */
    private WebElement findMissingElementInList(
            WebDriver driver, List<WebElement> elements, Map<WebElement, VisualProperties> propertiesMap) {
        
        try {
            // Check if elements are arranged vertically or horizontally in sequence
            boolean isVertical = isVerticalList(elements, propertiesMap);
            boolean isHorizontal = isHorizontalList(elements, propertiesMap);
            
            if (!isVertical && !isHorizontal) {
                return null; // Not a list
            }
            
            // Sort elements by appropriate coordinate
            if (isVertical) {
                elements.sort(Comparator.comparing(e -> propertiesMap.get(e).getY()));
            } else {
                elements.sort(Comparator.comparing(e -> propertiesMap.get(e).getX()));
            }
            
            // Calculate average spacing
            int totalSpacing = 0;
            int spacingCount = 0;
            List<Integer> coordinates = new ArrayList<>();
            
            for (WebElement element : elements) {
                VisualProperties props = propertiesMap.get(element);
                if (isVertical) {
                    coordinates.add(props.getY());
                } else {
                    coordinates.add(props.getX());
                }
            }
            
            for (int i = 1; i < coordinates.size(); i++) {
                int spacing = coordinates.get(i) - coordinates.get(i - 1);
                if (spacing > 0) {
                    totalSpacing += spacing;
                    spacingCount++;
                }
            }
            
            int averageSpacing = spacingCount > 0 ? totalSpacing / spacingCount : 0;
            
            if (averageSpacing <= 0) {
                return null;
            }
            
            // Look for gaps in the list
            for (int i = 0; i < coordinates.size() - 1; i++) {
                int spacing = coordinates.get(i + 1) - coordinates.get(i);
                
                // If spacing is significantly larger than average, there might be a missing element
                if (spacing > averageSpacing * 1.5) {
                    WebElement current = elements.get(i);
                    VisualProperties currentProps = propertiesMap.get(current);
                    
                    // Calculate expected position of missing element
                    int expectedX = isVertical ? currentProps.getX() : currentProps.getX() + averageSpacing;
                    int expectedY = isVertical ? currentProps.getY() + averageSpacing : currentProps.getY();
                    
                    // Look for elements at this position
                    WebElement missingElement = findElementAtPosition(driver, expectedX, expectedY, 
                        propertiesMap, elements);
                    
                    if (missingElement != null) {
                        return missingElement;
                    }
                }
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding missing element in list", e);
            return null;
        }
    }
    
    /**
     * Checks if elements form a vertical list
     */
    private boolean isVerticalList(List<WebElement> elements, Map<WebElement, VisualProperties> propertiesMap) {
        if (elements.size() < 2) {
            return false;
        }
        
        // Sort by Y coordinate
        List<WebElement> sorted = new ArrayList<>(elements);
        sorted.sort(Comparator.comparing(e -> propertiesMap.get(e).getY()));
        
        // Check if X coordinates are similar
        int referenceX = propertiesMap.get(sorted.get(0)).getX();
        int similarCount = 0;
        
        for (WebElement element : sorted) {
            int x = propertiesMap.get(element).getX();
            if (Math.abs(x - referenceX) <= 10) {
                similarCount++;
            }
        }
        
        // At least 70% of elements should align vertically
        return (double) similarCount / elements.size() >= 0.7;
    }
    
    /**
     * Checks if elements form a horizontal list
     */
    private boolean isHorizontalList(List<WebElement> elements, Map<WebElement, VisualProperties> propertiesMap) {
        if (elements.size() < 2) {
            return false;
        }
        
        // Sort by X coordinate
        List<WebElement> sorted = new ArrayList<>(elements);
        sorted.sort(Comparator.comparing(e -> propertiesMap.get(e).getX()));
        
        // Check if Y coordinates are similar
        int referenceY = propertiesMap.get(sorted.get(0)).getY();
        int similarCount = 0;
        
        for (WebElement element : sorted) {
            int y = propertiesMap.get(element).getY();
            if (Math.abs(y - referenceY) <= 10) {
                similarCount++;
            }
        }
        
        // At least 70% of elements should align horizontally
        return (double) similarCount / elements.size() >= 0.7;
    }
    
    /**
     * Finds missing element in a form pattern
     */
    private WebElement findMissingElementInForm(
            WebDriver driver, List<WebElement> elements, Map<WebElement, VisualProperties> propertiesMap) {
        
        try {
            // Check if these are form elements
            boolean hasFormElements = elements.stream()
                .anyMatch(e -> {
                    String tag = e.getTagName().toLowerCase();
                    return tag.equals("input") || tag.equals("select") || 
                          tag.equals("textarea") || tag.equals("button");
                });
            
            if (!hasFormElements) {
                return null; // Not form elements
            }
            
            // Look for a common ancestor (form)
            WebElement commonAncestor = findCommonAncestor(driver, elements);
            
            if (commonAncestor == null) {
                return null;
            }
            
            // Find all form controls in the ancestor that aren't in our list
            List<WebElement> allFormControls = commonAncestor.findElements(
                By.cssSelector("input, select, textarea, button"));
            
            // Filter to exclude elements we already have
            List<WebElement> missingControls = allFormControls.stream()
                .filter(e -> !elements.contains(e) && isElementVisible(e))
                .collect(Collectors.toList());
            
            if (!missingControls.isEmpty()) {
                // Return the first missing control
                return missingControls.get(0);
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding missing element in form", e);
            return null;
        }
    }
    
    /**
     * Finds a common ancestor for a set of elements
     */
    private WebElement findCommonAncestor(WebDriver driver, List<WebElement> elements) {
        if (elements.isEmpty()) {
            return null;
        }
        
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            // Script to find common ancestor
            String script = 
                "function findCommonAncestor(elements) {" +
                "  if (elements.length === 0) return null;" +
                "  if (elements.length === 1) return elements[0].parentElement;" +
                
                "  function getAncestors(element) {" +
                "    var ancestors = [];" +
                "    while (element) {" +
                "      ancestors.unshift(element);" +
                "      element = element.parentElement;" +
                "    }" +
                "    return ancestors;" +
                "  }" +
                
                "  var ancestorArrays = elements.map(getAncestors);" +
                "  var minLength = Math.min(...ancestorArrays.map(arr => arr.length));" +
                
                "  var commonAncestor = null;" +
                "  for (var i = 0; i < minLength; i++) {" +
                "    var current = ancestorArrays[0][i];" +
                "    if (ancestorArrays.every(arr => arr[i] === current)) {" +
                "      commonAncestor = current;" +
                "    } else {" +
                "      break;" +
                "    }" +
                "  }" +
                
                "  return commonAncestor;" +
                "}" +
                "return findCommonAncestor(arguments);";
            
            return (WebElement) js.executeScript(script, elements.toArray());
        } catch (Exception e) {
            logger.debug("Error finding common ancestor", e);
            return null;
        }
    }
    
    /**
     * Finds element in common regions of the page
     */
    private WebElement findElementInCommonRegions(
            WebDriver driver, Map<WebElement, VisualProperties> propertiesMap) {
        
        try {
            // Define common regions to check
            String[] commonRegions = {
                // Header region
                "header, .header, [class*='header'], #header, [role='banner']",
                
                // Navigation region
                "nav, .nav, .navigation, [class*='nav-'], #nav, [role='navigation']",
                
                // Footer region
                "footer, .footer, [class*='footer'], #footer, [role='contentinfo']",
                
                // Main content region
                "main, .main, #main, [role='main'], .content, #content",
                
                // Sidebar region
                "aside, .sidebar, #sidebar, [class*='sidebar']",
                
                // Form region
                "form, .form, [class*='form'], #form"
            };
            
            // Check each region for interactive elements
            for (String regionSelector : commonRegions) {
                try {
                    List<WebElement> regions = driver.findElements(By.cssSelector(regionSelector));
                    
                    for (WebElement region : regions) {
                        List<WebElement> interactiveElements = region.findElements(By.cssSelector(
                            "button, input, select, textarea, a, [role='button'], " + 
                            "[tabindex], [class*='btn'], [onclick]"));
                        
                        // Filter to visible elements that aren't in our map
                        interactiveElements = interactiveElements.stream()
                            .filter(e -> isElementVisible(e) && !propertiesMap.containsKey(e))
                            .collect(Collectors.toList());
                        
                        if (!interactiveElements.isEmpty()) {
                            return interactiveElements.get(0);
                        }
                    }
                } catch (Exception e) {
                    // Continue to next region
                }
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding element in common regions", e);
            return null;
        }
    }
    
    /**
     * Finds element by proximity to other elements
     */
    private WebElement findElementByProximity(
            WebDriver driver, Map<WebElement, VisualProperties> propertiesMap) {
        
        if (propertiesMap.isEmpty()) {
            return null;
        }
        
        try {
            // Calculate centroid of all known elements
            int totalX = 0;
            int totalY = 0;
            
            for (VisualProperties props : propertiesMap.values()) {
                totalX += props.getX();
                totalY += props.getY();
            }
            
            int centerX = totalX / propertiesMap.size();
            int centerY = totalY / propertiesMap.size();
            
            // Find all interactive elements we don't have
            List<WebElement> candidates = findVisibleInteractiveElements(driver);
            
            // Filter out elements we already know
            candidates = candidates.stream()
                .filter(e -> !propertiesMap.containsKey(e))
                .collect(Collectors.toList());
            
            if (candidates.isEmpty()) {
                return null;
            }
            
            // Find the closest element to our centroid
            WebElement closestElement = null;
            int closestDistance = Integer.MAX_VALUE;
            
            for (WebElement element : candidates) {
                Rectangle rect = element.getRect();
                int elementX = rect.getX() + rect.getWidth() / 2;
                int elementY = rect.getY() + rect.getHeight() / 2;
                
                int distance = calculateDistance(elementX, elementY, centerX, centerY);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestElement = element;
                }
            }
            
            // Only return if the element is reasonably close
            if (closestDistance < 300) {
                return closestElement;
            }
            
            return null;
        } catch (Exception e) {
            logger.debug("Error finding element by proximity", e);
            return null;
        }
    }
    
    /**
     * Calculates Euclidean distance between two points
     */
    private int calculateDistance(int x1, int y1, int x2, int y2) {
        int dx = x2 - x1;
        int dy = y2 - y1;
        return (int) Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * VisualProperties class to store visual characteristics of elements
     */
    private static class VisualProperties {
        private int x;
        private int y;
        private int width;
        private int height;
        private double relativeX;
        private double relativeY;
        private String backgroundColor;
        private String color;
        private String borderColor;
        private String fontSize;
        private String borderRadius;
        private String textContent;
        private String tagName;
        
        public int getX() {
            return x;
        }
        
        public void setX(int x) {
            this.x = x;
        }
        
        public int getY() {
            return y;
        }
        
        public void setY(int y) {
            this.y = y;
        }
        
        public int getWidth() {
            return width;
        }
        
        public void setWidth(int width) {
            this.width = width;
        }
        
        public int getHeight() {
            return height;
        }
        
        public void setHeight(int height) {
            this.height = height;
        }
        
        public double getRelativeX() {
            return relativeX;
        }
        
        public void setRelativeX(double relativeX) {
            this.relativeX = relativeX;
        }
        
        public double getRelativeY() {
            return relativeY;
        }
        
        public void setRelativeY(double relativeY) {
            this.relativeY = relativeY;
        }
        
        public String getBackgroundColor() {
            return backgroundColor;
        }
        
        public void setBackgroundColor(String backgroundColor) {
            this.backgroundColor = backgroundColor;
        }
        
        public String getColor() {
            return color;
        }
        
        public void setColor(String color) {
            this.color = color;
        }
        
        public String getBorderColor() {
            return borderColor;
        }
        
        public void setBorderColor(String borderColor) {
            this.borderColor = borderColor;
        }
        
        public String getFontSize() {
            return fontSize;
        }
        
        public void setFontSize(String fontSize) {
            this.fontSize = fontSize;
        }
        
        public String getBorderRadius() {
            return borderRadius;
        }
        
        public void setBorderRadius(String borderRadius) {
            this.borderRadius = borderRadius;
        }
        
        public String getTextContent() {
            return textContent;
        }
        
        public void setTextContent(String textContent) {
            this.textContent = textContent;
        }
        
        public String getTagName() {
            return tagName;
        }
        
        public void setTagName(String tagName) {
            this.tagName = tagName;
        }
    }
}


package com.cssmart.framework.healing;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

/**
 * Context information used for element healing
 */
public class HealingContext {
    private final WebDriver driver;
    private final String elementName;
    private final String elementDescription;
    private final Exception originalException;
    
    /**
     * Creates a healing context with information needed for healing strategies
     */
    public HealingContext(WebDriver driver, String elementName, String elementDescription, Exception originalException) {
        this.driver = driver;
        this.elementName = elementName;
        this.elementDescription = elementDescription;
        this.originalException = originalException;
    }
    
    public WebDriver getDriver() {
        return driver;
    }
    
    public String getElementName() {
        return elementName;
    }
    
    public String getElementDescription() {
        return elementDescription;
    }
    
    public Exception getOriginalException() {
        return originalException;
    }
}

/**
 * Result of a healing attempt
 */
public class HealingResult {
    private final boolean success;
    private final String strategy;
    private final String message;
    private final WebElement element;
    
    /**
     * Creates a healing result
     */
    public HealingResult(boolean success, String strategy, String message, WebElement element) {
        this.success = success;
        this.strategy = strategy;
        this.message = message;
        this.element = element;
    }
    
    public boolean isSuccess() {
        return success;
    }
    
    public String getStrategy() {
        return strategy;
    }
    
    public String getMessage() {
        return message;
    }
    
    public WebElement getElement() {
        return element;
    }
    
    @Override
    public String toString() {
        return "HealingResult{" +
               "success=" + success +
               ", strategy='" + strategy + '\'' +
               ", message='" + message + '\'' +
               ", element=" + (element != null ? "found" : "null") +
               '}';
    }
}

/**
 * Interface for all element healing strategies
 */
public interface HealingStrategy {
    /**
     * Attempts to heal (find) an element that could not be located with its primary locator
     * 
     * @param context Context information for the healing operation
     * @return Result of the healing attempt
     */
    HealingResult heal(HealingContext context);
}


package com.cssmart.framework.enums;

/**
 * Defines the strategy to use when attempting to locate an element
 */
public enum LocatorStrategy {
    /**
     * Uses natural language processing to understand the semantic meaning of the element description
     */
    SEMANTIC,
    
    /**
     * Uses DOM structure analysis to locate elements based on their relative position in the DOM
     */
    DOM,
    
    /**
     * Uses visual characteristics and positioning to locate elements
     */
    VISUAL
}

/**
 * Defines how to handle element location failures
 */
public enum FailureHandling {
    /**
     * Throw an exception when an element cannot be found
     */
    FAIL,
    
    /**
     * Attempt to heal the element using available strategies when it cannot be found
     */
    SELF_HEAL,
    
    /**
     * Log a warning but continue execution when an element cannot be found
     */
    CONTINUE
}

/**
 * Defines different element states for assertions
 */
public enum ElementState {
    /**
     * Element is visible on the page
     */
    VISIBLE,
    
    /**
     * Element is not visible on the page
     */
    INVISIBLE,
    
    /**
     * Element is enabled (not disabled)
     */
    ENABLED,
    
    /**
     * Element is disabled
     */
    DISABLED,
    
    /**
     * Element is selected (like checkboxes or radio buttons)
     */
    SELECTED,
    
    /**
     * Element is not selected
     */
    UNSELECTED
}



package com.cssmart.framework.annotation;

import com.cssmart.framework.enums.FailureHandling;
import com.cssmart.framework.enums.LocatorStrategy;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for defining alternate locators that can be used when the primary locator fails
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface AlternateLocator {
    /**
     * ID locator
     */
    String id() default "";
    
    /**
     * Name locator
     */
    String name() default "";
    
    /**
     * CSS selector locator
     */
    String css() default "";
    
    /**
     * XPath locator
     */
    String xpath() default "";
    
    /**
     * Class name locator
     */
    String className() default "";
    
    /**
     * Tag name locator
     */
    String tagName() default "";
    
    /**
     * Link text locator
     */
    String linkText() default "";
    
    /**
     * Partial link text locator
     */
    String partialLinkText() default "";
}

/**
 * Enhanced version of Selenium @FindBy with AI-powered element location capabilities
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface CSSmartFindBy {
    /**
     * ID locator
     */
    String id() default "";
    
    /**
     * Name locator
     */
    String name() default "";
    
    /**
     * CSS selector locator
     */
    String css() default "";
    
    /**
     * XPath locator
     */
    String xpath() default "";
    
    /**
     * Class name locator
     */
    String className() default "";
    
    /**
     * Tag name locator
     */
    String tagName() default "";
    
    /**
     * Link text locator
     */
    String linkText() default "";
    
    /**
     * Partial link text locator
     */
    String partialLinkText() default "";
    
    /**
     * Natural language description of the element
     */
    String description() default "";
    
    /**
     * Enable AI-powered element location
     */
    boolean useAI() default false;
    
    /**
     * Enable context-aware element detection
     */
    boolean contextAware() default false;
    
    /**
     * Enable element fingerprinting for more reliable identification
     */
    boolean fingerprint() default false;
    
    /**
     * Specifies how to handle element location failures
     */
    FailureHandling failureHandling() default FailureHandling.FAIL;
    
    /**
     * Prioritized list of strategies to use when locating the element
     */
    LocatorStrategy[] priority() default {};
    
    /**
     * Alternate locators to try if the primary one fails
     */package com.cssmart.framework.logging;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.ConsoleHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

/**
 * Custom logger for the CSSmartFramework
 */
public class CSSmartLogger {
    
    private final Logger logger;
    private static final String LOG_FORMAT = "[%s] [%s] [%s] %s%n";
    
    static {
        // Configure the root logger
        Logger rootLogger = Logger.getLogger("");
        rootLogger.setUseParentHandlers(false);
        
        // Set up custom formatter
        ConsoleHandler consoleHandler = new ConsoleHandler();
        consoleHandler.setFormatter(new Formatter() {
            @Override
            public String format(LogRecord record) {
                SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
                String timestamp = dateFormat.format(new Date(record.getMillis()));
                
                return String.format(LOG_FORMAT, 
                    timestamp,
                    record.getLevel().getName(), 
                    record.getLoggerName(), 
                    record.getMessage());
            }
        });
        
        rootLogger.addHandler(consoleHandler);
    }
    
    /**
     * Gets a logger instance for the specified class
     */
    public static CSSmartLogger getLogger(Class<?> clazz) {
        return new CSSmartLogger(clazz.getSimpleName());
    }
    
    /**
     * Creates a new logger with the specified name
     */
    private CSSmartLogger(String name) {
        this.logger = Logger.getLogger(name);
        this.logger.setLevel(Level.INFO);
    }
    
    /**
     * Sets the log level for this logger
     */
    public void setLevel(Level level) {
        logger.setLevel(level);
    }
    
    /**
     * Logs a debug message
     */
    public void debug(String message) {
        logger.fine(message);
    }
    
    /**
     * Logs a debug message with an exception
     */
    public void debug(String message, Throwable throwable) {
        logger.log(Level.FINE, message, throwable);
    }
    
    /**
     * Logs an info message
     */
    public void info(String message) {
        logger.info(message);
    }
    
    /**
     * Logs an info message with an exception
     */
    public void info(String message, Throwable throwable) {
        logger.log(Level.INFO, message, throwable);
    }
    
    /**
     * Logs a warning message
     */
    public void warning(String message) {
        logger.warning(message);
    }
    
    /**
     * Logs a warning message with an exception
     */
    public void warning(String message, Throwable throwable) {
        logger.log(Level.WARNING, message, throwable);
    }
    
    /**
     * Logs an error message
     */
    public void error(String message) {
        logger.severe(message);
    }
    
    /**
     * Logs an error message with an exception
     */
    public void error(String message, Throwable throwable) {
        logger.log(Level.SEVERE, message, throwable);
    }
}



    AlternateLocator[] alternateLocators() default {};
}



package com.cssmart.framework.exception;

/**
 * Exception thrown when an element cannot be found even after healing attempts
 */
public class ElementNotFoundException extends RuntimeException {
    
    /**
     * Creates a new ElementNotFoundException
     */
    public ElementNotFoundException(String message) {
        super(message);
    }
    
    /**
     * Creates a new ElementNotFoundException with a cause
     */
    public ElementNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.cssmart.framework.annotation;

import com.cssmart.framework.enums.Importance;
import com.cssmart.framework.enums.ScreenshotType;
import com.cssmart.framework.enums.StepCategory;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for step mapping patterns used to match BDD steps
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface StepMapping {
    /**
     * Type of BDD step (Given, When, Then, And, But)
     */
    StepType type();
    
    /**
     * Pattern to match BDD steps (can use regular expressions)
     */
    String pattern();
}

/**
 * Enum for BDD step types
 */
enum StepType {
    GIVEN,
    WHEN,
    THEN,
    AND,
    BUT
}

/**
 * Smart test step annotation for enhanced test step tracking and BDD integration
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSSmartTestStep {
    /**
     * Description of the test step
     */
    String description();
    
    /**
     * Category of the step (e.g., SETUP, ACTION, VERIFICATION)
     */
    StepCategory category() default StepCategory.ACTION;package com.cssmart.framework.enums;

/**
 * Defines the category of a test step
 */
public enum StepCategory {
    /**
     * Step that sets up the test environment or preconditions
     */
    SETUP,
    
    /**
     * Step that performs an action on the application
     */
    ACTION,
    
    /**
     * Step that validates or verifies expected outcomes
     */
    VERIFICATION,
    
    /**
     * Step that cleans up after the test
     */
    CLEANUP,
    
    /**
     * Step that logs or documents information
     */
    INFORMATION
}

/**
 * Defines the importance level of a test step
 */
public enum Importance {
    /**
     * Critical step that is essential for the test flow
     */
    CRITICAL,
    
    /**
     * High importance step
     */
    HIGH,
    
    /**
     * Normal importance step
     */
    NORMAL,
    
    /**
     * Low importance step
     */
    LOW
}

/**
 * Defines when screenshots should be taken during a test step
 */
public enum ScreenshotType {
    /**
     * No screenshots will be taken
     */
    NONE,
    
    /**
     * Screenshot is taken before executing the step
     */
    BEFORE,
    
    /**
     * Screenshot is taken after executing the step
     */
    AFTER,
    
    /**
     * Screenshots are taken both before and after executing the step
     */
    BEFORE_AND_AFTER,
    
    /**
     * Screenshots are taken only if the step fails
     */
    ON_FAILURE
}

package com.cssmart.framework.bdd;

import com.cssmart.framework.annotation.CSSmartTestStep;
import com.cssmart.framework.annotation.StepMapping;
import com.cssmart.framework.annotation.StepType;
import com.cssmart.framework.logging.CSSmartLogger;

import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Smart step matcher for intelligent BDD step matching and execution
 */
public class SmartStepMatcher {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(SmartStepMatcher.class);
    
    // Dictionary of synonyms for pattern matching
    private static final Map<String, List<String>> synonymDictionary = initializeSynonymDictionary();
    
    // Cache of registered step methods
    private final Map<String, List<StepMethodInfo>> registeredSteps = new HashMap<>();
    
    // Cache of word similarity scores
    private final Map<String, Map<String, Double>> wordSimilarityCache = new HashMap<>();
    
    /**
     * Registers test steps from a class
     */
    public void registerSteps(Object stepDefinitionInstance) {
        Class<?> stepClass = stepDefinitionInstance.getClass();
        
        for (Method method : stepClass.getMethods()) {
            CSSmartTestStep annotation = method.getAnnotation(CSSmartTestStep.class);
            if (annotation != null) {
                registerStep(method, annotation, stepDefinitionInstance);
            }
        }
    }
    
    /**
     * Registers a single test step method
     */
    private void registerStep(Method method, CSSmartTestStep annotation, Object instance) {
        String description = annotation.description().toLowerCase();
        
        // Create step method info
        StepMethodInfo stepInfo = new StepMethodInfo(method, annotation, instance);
        
        // Add the step using the description as key
        addToRegisteredSteps(description, stepInfo);
        
        // Register with specific mapping patterns if present
        StepMapping[] mappings = annotation.mappingStrategies();
        if (mappings.length > 0) {
            for (StepMapping mapping : mappings) {
                String pattern = mapping.pattern().toLowerCase();
                addToRegisteredSteps(pattern, stepInfo);
            }
        } else {
            // Auto-generate mappings based on the description
            List<String> generatedPatterns = generatePatterns(description);
            for (String pattern : generatedPatterns) {
                addToRegisteredSteps(pattern, stepInfo);
            }
        }
    }
    
    /**
     * Adds a step method to the registered steps map
     */
    private void addToRegisteredSteps(String key, StepMethodInfo stepInfo) {
        registeredSteps.computeIfAbsent(key, k -> new ArrayList<>()).add(stepInfo);
    }
    
    /**
     * Automatically generates alternative patterns for a step description
     */
    private List<String> generatePatterns(String description) {
        List<String> patterns = new ArrayList<>();
        
        // Add exact description as a pattern
        patterns.add(description);
        
        // Generate patterns with synonyms
        String[] words = description.split("\\s+");
        
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            List<String> synonyms = synonymDictionary.getOrDefault(word, Collections.emptyList());
            
            for (String synonym : synonyms) {
                if (!synonym.equals(word)) {
                    // Create a new pattern with this synonym
                    String[] patternWords = Arrays.copyOf(words, words.length);
                    patternWords[i] = synonym;
                    patterns.add(String.join(" ", patternWords));
                    
                    // To avoid combinatorial explosion, only create combinations
                    // for the most significant words (verbs, nouns)
                    if (patterns.size() >= 5) {
                        break;
                    }
                }
            }
        }
        
        // Add pattern with word order variations for key phrases
        if (description.contains(" and ")) {
            String reversed = description.replaceFirst(" and ", " PLACEHOLDER ")
                                        .replaceFirst(" (\\w+) ", " PLACEHOLDER ")
                                        .replaceFirst("PLACEHOLDER", "$1")
                                        .replaceFirst("PLACEHOLDER", "and");
            patterns.add(reversed);
        }
        
        return patterns;
    }
    
    /**
     * Finds the best matching step method for a given BDD step
     */
    public StepMethodInfo findMatchingStep(String bddStep) {
        if (bddStep == null || bddStep.isEmpty()) {
            return null;
        }
        
        // Normalize input step
        String normalizedStep = bddStep.toLowerCase().trim();
        
        // Strip leading Given/When/Then/And/But keyword
        normalizedStep = stripBddKeyword(normalizedStep);
        
        // Try to find exact match
        for (Map.Entry<String, List<StepMethodInfo>> entry : registeredSteps.entrySet()) {
            String pattern = entry.getKey();
            
            if (exactMatch(normalizedStep, pattern)) {
                logger.info("Found exact step match: " + pattern);
                return entry.getValue().get(0);
            }
        }
        
        // Try to find regex pattern match
        for (Map.Entry<String, List<StepMethodInfo>> entry : registeredSteps.entrySet()) {
            String pattern = entry.getKey();
            
            if (patternMatch(normalizedStep, pattern)) {
                logger.info("Found pattern step match: " + pattern);
                return entry.getValue().get(0);
            }
        }
        
        // Try to find semantic match
        StepMethodInfo bestMatch = findSemanticMatch(normalizedStep);
        if (bestMatch != null) {
            logger.info("Found semantic step match for: " + normalizedStep);
            return bestMatch;
        }
        
        logger.warning("No matching step found for: " + bddStep);
        return null;
    }
    
    /**
     * Strips the BDD keyword (Given, When, Then, And, But) from a step
     */
    private String stripBddKeyword(String step) {
        return step.replaceFirst("^(given|when|then|and|but)\\s+", "");
    }
    
    /**
     * Checks if a step exactly matches a pattern
     */
    private boolean exactMatch(String step, String pattern) {
        return step.equals(pattern);
    }
    
    /**
     * Checks if a step matches a regex pattern
     */
    private boolean patternMatch(String step, String pattern) {
        // If pattern contains regex special characters
        if (pattern.contains("(") || pattern.contains("[") || pattern.contains("*") || 
            pattern.contains("+") || pattern.contains("?") || pattern.contains("\\")) {
            try {
                Pattern regex = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
                Matcher matcher = regex.matcher(step);
                return matcher.matches();
            } catch (Exception e) {
                // If pattern compilation fails, treat as regular string
                return false;
            }
        }
        return false;
    }
    
    /**
     * Finds the best semantic match for a step
     */
    private StepMethodInfo findSemanticMatch(String step) {
        StepMethodInfo bestMatch = null;
        double bestScore = 0.7; // Threshold for accepting a match
        
        for (Map.Entry<String, List<StepMethodInfo>> entry : registeredSteps.entrySet()) {
            String pattern = entry.getKey();
            double similarity = calculateSemanticSimilarity(step, pattern);
            
            if (similarity > bestScore) {
                bestScore = similarity;
                bestMatch = entry.getValue().get(0);
            }
        }
        
        return bestMatch;
    }
    
    /**
     * Calculates semantic similarity between two step descriptions
     */
    private double calculateSemanticSimilarity(String step1, String step2) {
        // Tokenize steps
        String[] words1 = step1.split("\\s+");
        String[] words2 = step2.split("\\s+");
        
        // If lengths are very different, reduce similarity
        double lengthDifference = 1.0 - (double) Math.abs(words1.length - words2.length) / 
                                        Math.max(words1.length, words2.length);
        
        // Calculate word matching scores
        double totalScore = 0;
        int matchCount = 0;
        
        // Track which words in step2 have been matched
        boolean[] matched = new boolean[words2.length];
        
        for (String word1 : words1) {
            double bestWordScore = 0;
            int bestMatchIndex = -1;
            
            for (int i = 0; i < words2.length; i++) {
                if (matched[i]) continue;
                
                double wordScore = getWordSimilarity(word1, words2[i]);
                if (wordScore > bestWordScore) {
                    bestWordScore = wordScore;
                    bestMatchIndex = i;
                }
            }
            
            if (bestMatchIndex >= 0 && bestWordScore > 0.5) {
                totalScore += bestWordScore;
                matchCount++;
                matched[bestMatchIndex] = true;
            }
        }
        
        // Calculate final similarity score
        double wordMatchScore = matchCount > 0 ? totalScore / matchCount : 0;
        
        // Weigh both length similarity and word match quality
        double finalScore = wordMatchScore * 0.7 + lengthDifference * 0.3;
        
        return finalScore;
    }
    
    /**
     * Gets the similarity score between two words
     */
    private double getWordSimilarity(String word1, String word2) {
        // Check cache first
        Map<String, Double> wordCache = wordSimilarityCache.computeIfAbsent(word1, k -> new HashMap<>());
        if (wordCache.containsKey(word2)) {
            return wordCache.get(word2);
        }
        
        // Exact match
        if (word1.equals(word2)) {
            wordCache.put(word2, 1.0);
            return 1.0;
        }
        
        // Check if one is a substring of the other
        if (word1.contains(word2) || word2.contains(word1)) {
            double minLength = Math.min(word1.length(), word2.length());
            double maxLength = Math.max(word1.length(), word2.length());
            double score = minLength / maxLength;
            wordCache.put(word2, score);
            return score;
        }
        
        // Check for edit distance
        int distance = calculateLevenshteinDistance(word1, word2);
        double maxLength = Math.max(word1.length(), word2.length());
        double score = 1.0 - (distance / maxLength);
        
        // Check for synonyms
        List<String> synonyms1 = synonymDictionary.getOrDefault(word1, Collections.emptyList());
        if (synonyms1.contains(word2)) {
            score = Math.max(score, 0.9);
        }
        
        wordCache.put(word2, score);
        return score;
    }
    
    /**
     * Calculates the Levenshtein distance between two strings
     */
    private int calculateLevenshteinDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            dp[i][0] = i;
        }
        
        for (int j = 0; j <= s2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;
                dp[i][j] = Math.min(
                    Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),
                    dp[i - 1][j - 1] + cost
                );
            }
        }
        
        return dp[s1.length()][s2.length()];
    }
    
    /**
     * Executes a BDD step
     */
    public void executeStep(String bddStep) throws Exception {
        StepMethodInfo stepInfo = findMatchingStep(bddStep);
        
        if (stepInfo == null) {
            throw new IllegalArgumentException("No matching step found for: " + bddStep);
        }
        
        // Parse parameters if needed (for parameterized steps)
        Object[] parameters = extractParameters(bddStep, stepInfo);
        
        // Execute the step
        stepInfo.execute(parameters);
    }
    
    /**
     * Extracts parameters from a BDD step string
     */
    private Object[] extractParameters(String bddStep, StepMethodInfo stepInfo) {
        Method method = stepInfo.getMethod();
        Class<?>[] parameterTypes = method.getParameterTypes();
        
        if (parameterTypes.length == 0) {
            return new Object[0];
        }
        
        // For each mapping pattern, try to extract parameters
        for (StepMapping mapping : stepInfo.getAnnotation().mappingStrategies()) {
            String pattern = mapping.pattern();
            
            // Skip patterns without parameter placeholders
            if (!pattern.contains("(") || !pattern.contains(")")) {
                continue;
            }
            
            try {
                Pattern regex = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
                Matcher matcher = regex.matcher(bddStep);
                
                if (matcher.matches()) {
                    Object[] params = new Object[parameterTypes.length];
                    
                    for (int i = 0; i < parameterTypes.length && i < matcher.groupCount(); i++) {
                        String paramValue = matcher.group(i + 1);
                        params[i] = convertParameter(paramValue, parameterTypes[i]);
                    }
                    
                    return params;
                }
            } catch (Exception e) {
                logger.error("Error extracting parameters from step", e);
            }
        }
        
        // If no pattern matched or no parameters found, return empty array
        return new Object[0];
    }
    
    /**
     * Converts a string parameter to the required type
     */
    private Object convertParameter(String value, Class<?> targetType) {
        if (value == null) {
            return null;
        }
        
        if (targetType == String.class) {
            return value;
        } else if (targetType == int.class || targetType == Integer.class) {
            return Integer.parseInt(value);
        } else if (targetType == long.class || targetType == Long.class) {
            return Long.parseLong(value);
        } else if (targetType == double.class || targetType == Double.class) {
            return Double.parseDouble(value);
        } else if (targetType == boolean.class || targetType == Boolean.class) {
            return Boolean.parseBoolean(value);
        } else if (targetType == float.class || targetType == Float.class) {
            return Float.parseFloat(value);
        } else if (targetType.isEnum()) {
            return Enum.valueOf((Class<Enum>) targetType, value.toUpperCase());
        }
        
        // For other types, try to use constructor with String parameter
        try {
            return targetType.getConstructor(String.class).newInstance(value);
        } catch (Exception e) {
            throw new IllegalArgumentException(
                "Cannot convert value '" + value + "' to type " + targetType.getName(), e);
        }
    }
    
    /**
     * Suggests step implementations for a BDD scenario
     */
    public List<StepSuggestion> suggestStepImplementations(List<String> bddSteps) {
        List<StepSuggestion> suggestions = new ArrayList<>();
        
        for (String step : bddSteps) {
            StepMethodInfo match = findMatchingStep(step);
            
            if (match == null) {
                // Determine the step type
                StepType stepType = determineStepType(step);
                
                // Create a step suggestion
                StepSuggestion suggestion = new StepSuggestion(step, stepType);
                suggestions.add(suggestion);
            }
        }
        
        return suggestions;
    }
    
    /**
     * Determines the BDD step type (Given, When, Then, And, But)
     */
    private StepType determineStepType(String step) {
        String lowercaseStep = step.toLowerCase().trim();
        
        if (lowercaseStep.startsWith("given ")) {
            return StepType.GIVEN;
        } else if (lowercaseStep.startsWith("when ")) {
            return StepType.WHEN;
        } else if (lowercaseStep.startsWith("then ")) {
            return StepType.THEN;
        } else if (lowercaseStep.startsWith("and ")) {
            return StepType.AND;
        } else if (lowercaseStep.startsWith("but ")) {
            return StepType.BUT;
        }
        
        // If no keyword found, infer from the semantics
        if (lowercaseStep.contains("verify") || 
            lowercaseStep.contains("should") || 
            lowercaseStep.contains("must be") ||
            lowercaseStep.contains("is shown") ||
            lowercaseStep.contains("is displayed")) {
            return StepType.THEN;
        } else if (lowercaseStep.contains("click") || 
                  lowercaseStep.contains("enter") || 
                  lowercaseStep.contains("select") ||
                  lowercaseStep.contains("navigate") ||
                  lowercaseStep.contains("submit")) {
            return StepType.WHEN;
        } else {
            return StepType.GIVEN;
        }
    }
    
    /**
     * Detects missing steps in a scenario
     */
    public List<String> detectMissingSteps(List<String> bddSteps) {
        List<String> missingStepTypes = new ArrayList<>();
        
        boolean hasGiven = false;
        boolean hasWhen = false;
        boolean hasThen = false;
        
        for (String step : bddSteps) {
            String lowercaseStep = step.toLowerCase().trim();
            
            if (lowercaseStep.startsWith("given ")) {
                hasGiven = true;
            } else if (lowercaseStep.startsWith("when ")) {
                hasWhen = true;
            } else if (lowercaseStep.startsWith("then ")) {
                hasThen = true;
            }
        }
        
        if (!hasGiven) {
            missingStepTypes.add("Given (precondition)");
        }
        
        if (!hasWhen) {
            missingStepTypes.add("When (action)");
        }
        
        if (!hasThen) {
            missingStepTypes.add("Then (verification)");
        }
        
        return missingStepTypes;
    }
    
    /**
     * Detects logical inconsistencies in a scenario
     */
    public List<String> detectLogicalInconsistencies(List<String> bddSteps) {
        List<String> inconsistencies = new ArrayList<>();
        
        // Check for "Then" step before "When" step
        boolean whenSeen = false;
        boolean thenBeforeWhen = false;
        
        for (String step : bddSteps) {
            String lowercaseStep = step.toLowerCase().trim();
            
            if (lowercaseStep.startsWith("when ")) {
                whenSeen = true;
            } else if (lowercaseStep.startsWith("then ") && !whenSeen) {
                thenBeforeWhen = true;
            }
        }
        
        if (thenBeforeWhen) {
            inconsistencies.add("Verification step (Then) appears before action step (When)");
        }
        
        // Check for logically inconsistent actions
        boolean hasLogout = false;
        boolean hasActionAfterLogout = false;
        
        for (String step : bddSteps) {
            String lowercaseStep = step.toLowerCase().trim();
            
            if (lowercaseStep.contains("log out") || 
                lowercaseStep.contains("logout") || 
                lowercaseStep.contains("sign out")) {
                hasLogout = true;
            } else if (hasLogout && 
                      (lowercaseStep.contains("click") || 
                       lowercaseStep.contains("enter") || 
                       lowercaseStep.contains("navigate"))) {
                hasActionAfterLogout = true;
            }
        }
        
        if (hasActionAfterLogout) {
            inconsistencies.add("Actions performed after logout step");
        }
        
        return inconsistencies;
    }
    
    /**
     * Initializes synonym dictionary for smarter step matching
     */
    private static Map<String, List<String>> initializeSynonymDictionary() {
        Map<String, List<String>> synonyms = new HashMap<>();
        
        // Action verbs
        synonyms.put("click", Arrays.asList("press", "tap", "select", "choose"));
        synonyms.put("enter", Arrays.asList("type", "input", "fill", "provide"));
        synonyms.put("select", Arrays.asList("choose", "pick", "opt for"));
        synonyms.put("navigate", Arrays.asList("go", "browse", "visit", "open"));
        synonyms.put("verify", Arrays.asList("check", "confirm", "validate", "ensure", "assert"));
        
        // UI elements
        synonyms.put("button", Arrays.asList("btn", "option", "link"));
        synonyms.put("field", Arrays.asList("input", "textbox", "text box", "text field"));
        synonyms.put("dropdown", Arrays.asList("select", "combo box", "drop-down", "list"));
        synonyms.put("checkbox", Arrays.asList("check box", "tick box", "option"));
        
        // Common terms
        synonyms.put("login", Arrays.asList("log in", "sign in", "authenticate"));
        synonyms.put("logout", Arrays.asList("log out", "sign out"));
        synonyms.put("username", Arrays.asList("user", "user name", "login id", "account name"));
        synonyms.put("password", Arrays.asList("pass", "secret", "credentials"));
        
        return synonyms;
    }
    
    /**
     * Class to store information about a step method
     */
    public static class StepMethodInfo {
        private final Method method;
        private final CSSmartTestStep annotation;
        private final Object instance;
        
        public StepMethodInfo(Method method, CSSmartTestStep annotation, Object instance) {
            this.method = method;
            this.annotation = annotation;
            this.instance = instance;
        }
        
        public Method getMethod() {
            return method;
        }
        
        public CSSmartTestStep getAnnotation() {
            return annotation;
        }
        
        public Object getInstance() {
            return instance;
        }
        
        /**
         * Executes this step with the given parameters
         */
        public void execute(Object[] parameters) throws Exception {
            method.invoke(instance, parameters);
        }
    }
    
    /**
     * Class for step implementation suggestions
     */
    public static class StepSuggestion {
        private final String bddStep;
        private final StepType stepType;
        private final String suggestedMethodName;
        private final String suggestedImplementation;
        
        public StepSuggestion(String bddStep, StepType stepType) {
            this.bddStep = bddStep;
            this.stepType = stepType;
            this.suggestedMethodName = generateMethodName(bddStep);
            this.suggestedImplementation = generateImplementation(bddStep, stepType);
        }
        
        public String getBddStep() {
            return bddStep;
        }
        
        public StepType getStepType() {
            return stepType;
        }
        
        public String getSuggestedMethodName() {
            return suggestedMethodName;
        }
        
        public String getSuggestedImplementation() {
            return suggestedImplementation;
        }
        
        /**
         * Generates a method name from a BDD step
         */
        private String generateMethodName(String step) {
            // Remove the step type prefix and trim
            String content = step.replaceFirst("^(Given|When|Then|And|But)\\s+", "").trim();
            
            // Convert to camelCase
            StringBuilder methodName = new StringBuilder();
            boolean capitalizeNext = false;
            
            for (char c : content.toCharArray()) {
                if (Character.isLetterOrDigit(c)) {
                    methodName.append(capitalizeNext ? Character.toUpperCase(c) : Character.toLowerCase(c));
                    capitalizeNext = false;
                } else {
                    capitalizeNext = true;
                }
            }
            
            // Handle special characters and ensure valid Java method name
            String result = methodName.toString();
            
            // Add prefix based on step type
            switch (stepType) {
                case GIVEN:
                    return "given" + capitalize(result);
                case WHEN:
                    return "when" + capitalize(result);
                case THEN:
                    return "then" + capitalize(result);
                default:
                    return result;
            }
        }
        
        /**
         * Capitalizes the first letter of a string
         */
        private String capitalize(String str) {
            if (str == null || str.isEmpty()) {
                return str;
            }
            return Character.toUpperCase(str.charAt(0)) + str.substring(1);
        }
        
        /**
         * Generates suggested implementation for a BDD step
         */
        private String generateImplementation(String step, StepType stepType) {
            // Basic template based on step type
            StringBuilder code = new StringBuilder();
            
            String methodName = suggestedMethodName;
            String description = step.replaceFirst("^(Given|When|Then|And|But)\\s+", "").trim();
            
            code.append("@CSSmartTestStep(description = \"").append(description).append("\"");
            
            switch (stepType) {
                case GIVEN:
                    code.append(", category = StepCategory.SETUP");
                    break;
                case WHEN:
                    code.append(", category = StepCategory.ACTION");
                    break;
                case THEN:
                    code.append(", category = StepCategory.VERIFICATION");
                    break;
                default:
                    // Use default category
            }
            
            code.append(")\n");
            code.append("public void ").append(methodName).append("() {\n");
            
            // Add stub implementation based on step type
            switch (stepType) {
                case GIVEN:
                    code.append("    // TODO: Implement precondition setup\n");
                    break;
                case WHEN:
                    // Try to detect common actions
                    if (step.toLowerCase().contains("click")) {
                        code.append("    // TODO: Implement click action\n");
                        code.append("    // pageObject.clickButton();\n");
                    } else if (step.toLowerCase().contains("enter") || step.toLowerCase().contains("type")) {
                        code.append("    // TODO: Implement text entry\n");
                        code.append("    // pageObject.enterText(\"text\");\n");
                    } else if (step.toLowerCase().contains("select")) {
                        code.append("    // TODO: Implement selection\n");
                        code.append("    // pageObject.selectOption(\"option\");\n");
                    } else {
                        code.append("    // TODO: Implement action\n");
                    }
                    break;
                case THEN:
                    code.append("    // TODO: Implement verification\n");
                    code.append("    // assertThat(actual).isEqualTo(expected);\n");
                    break;
                default:
                    code.append("    // TODO: Implement step\n");
            }
            
            code.append("}");
            
            return code.toString();
        }
    }
}


package com.cssmart.framework.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for defining a TestNG test as a BDD scenario
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSSmartScenario {
    /**
     * Feature name this scenario belongs to
     */
    String feature();
    
    /**
     * Scenario description
     */
    String scenario() default "";
    
    /**
     * BDD steps to execute in this scenario
     */
    String[] steps();
    
    /**
     * Tags associated with this scenario
     */
    String[] tags() default {};
}


package com.cssmart.framework.bdd;

import com.cssmart.framework.annotation.CSSmartScenario;
import com.cssmart.framework.logging.CSSmartLogger;
import org.testng.IHookCallBack;
import org.testng.IHookable;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Bridge between TestNG and BDD execution
 * Allows TestNG tests to be executed as BDD scenarios
 */
public class CSSmartBddTestNGBridge implements IHookable {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartBddTestNGBridge.class);
    
    // Global step matcher instance
    private static final SmartStepMatcher stepMatcher = new SmartStepMatcher();
    
    // Map of features to scenarios
    private static final Map<String, List<ScenarioInfo>> featureMap = new HashMap<>();
    
    // Current scenario being executed
    private ScenarioInfo currentScenario;
    
    /**
     * Registers step definition classes
     */
    public void registerStepDefinitions(Object... stepDefinitionInstances) {
        for (Object instance : stepDefinitionInstances) {
            stepMatcher.registerSteps(instance);
        }
    }
    
    /**
     * Sets up the scenario before method execution
     */
    @BeforeMethod
    public void setupBddScenario(Method method) {
        CSSmartScenario scenarioAnnotation = method.getAnnotation(CSSmartScenario.class);
        
        if (scenarioAnnotation != null) {
            String featureName = scenarioAnnotation.feature();
            String scenarioName = !scenarioAnnotation.scenario().isEmpty() ? 
                                  scenarioAnnotation.scenario() : method.getName();
            String[] steps = scenarioAnnotation.steps();
            String[] tags = scenarioAnnotation.tags();
            
            currentScenario = new ScenarioInfo(featureName, scenarioName, steps, tags);
            
            // Add to feature map for reporting
            featureMap.computeIfAbsent(featureName, k -> new ArrayList<>()).add(currentScenario);
            
            // Log scenario start
            logger.info("Starting BDD Scenario: " + scenarioName + " [Feature: " + featureName + "]");
        }
    }
    
    /**
     * Cleans up after scenario execution
     */
    @AfterMethod
    public void tearDownBddScenario(ITestResult result) {
        if (currentScenario != null) {
            // Update scenario status
            currentScenario.setStatus(result.isSuccess() ? "Passed" : "Failed");
            
            if (!result.isSuccess()) {
                currentScenario.setFailureCause(result.getThrowable());
            }
            
            // Log scenario completion
            logger.info("Completed BDD Scenario: " + currentScenario.getScenarioName() + 
                       " [Status: " + currentScenario.getStatus() + "]");
            
            currentScenario = null;
        }
    }
    
    /**
     * IHookable implementation to intercept test execution
     * and execute BDD steps instead
     */
    @Override
    public void run(IHookCallBack callBack, ITestResult testResult) {
        Method method = testResult.getMethod().getConstructorOrMethod().getMethod();
        CSSmartScenario scenarioAnnotation = method.getAnnotation(CSSmartScenario.class);
        
        if (scenarioAnnotation != null) {
            // Execute BDD scenario
            try {
                executeScenario(scenarioAnnotation.steps());
                testResult.setStatus(ITestResult.SUCCESS);
            } catch (Throwable e) {
                testResult.setStatus(ITestResult.FAILURE);
                testResult.setThrowable(e);
            }
        } else {
            // Standard execution for non-BDD tests
            callBack.runTestMethod(testResult);
        }
    }
    
    /**
     * Executes a BDD scenario with the given steps
     */
    private void executeScenario(String[] steps) throws Exception {
        for (String step : steps) {
            logger.info("Executing step: " + step);
            
            try {
                stepMatcher.executeStep(step);
                
                if (currentScenario != null) {
                    currentScenario.addStepResult(step, "Passed", null);
                }
            } catch (Exception e) {
                if (currentScenario != null) {
                    currentScenario.addStepResult(step, "Failed", e);
                }
                throw e;
            }
        }
    }
    
    /**
     * Generates Gherkin feature files from executed scenarios
     */
    public void generateFeatureFiles(String outputDirectory) {
        File outputDir = new File(outputDirectory);
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            logger.error("Failed to create output directory: " + outputDirectory);
            return;
        }
        
        for (Map.Entry<String, List<ScenarioInfo>> entry : featureMap.entrySet()) {
            String featureName = entry.getKey();
            List<ScenarioInfo> scenarios = entry.getValue();
            
            // Generate feature file content
            StringBuilder featureContent = new StringBuilder();
            featureContent.append("Feature: ").append(featureName).append("\n\n");
            
            for (ScenarioInfo scenario : scenarios) {
                // Add tags
                if (scenario.getTags().length > 0) {
                    for (String tag : scenario.getTags()) {
                        featureContent.append("@").append(tag).append(" ");
                    }
                    featureContent.append("\n");
                }
                
                featureContent.append("Scenario: ").append(scenario.getScenarioName()).append("\n");
                
                for (String step : scenario.getSteps()) {
                    featureContent.append("  ").append(step).append("\n");
                }
                
                featureContent.append("\n");
            }
            
            // Write to file
            String fileName = featureName.replaceAll("[^a-zA-Z0-9]", "_").toLowerCase() + ".feature";
            File featureFile = new File(outputDir, fileName);
            
            try (FileWriter writer = new FileWriter(featureFile)) {
                writer.write(featureContent.toString());
                logger.info("Generated feature file: " + featureFile.getAbsolutePath());
            } catch (IOException e) {
                logger.error("Failed to write feature file: " + fileName, e);
            }
        }
    }
    
    /**
     * Generates HTML test report
     */
    public void generateHTMLReport(String outputDirectory) {
        File outputDir = new File(outputDirectory);
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            logger.error("Failed to create output directory: " + outputDirectory);
            return;
        }
        
        File reportFile = new File(outputDir, "bdd-report-" + 
            new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date()) + ".html");
        
        try (FileWriter writer = new FileWriter(reportFile)) {
            StringBuilder html = new StringBuilder();
            html.append("<!DOCTYPE html>\n");
            html.append("<html lang=\"en\">\n");
            html.append("<head>\n");
            html.append("    <meta charset=\"UTF-8\">\n");
            html.append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
            html.append("    <title>BDD Test Report</title>\n");
            html.append("    <style>\n");
            html.append("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
            html.append("        h1 { color: #2c3e50; }\n");
            html.append("        .feature { margin-bottom: 30px; border: 1px solid #ddd; border-radius: 5px; padding: 15px; }\n");
            html.append("        .feature-title { background-color: #f8f9fa; padding: 10px; margin-top: 0; }\n");
            html.append("        .scenario { margin: 15px 0; border-left: 4px solid #6c757d; padding-left: 15px; }\n");
            html.append("        .scenario.passed { border-left-color: #28a745; }\n");
            html.append("        .scenario.failed { border-left-color: #dc3545; }\n");
            html.append("        .step { margin: 5px 0; padding: 5px; }\n");
            html.append("        .step.passed { color: #28a745; }\n");
            html.append("        .step.failed { color: #dc3545; }\n");
            html.append("        .error-message { background-color: #f8d7da; color: #721c24; padding: 10px; margin: 5px 0; border-radius: 3px; }\n");
            html.append("        .tag { display: inline-block; background-color: #17a2b8; color: white; padding: 2px 8px; border-radius: 10px; margin-right: 5px; font-size: 0.8em; }\n");
            html.append("    </style>\n");
            html.append("</head>\n");
            html.append("<body>\n");
            html.append("    <h1>BDD Test Report</h1>\n");
            
            // Summary
            int totalScenarios = 0;
            int passedScenarios = 0;
            
            for (List<ScenarioInfo> scenarios : featureMap.values()) {
                totalScenarios += scenarios.size();
                for (ScenarioInfo scenario : scenarios) {
                    if ("Passed".equals(scenario.getStatus())) {
                        passedScenarios++;
                    }
                }
            }
            
            html.append("    <div class=\"summary\">\n");
            html.append("        <p><strong>Total Features:</strong> ").append(featureMap.size()).append("</p>\n");
            html.append("        <p><strong>Total Scenarios:</strong> ").append(totalScenarios).append("</p>\n");
            html.append("        <p><strong>Passed Scenarios:</strong> ").append(passedScenarios).append("</p>\n");
            html.append("        <p><strong>Failed Scenarios:</strong> ").append(totalScenarios - passedScenarios).append("</p>\n");
            html.append("    </div>\n");
            
            // Features and Scenarios
            for (Map.Entry<String, List<ScenarioInfo>> entry : featureMap.entrySet()) {
                String featureName = entry.getKey();
                List<ScenarioInfo> scenarios = entry.getValue();
                
                html.append("    <div class=\"feature\">\n");
                html.append("        <h2 class=\"feature-title\">Feature: ").append(featureName).append("</h2>\n");
                
                for (ScenarioInfo scenario : scenarios) {
                    String scenarioStatus = scenario.getStatus() != null ? scenario.getStatus() : "Unknown";
                    html.append("        <div class=\"scenario ").append(scenarioStatus.toLowerCase()).append("\">\n");
                    
                    // Tags
                    if (scenario.getTags().length > 0) {
                        html.append("            <div class=\"tags\">\n");
                        for (String tag : scenario.getTags()) {
                            html.append("                <span class=\"tag\">").append(tag).append("</span>\n");
                        }
                        html.append("            </div>\n");
                    }
                    
                    html.append("            <h3>Scenario: ").append(scenario.getScenarioName())
                        .append(" <span style=\"color: ")
                        .append("Passed".equals(scenarioStatus) ? "#28a745" : "#dc3545")
                        .append(";\">").append(scenarioStatus).append("</span></h3>\n");
                    
                    // Steps
                    List<StepResult> stepResults = scenario.getStepResults();
                    if (stepResults.isEmpty()) {
                        // If no step results recorded, just list the steps
                        for (String step : scenario.getSteps()) {
                            html.append("            <div class=\"step\">").append(step).append("</div>\n");
                        }
                    } else {
                        // If step results available, show them with status
                        for (StepResult result : stepResults) {
                            html.append("            <div class=\"step ").append(result.getStatus().toLowerCase())
                                .append("\">").append(result.getStep()).append("</div>\n");
                            
                            if (result.getException() != null) {
                                html.append("            <div class=\"error-message\">")
                                    .append(escapeHtml(result.getException().toString())).append("</div>\n");
                            }
                        }
                    }
                    
                    html.append("        </div>\n");
                }
                
                html.append("    </div>\n");
            }
            
            html.append("</body>\n");
            html.append("</html>");
            
            writer.write(html.toString());
            logger.info("Generated HTML report: " + reportFile.getAbsolutePath());
        } catch (IOException e) {
            logger.error("Failed to write HTML report", e);
        }
    }
    
    /**
     * Escapes HTML special characters
     */
    private String escapeHtml(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#39;");
    }
    
    /**
     * Class to store information about a scenario
     */
    private static class ScenarioInfo {
        private final String featureName;
        private final String scenarioName;
        private final String[] steps;
        private final String[] tags;
        private String status;
        private Throwable failureCause;
        private final List<StepResult> stepResults = new ArrayList<>();
        
        public ScenarioInfo(String featureName, String scenarioName, String[] steps, String[] tags) {
            this.featureName = featureName;
            this.scenarioName = scenarioName;
            this.steps = steps;
            this.tags = tags;
        }
        
        public String getFeatureName() {
            return featureName;
        }
        
        public String getScenarioName() {
            return scenarioName;
        }
        
        public String[] getSteps() {
            return steps;
        }
        
        public String[] getTags() {
            return tags;
        }
        
        public String getStatus() {
            return status;
        }
        
        public void setStatus(String status) {
            this.status = status;
        }
        
        public Throwable getFailureCause() {
            return failureCause;
        }
        
        public void setFailureCause(Throwable failureCause) {
            this.failureCause = failureCause;
        }
        
        public void addStepResult(String step, String status, Throwable exception) {
            stepResults.add(new StepResult(step, status, exception));
        }
        
        public List<StepResult> getStepResults() {
            return stepResults;
        }
    }
    
    /**
     * Class to store results of a step execution
     */
    private static class StepResult {
        private final String step;
        private final String status;
        private final Throwable exception;
        
        public StepResult(String step, String status, Throwable exception) {
            this.step = step;
            this.status = status;
            this.exception = exception;
        }
        
        public String getStep() {
            return step;
        }
        
        public String getStatus() {
            return status;
        }
        
        public Throwable getException() {
            return exception;
        }
    }
}



package com.cssmart.framework.ai;

import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.stream.Collectors;

/**
 * AI-powered test analysis and recommendation engine
 */
public class CSSmartAITestRecommender {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartAITestRecommender.class);
    
    // Maximum depth for exploring page elements
    private static final int MAX_EXPLORATION_DEPTH = 5;
    
    // Maximum number of elements to explore per page
    private static final int MAX_ELEMENTS_PER_PAGE = 50;
    
    // Timeout for page analysis in milliseconds
    private static final int ANALYSIS_TIMEOUT = 30000;
    
    /**
     * Finds optimal test paths through an application
     */
    public List<TestPath> findOptimalTestPaths(WebDriver driver, String startUrl) {
        logger.info("Starting application flow analysis from: " + startUrl);
        
        List<TestPath> testPaths = new ArrayList<>();
        Set<String> visitedUrls = new HashSet<>();
        
        try {
            // Navigate to the start URL
            driver.get(startUrl);
            visitedUrls.add(normalizeUrl(startUrl));
            
            // Start exploring from the initial page
            explorePage(driver, null, 0, visitedUrls, testPaths, new ArrayDeque<>());
            
            // Sort paths by priority score
            testPaths.sort(Comparator.comparing(TestPath::getPriorityScore).reversed());
            
            logger.info("Completed application flow analysis. Found " + testPaths.size() + " test paths");
            return testPaths;
            
        } catch (Exception e) {
            logger.error("Error in application flow analysis", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Recursively explores pages to find test paths
     */
    private void explorePage(WebDriver driver, WebElement sourceElement, int depth, 
                            Set<String> visitedUrls, List<TestPath> testPaths, 
                            Deque<PageAction> currentPath) {
        
        if (depth >= MAX_EXPLORATION_DEPTH) {
            // Maximum exploration depth reached
            if (!currentPath.isEmpty()) {
                testPaths.add(new TestPath(new ArrayList<>(currentPath)));
            }
            return;
        }
        
        String currentUrl = normalizeUrl(driver.getCurrentUrl());
        
        // Record the navigation action if this is not the first page
        if (sourceElement != null) {
            PageAction action = new PageAction(
                sourceElement.getTagName(),
                getElementDescription(sourceElement),
                ActionType.NAVIGATE,
                currentUrl
            );
            currentPath.add(action);
        }
        
        // Analyze the current page
        PageAnalysis pageAnalysis = analyzePage(driver);
        
        // Record significant forms on the page
        for (FormInfo form : pageAnalysis.getForms()) {
            testPaths.add(createFormTestPath(currentPath, form));
        }
        
        // Explore interactive elements
        List<WebElement> interactiveElements = pageAnalysis.getInteractiveElements();
        
        for (WebElement element : interactiveElements) {
            // Skip elements that would navigate away from the page
            if (isNavigationElement(element) && depth < MAX_EXPLORATION_DEPTH - 1) {
                try {
                    // Store current URL before clicking
                    String beforeUrl = driver.getCurrentUrl();
                    
                    // Clone the current path
                    Deque<PageAction> pathCopy = new ArrayDeque<>(currentPath);
                    
                    // Click the element
                    element.click();
                    
                    // Wait for page to load
                    Thread.sleep(1000);
                    
                    // Get the new URL
                    String afterUrl = driver.getCurrentUrl();
                    
                    // If URL changed and not visited before, explore the new page
                    String normalizedUrl = normalizeUrl(afterUrl);
                    if (!normalizedUrl.equals(normalizeUrl(beforeUrl)) && !visitedUrls.contains(normalizedUrl)) {
                        visitedUrls.add(normalizedUrl);
                        explorePage(driver, element, depth + 1, visitedUrls, testPaths, pathCopy);
                    }
                    
                    // Navigate back
                    driver.navigate().back();
                    Thread.sleep(500);
                    
                } catch (Exception e) {
                    logger.debug("Error exploring element: " + e.getMessage());
                    // Continue with next element
                }
            } else {
                // For non-navigation elements, add interaction test paths
                PageAction action = new PageAction(
                    element.getTagName(),
                    getElementDescription(element),
                    determineActionType(element),
                    null
                );
                
                Deque<PageAction> pathCopy = new ArrayDeque<>(currentPath);
                pathCopy.add(action);
                
                testPaths.add(new TestPath(new ArrayList<>(pathCopy)));
            }
        }
    }
    
    /**
     * Analyzes a page to identify forms, interactive elements, and other key components
     */
    private PageAnalysis analyzePage(WebDriver driver) {
        PageAnalysis analysis = new PageAnalysis();
        
        try {
            // Get page title
            analysis.setTitle(driver.getTitle());
            
            // Get page URL
            analysis.setUrl(driver.getCurrentUrl());
            
            // Find forms
            List<WebElement> forms = driver.findElements(By.tagName("form"));
            for (WebElement form : forms) {
                FormInfo formInfo = analyzeForm(form);
                analysis.addForm(formInfo);
            }
            
            // Find interactive elements
            List<WebElement> interactiveElements = findInteractiveElements(driver);
            analysis.setInteractiveElements(interactiveElements);
            
            // Find potential validation points
            List<WebElement> validationPoints = findValidationPoints(driver);
            analysis.setValidationPoints(validationPoints);
            
            return analysis;
        } catch (Exception e) {
            logger.error("Error analyzing page", e);
            return analysis;
        }
    }
    
    /**
     * Analyzes a form to identify its fields and purpose
     */
    private FormInfo analyzeForm(WebElement form) {
        FormInfo formInfo = new FormInfo();
        
        try {
            // Get form ID or name
            String formId = form.getAttribute("id");
            String formName = form.getAttribute("name");
            
            formInfo.setId(formId != null ? formId : "");
            formInfo.setName(formName != null ? formName : "");
            
            // Try to determine form purpose
            formInfo.setPurpose(determineFormPurpose(form));
            
            // Find form fields
            List<WebElement> inputElements = form.findElements(By.tagName("input"));
            List<WebElement> selectElements = form.findElements(By.tagName("select"));
            List<WebElement> textareaElements = form.findElements(By.tagName("textarea"));
            
            // Add input fields
            for (WebElement input : inputElements) {
                String type = input.getAttribute("type");
                if (type == null) type = "text";
                
                if (!"submit".equals(type) && !"button".equals(type) && !"reset".equals(type)) {
                    FieldInfo field = new FieldInfo();
                    field.setName(input.getAttribute("name"));
                    field.setType(type);
                    field.setRequired(input.getAttribute("required") != null);
                    field.setElement(input);
                    
                    formInfo.addField(field);
                }
            }
            
            // Add select fields
            for (WebElement select : selectElements) {
                FieldInfo field = new FieldInfo();
                field.setName(select.getAttribute("name"));
                field.setType("select");
                field.setRequired(select.getAttribute("required") != null);
                field.setElement(select);
                
                // Get options
                List<WebElement> options = select.findElements(By.tagName("option"));
                for (WebElement option : options) {
                    field.addOption(option.getAttribute("value"), option.getText());
                }
                
                formInfo.addField(field);
            }
            
            // Add textarea fields
            for (WebElement textarea : textareaElements) {
                FieldInfo field = new FieldInfo();
                field.setName(textarea.getAttribute("name"));
                field.setType("textarea");
                field.setRequired(textarea.getAttribute("required") != null);
                field.setElement(textarea);
                
                formInfo.addField(field);
            }
            
            // Find submit button
            List<WebElement> submitButtons = form.findElements(By.cssSelector(
                "input[type='submit'], button[type='submit'], button:not([type])"));
            
            if (!submitButtons.isEmpty()) {
                formInfo.setSubmitButton(submitButtons.get(0));
            }
            
            return formInfo;
        } catch (Exception e) {
            logger.error("Error analyzing form", e);
            return formInfo;
        }
    }
    
    /**
     * Determines the purpose of a form
     */
    private String determineFormPurpose(WebElement form) {
        String formHtml = form.getAttribute("outerHTML").toLowerCase();
        
        if (formHtml.contains("login") || formHtml.contains("sign in") || 
            formHtml.contains("signin") || formHtml.contains("log in")) {
            return "Login";
        } else if (formHtml.contains("register") || formHtml.contains("sign up") || 
                  formHtml.contains("signup") || formHtml.contains("create account")) {
            return "Registration";
        } else if (formHtml.contains("search")) {
            return "Search";
        } else if (formHtml.contains("contact") || formHtml.contains("inquiry") || 
                  formHtml.contains("enquiry")) {
            return "Contact";
        } else if (formHtml.contains("checkout") || formHtml.contains("payment") || 
                  formHtml.contains("billing")) {
            return "Checkout";
        } else if (formHtml.contains("profile") || formHtml.contains("settings") || 
                  formHtml.contains("account")) {
            return "Profile";
        } else if (formHtml.contains("password") && (formHtml.contains("reset") || 
                  formHtml.contains("forgot") || formHtml.contains("change"))) {
            return "Password Reset";
        } else {
            return "Generic Form";
        }
    }
    
    /**
     * Finds interactive elements on a page
     */
    private List<WebElement> findInteractiveElements(WebDriver driver) {
        List<WebElement> elements = new ArrayList<>();
        
        try {
            // Find clickable elements
            elements.addAll(driver.findElements(By.cssSelector(
                "a, button, input[type='button'], input[type='submit'], [role='button'], " +
                "[onclick], [class*='btn'], [class*='button']")));
            
            // Find form elements
            elements.addAll(driver.findElements(By.cssSelector(
                "input:not([type='hidden']), select, textarea")));
            
            // Limit to visible elements
            elements = elements.stream()
                .filter(e -> {
                    try {
                        return e.isDisplayed();
                    } catch (Exception ex) {
                        return false;
                    }
                })
                .limit(MAX_ELEMENTS_PER_PAGE)
                .collect(Collectors.toList());
            
            return elements;
        } catch (Exception e) {
            logger.error("Error finding interactive elements", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Finds potential validation points (elements that display messages or feedback)
     */
    private List<WebElement> findValidationPoints(WebDriver driver) {
        List<WebElement> elements = new ArrayList<>();
        
        try {
            // Find elements that typically contain validation messages
            elements.addAll(driver.findElements(By.cssSelector(
                ".error, .success, .message, .alert, .notification, " +
                "[role='alert'], [aria-live], .validation-message")));
            
            return elements;
        } catch (Exception e) {
            logger.error("Error finding validation points", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Checks if an element is likely to cause navigation
     */
    private boolean isNavigationElement(WebElement element) {
        String tagName = element.getTagName().toLowerCase();
        
        if ("a".equals(tagName)) {
            return true;
        }
        
        if ("button".equals(tagName) || "input".equals(tagName)) {
            String type = element.getAttribute("type");
            String onClick = element.getAttribute("onclick");
            
            // Buttons with navigation-related attributes
            return (onClick != null && (onClick.contains("location") || onClick.contains("href"))) ||
                  ("submit".equals(type) && element.findElement(By.xpath("./ancestor::form")) != null);
        }
        
        return false;
    }
    
    /**
     * Determines the appropriate action type for an element
     */
    private ActionType determineActionType(WebElement element) {
        String tagName = element.getTagName().toLowerCase();
        
        switch (tagName) {
            case "a":
                return ActionType.NAVIGATE;
                
            case "button":
            case "input":
                String type = element.getAttribute("type");
                if ("checkbox".equals(type) || "radio".equals(type)) {
                    return ActionType.SELECT;
                } else if ("submit".equals(type)) {
                    return ActionType.SUBMIT;
                } else {
                    return ActionType.CLICK;
                }
                
            case "select":
                return ActionType.SELECT;
                
            case "textarea":
            case "input":
                return ActionType.ENTER_TEXT;
                
            default:
                return ActionType.CLICK;
        }
    }
    
    /**
     * Gets a descriptive identifier for an element
     */
    private String getElementDescription(WebElement element) {
        // Try various attributes in priority order
        String[] attributes = {"id", "name", "aria-label", "title", "placeholder"};
        
        for (String attribute : attributes) {
            String value = element.getAttribute(attribute);
            if (value != null && !value.isEmpty()) {
                return value;
            }
        }
        
        // Try text content
        String text = element.getText();
        if (text != null && !text.isEmpty()) {
            // Truncate long text
            if (text.length() > 30) {
                text = text.substring(0, 27) + "...";
            }
            return text;
        }
        
        // Fallback to tag name and position
        return element.getTagName() + "_element";
    }
    
    /**
     * Creates a test path for form interaction
     */
    private TestPath createFormTestPath(Deque<PageAction> navigationPath, FormInfo form) {
        List<PageAction> actions = new ArrayList<>(navigationPath);
        
        // Add actions for each field
        for (FieldInfo field : form.getFields()) {
            ActionType actionType;
            String value = "";
            
            switch (field.getType()) {
                case "checkbox":
                case "radio":
                    actionType = ActionType.SELECT;
                    value = "true";
                    break;
                case "select":
                    actionType = ActionType.SELECT;
                    if (!field.getOptions().isEmpty()) {
                        value = field.getOptions().keySet().iterator().next();
                    }
                    break;
                default:
                    actionType = ActionType.ENTER_TEXT;
                    value = generateTestDataForField(field);
            }
            
            PageAction action = new PageAction(
                field.getElement().getTagName(),
                field.getName(),
                actionType,
                value
            );
            
            actions.add(action);
        }
        
        // Add submit action if submit button exists
        if (form.getSubmitButton() != null) {
            PageAction submitAction = new PageAction(
                form.getSubmitButton().getTagName(),
                getElementDescription(form.getSubmitButton()),
                ActionType.SUBMIT,
                null
            );
            
            actions.add(submitAction);
        }
        
        // Create and return the test path
        TestPath path = new TestPath(actions);
        
        // Set path metadata
        path.setName(form.getPurpose() + " Test");
        path.setDescription("Test path for " + form.getPurpose() + " form");
        
        // Set priority based on form type
        switch (form.getPurpose()) {
            case "Login":
            case "Registration":
            case "Checkout":
                path.setPriorityScore(5);
                break;
            case "Password Reset":
            case "Profile":
                path.setPriorityScore(4);
                break;
            case "Search":
                path.setPriorityScore(3);
                break;
            default:
                path.setPriorityScore(2);
        }
        
        return path;
    }
    
    /**
     * Generates test data for a form field
     */
    private String generateTestDataForField(FieldInfo field) {
        String name = field.getName() != null ? field.getName().toLowerCase() : "";
        String type = field.getType();
        
        // Generate data based on field name and type
        if (name.contains("email")) {
            return "test_user@example.com";
        } else if (name.contains("password")) {
            return "TestPassword123!";
        } else if (name.contains("username") || name.contains("user")) {
            return "testuser";
        } else if (name.contains("name")) {
            if (name.contains("first") || name.contains("fname")) {
                return "John";
            } else if (name.contains("last") || name.contains("lname")) {
                return "Doe";
            } else {
                return "John Doe";
            }
        } else if (name.contains("phone") || name.contains("mobile")) {
            return "1234567890";
        } else if (name.contains("address")) {
            return "123 Test Street";
        } else if (name.contains("city")) {
            return "Test City";
        } else if (name.contains("state") || name.contains("province")) {
            return "Test State";
        } else if (name.contains("zip") || name.contains("postal")) {
            return "12345";
        } else if (name.contains("country")) {
            return "United States";
        } else if (name.contains("search") || name.contains("query")) {
            return "test search";
        } else if ("date".equals(type) || name.contains("date")) {
            return "2023-01-01";
        } else if ("number".equals(type) || name.contains("number")) {
            return "123";
        } else {
            return "Test Value";
        }
    }
    
    /**
     * Normalizes a URL by removing trailing slashes and fragments
     */
    private String normalizeUrl(String url) {
        String normalized = url;
        
        // Remove fragment
        int fragmentIndex = normalized.indexOf('#');
        if (fragmentIndex != -1) {
            normalized = normalized.substring(0, fragmentIndex);
        }
        
        // Remove trailing slash
        if (normalized.endsWith("/")) {
            normalized = normalized.substring(0, normalized.length() - 1);
        }
        
        return normalized;
    }
    
    /**
     * Identifies edge cases and potential issues in test paths
     */
    public List<EdgeCase> identifyEdgeCases(List<TestPath> testPaths) {
        List<EdgeCase> edgeCases = new ArrayList<>();
        
        // Analyze each test path for edge cases
        for (TestPath path : testPaths) {
            // Check for login paths to generate authentication edge cases
            if (isLoginPath(path)) {
                edgeCases.add(new EdgeCase(
                    "Invalid Login",
                    "Test login with invalid credentials",
                    modifyLoginPath(path, true, false),
                    EdgeCaseType.AUTHENTICATION,
                    5
                ));
                
                edgeCases.add(new EdgeCase(
                    "Empty Login",
                    "Test login with empty credentials",
                    modifyLoginPath(path, false, true),
                    EdgeCaseType.VALIDATION,
                    4
                ));
            }
            
            // Check for form submissions to generate validation edge cases
            if (containsFormSubmission(path)) {
                edgeCases.add(new EdgeCase(
                    "Empty Form Submission",
                    "Test form submission with empty required fields",
                    createEmptyFormPath(path),
                    EdgeCaseType.VALIDATION,
                    4
                ));
                
                edgeCases.add(new EdgeCase(
                    "Invalid Data Submission",
                    "Test form submission with invalid data",
                    createInvalidDataPath(path),
                    EdgeCaseType.VALIDATION,
                    3
                ));
            }
            
            // Check for navigation paths to generate navigation edge cases
            if (containsNavigation(path)) {
                edgeCases.add(new EdgeCase(
                    "Back Navigation Test",
                    "Test navigation flow with back/forward operations",
                    createNavigationVariant(path),
                    EdgeCaseType.NAVIGATION,
                    2
                ));
            }
        }
        
        // Add generic edge cases
        edgeCases.add(new EdgeCase(
            "Session Timeout",
            "Test application behavior when session times out",
            createSessionTimeoutTest(),
            EdgeCaseType.SECURITY,
            5
        ));
        
        edgeCases.add(new EdgeCase(
            "Concurrent Access",
            "Test application behavior with concurrent access",
            createConcurrentAccessTest(),
            EdgeCaseType.PERFORMANCE,
            4
        ));
        
        // Sort by priority
        edgeCases.sort(Comparator.comparing(EdgeCase::getPriority).reversed());
        
        return edgeCases;
    }
    
    /**
     * Checks if a test path is for login
     */
    private boolean isLoginPath(TestPath path) {
        return path.getName() != null && path.getName().contains("Login");
    }
    
    /**
     * Modifies a login path to test invalid login scenarios
     */
    private TestPath modifyLoginPath(TestPath originalPath, boolean invalidCredentials, boolean emptyCredentials) {
        List<PageAction> actions = new ArrayList<>();
        
        for (PageAction action : originalPath.getActions()) {
            if (action.getActionType() == ActionType.ENTER_TEXT) {
                String fieldName = action.getElementDescription().toLowerCase();
                
                if (fieldName.contains("email") || fieldName.contains("username") || fieldName.contains("user")) {
                    PageAction modified = new PageAction(
                        action.getElementTag(),
                        action.getElementDescription(),
                        action.getActionType(),
                        emptyCredentials ? "" : (invalidCredentials ? "invalid_user@example.com" : action.getValue())
                    );
                    actions.add(modified);
                } else if (fieldName.contains("password") || fieldName.contains("pass")) {
                    PageAction modified = new PageAction(
                        action.getElementTag(),
                        action.getElementDescription(),
                        action.getActionType(),
                        emptyCredentials ? "" : (invalidCredentials ? "InvalidPassword123!" : action.getValue())
                    );
                    actions.add(modified);
                } else {
                    actions.add(action);
                }
            } else {
                actions.add(action);
            }
        }
        
        TestPath modified = new TestPath(actions);
        modified.setName(emptyCredentials ? "Empty Login Test" : "Invalid Login Test");
        modified.setDescription(emptyCredentials ? 
            "Test login with empty credentials" : 
            "Test login with invalid credentials");
        modified.setPriorityScore(4);
        
        return modified;
    }
    
    /**
     * Checks if a test path contains a form submission
     */
    private boolean containsFormSubmission(TestPath path) {
        return path.getActions().stream()
            .anyMatch(action -> action.getActionType() == ActionType.SUBMIT);
    }
    
    /**
     * Creates a test path with empty form fields
     */
    private TestPath createEmptyFormPath(TestPath originalPath) {
        List<PageAction> actions = new ArrayList<>();
        
        for (PageAction action : originalPath.getActions()) {
            if (action.getActionType() == ActionType.ENTER_TEXT) {
                PageAction modified = new PageAction(
                    action.getElementTag(),
                    action.getElementDescription(),
                    action.getActionType(),
                    ""
                );
                actions.add(modified);
            } else {
                actions.add(action);
            }
        }
        
        TestPath modified = new TestPath(actions);
        modified.setName("Empty Form Submission Test");
        modified.setDescription("Test form submission with empty fields");
        modified.setPriorityScore(3);
        
        return modified;
    }
    
    /**
     * Creates a test path with invalid form data
     */
    private TestPath createInvalidDataPath(TestPath originalPath) {
        List<PageAction> actions = new ArrayList<>();
        
        for (PageAction action : originalPath.getActions()) {
            if (action.getActionType() == ActionType.ENTER_TEXT) {
                String fieldName = action.getElementDescription().toLowerCase();
                String invalidValue = "";
                
                if (fieldName.contains("email")) {
                    invalidValue = "invalid-email";
                } else if (fieldName.contains("phone") || fieldName.contains("mobile")) {
                    invalidValue = "abcdefghij";
                } else if (fieldName.contains("zip") || fieldName.contains("postal")) {
                    invalidValue = "abcde";
                } else if (fieldName.contains("date")) {
                    invalidValue = "invalid-date";
                } else if (fieldName.contains("number")) {
                    invalidValue = "not-a-number";
                } else {
                    // Generate a value that's likely too long
                    invalidValue = "This is an extremely long input value that is likely to exceed the maximum allowed length for most fields in a typical form";
                }
                
                PageAction modified = new PageAction(
                    action.getElementTag(),
                    action.getElementDescription(),
                    action.getActionType(),
                    invalidValue
                );
                actions.add(modified);
            } else {
                actions.add(action);
            }
        }
        
        TestPath modified = new TestPath(actions);
        modified.setName("Invalid Data Submission Test");
        modified.setDescription("Test form submission with invalid data");
        modified.setPriorityScore(3);
        
        return modified;
    }
    
    /**
     * Checks if a test path contains navigation actions
     */
    private boolean containsNavigation(TestPath path) {
        return path.getActions().stream()
            .anyMatch(action -> action.getActionType() == ActionType.NAVIGATE);
    }
    
    /**
     * Creates a test path variant with back/forward navigation
     */
    private TestPath createNavigationVariant(TestPath originalPath) {
        List<PageAction> actions = new ArrayList<>(originalPath.getActions());
        
        // Add browser navigation actions
        actions.add(new PageAction("browser", "Browser Navigation", ActionType.BROWSER_BACK, null));
        actions.add(new PageAction("browser", "Browser Navigation", ActionType.BROWSER_FORWARD, null));
        
        TestPath modified = new TestPath(actions);
        modified.setName("Navigation Flow Test");
        modified.setDescription("Test navigation with back/forward operations");
        modified.setPriorityScore(2);
        
        return modified;
    }
    
    /**
     * Creates a test for session timeout
     */
    private TestPath createSessionTimeoutTest() {
        List<PageAction> actions = new ArrayList<>();
        
        actions.add(new PageAction("session", "Session Management", ActionType.WAIT, "timeout"));
        actions.add(new PageAction("page", "Page Refresh", ActionType.REFRESH, null));
        actions.add(new PageAction("verify", "Verification", ActionType.VERIFY, "session expired message"));
        
        TestPath path = new TestPath(actions);
        path.setName("Session Timeout Test");
        path.setDescription("Test application behavior when session times out");
        path.setPriorityScore(5);
        
        return path;
    }
    
    /**
     * Creates a test for concurrent access
     */
    private TestPath createConcurrentAccessTest() {
        List<PageAction> actions = new ArrayList<>();
        
        actions.add(new PageAction("browser", "Multiple Browser", ActionType.MULTI_SESSION, "2"));
        actions.add(new PageAction("session", "Concurrent Access", ActionType.CONCURRENT, "same resource"));
        actions.add(new PageAction("verify", "Verification", ActionType.VERIFY, "data integrity"));
        
        TestPath path = new TestPath(actions);
        path.setName("Concurrent Access Test");
        path.setDescription("Test application behavior with concurrent access");
        path.setPriorityScore(4);
        
        return path;
    }
    
    /**
     * Performs risk analysis on the identified test paths to determine test priority
     */
    public List<RiskAnalysis> performRiskAnalysis(List<TestPath> testPaths) {
        List<RiskAnalysis> riskAnalyses = new ArrayList<>();
        
        // Calculate risk factors for each test path
        for (TestPath path : testPaths) {
            RiskAnalysis analysis = new RiskAnalysis();
            analysis.setTestPath(path);
            
            // Set name based on path
            analysis.setName(path.getName() != null ? path.getName() : "Test path risk analysis");
            
            // Calculate business impact
            int businessImpact = calculateBusinessImpact(path);
            analysis.setBusinessImpact(businessImpact);
            
            // Calculate likelihood of failure
            int likelihood = calculateLikelihood(path);
            analysis.setLikelihood(likelihood);
            
            // Calculate risk score (impact * likelihood)
            analysis.setRiskScore(businessImpact * likelihood);
            
            // Generate risk mitigation recommendation
            analysis.setRecommendation(generateRiskRecommendation(path, businessImpact, likelihood));
            
            riskAnalyses.add(analysis);
        }
        
        // Sort by risk score (highest first)
        riskAnalyses.sort(Comparator.comparing(RiskAnalysis::getRiskScore).reversed());
        
        return riskAnalyses;
    }
    
    /**
     * Calculates the business impact of a test path failure (1-10 scale)
     */
    private int calculateBusinessImpact(TestPath path) {
        // Determine business impact based on path characteristics
        int impact = 5; // Default medium impact
        
        if (path.getName() != null) {
            String name = path.getName().toLowerCase();
            
            // Critical paths have higher impact
            if (name.contains("login") || name.contains("authentication")) {
                impact += 4;
            } else if (name.contains("checkout") || name.contains("payment")) {
                impact += 5;
            } else if (name.contains("registration") || name.contains("signup")) {
                impact += 3;
            } else if (name.contains("search")) {
                impact += 1;
            }
        }
        
        // Paths with form submissions generally have higher impact
        if (containsFormSubmission(path)) {
            impact += 1;
        }
        
        // Ensure impact is between 1-10
        return Math.max(1, Math.min(10, impact));
    }
    
    /**
     * Calculates the likelihood of failure for a test path (1-10 scale)
     */
    private int calculateLikelihood(TestPath path) {
        // Determine likelihood based on path complexity and characteristics
        int likelihood = 3; // Default low-medium likelihood
        
        // More actions means higher complexity and higher likelihood of failure
        int actionCount = path.getActions().size();
        if (actionCount > 10) {
            likelihood += 3;
        } else if (actionCount > 5) {
            likelihood += 1;
        }
        
        // Paths with form submissions are more likely to fail
        if (containsFormSubmission(path)) {
            likelihood += 1;
        }
        
        // Navigation paths are more likely to fail
        if (containsNavigation(path)) {
            likelihood += 1;
        }
        
        // Edge cases are more likely to fail
        if (path.getName() != null && 
            (path.getName().contains("Invalid") || path.getName().contains("Empty"))) {
            likelihood += 2;
        }
        
        // Ensure likelihood is between 1-10
        return Math.max(1, Math.min(10, likelihood));
    }
    
    /**
     * Generates a risk mitigation recommendation
     */
    private String generateRiskRecommendation(TestPath path, int businessImpact, int likelihood) {
        StringBuilder recommendation = new StringBuilder();
        
        // High risk paths need more attention
        int riskScore = businessImpact * likelihood;
        
        if (riskScore >= 50) {
            recommendation.append("CRITICAL RISK: ");
            
            // Recommendations for critical risk
            if (path.getName() != null) {
                String name = path.getName().toLowerCase();
                
                if (name.contains("login") || name.contains("authentication")) {
                    recommendation.append("Implement comprehensive authentication testing including " +
                                        "negative scenarios, edge cases, and security penetration testing. " +
                                        "Consider adding multi-factor authentication tests.");
                } else if (name.contains("checkout") || name.contains("payment")) {
                    recommendation.append("Implement extensive payment flow testing including different " +
                                        "payment methods, validation scenarios, and transaction rollback tests. " +
                                        "Consider adding load tests for checkout process.");
                } else if (name.contains("registration")) {
                    recommendation.append("Implement thorough registration flow testing including field " +
                                        "validation, duplicate detection, and confirmation processes. " +
                                        "Consider adding security tests for user data protection.");
                } else {
                    recommendation.append("This path has a critical risk score and requires extensive " +
                                        "testing including positive, negative, and boundary test cases. " +
                                        "Consider adding performance and security tests.");
                }
            } else {
                recommendation.append("This path has a critical risk score and requires extensive " +
                                    "testing including positive, negative, and boundary test cases. " +
                                    "Consider adding performance and security tests.");
            }
        } else if (riskScore >= 30) {
            recommendation.append("HIGH RISK: Implement comprehensive test cases for this path " +
                                "including positive and negative scenarios. Consider adding edge cases " +
                                "and boundary tests to ensure robustness.");
        } else if (riskScore >= 15) {
            recommendation.append("MEDIUM RISK: Create standard test cases covering the main functionality " +
                                "and common failure scenarios. Regular regression testing is recommended.");
        } else {
            recommendation.append("LOW RISK: Basic test coverage should be sufficient. " +
                                "Include this path in general regression testing.");
        }
        
        return recommendation.toString();
    }
    
    /**
     * Runs accessibility analysis on the current page
     */
    public AccessibilityAnalysis analyzeAccessibility(WebDriver driver, String level) {
        AccessibilityAnalysis analysis = new AccessibilityAnalysis();
        analysis.setUrl(driver.getCurrentUrl());
        analysis.setComplianceLevel(level);
        
        try {
            // Check for basic accessibility issues
            checkImageAlts(driver, analysis);
            checkColorContrast(driver, analysis);
            checkFormLabels(driver, analysis);
            checkHeadingStructure(driver, analysis);
            checkKeyboardNavigation(driver, analysis);
            checkARIAAttributes(driver, analysis);
            
            // Calculate overall compliance
            calculateComplianceScore(analysis);
            
            return analysis;
        } catch (Exception e) {
            logger.error("Error in accessibility analysis", e);
            analysis.addIssue("Analysis Error", "An error occurred during accessibility analysis", "Critical");
            return analysis;
        }
    }
    
    /**
     * Checks image elements for alt attributes
     */
    private void checkImageAlts(WebDriver driver, AccessibilityAnalysis analysis) {
        try {
            List<WebElement> images = driver.findElements(By.tagName("img"));
            
            for (WebElement image : images) {
                String alt = image.getAttribute("alt");
                
                if (alt == null || alt.isEmpty()) {
                    String src = image.getAttribute("src");
                    String description = src != null && !src.isEmpty() 
                        ? "Image with src '" + src + "'" 
                        : "Image element";
                    
                    analysis.addIssue(
                        "Missing Alt Text",
                        description + " has no alt attribute",
                        "Critical"
                    );
                }
            }
        } catch (Exception e) {
            logger.error("Error checking image alts", e);
        }
    }
    
    /**
     * Performs basic color contrast checks
     * Note: Full contrast checking requires more advanced analysis
     */
    private void checkColorContrast(WebDriver driver, AccessibilityAnalysis analysis) {
        try {
            // Check text elements for potential contrast issues
            List<WebElement> textElements = driver.findElements(By.cssSelector(
                "p, span, h1, h2, h3, h4, h5, h6, a, button, label"));
            
            for (WebElement element : textElements) {
                String color = element.getCssValue("color");
                String backgroundColor = element.getCssValue("background-color");
                
                // This is a simplified check - real contrast analysis would be more complex
                if (color != null && backgroundColor != null) {
                    if ((color.contains("rgba(255, 255, 255") && backgroundColor.contains("rgba(255, 255, 255")) ||
                        (color.contains("rgba(0, 0, 0") && backgroundColor.contains("rgba(0, 0, 0"))) {
                        
                        analysis.addIssue(
                            "Potential Low Contrast",
                            "Element may have insufficient color contrast",
                            "Warning"
                        );
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error checking color contrast", e);
        }
    }
    
    /**
     * Checks form fields for associated labels
     */
    private void checkFormLabels(WebDriver driver, AccessibilityAnalysis analysis) {
        try {
            List<WebElement> formFields = driver.findElements(By.cssSelector(
                "input:not([type='hidden']):not([type='submit']):not([type='button']), select, textarea"));
            
            for (WebElement field : formFields) {
                String id = field.getAttribute("id");
                
                if (id != null && !id.isEmpty()) {
                    List<WebElement> labels = driver.findElements(By.cssSelector("label[for='" + id + "']"));
                    
                    if (labels.isEmpty()) {
                        String name = field.getAttribute("name");
                        String description = name != null && !name.isEmpty() 
                            ? "Field with name '" + name + "'" 
                            : "Form field";
                        
                        analysis.addIssue(
                            "Missing Form Label",
                            description + " has no associated label",
                            "Critical"
                        );
                    }
                } else {
                    // Check if field is inside a label
                    try {
                        field.findElement(By.xpath("./ancestor::label"));
                    } catch (Exception e) {
                        String name = field.getAttribute("name");
                        String description = name != null && !name.isEmpty() 
                            ? "Field with name '" + name + "'" 
                            : "Form field";
                        
                        analysis.addIssue(
                            "Missing Form Label",
                            description + " has no associated label",
                            "Critical"
                        );
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error checking form labels", e);
        }
    }
    
    /**
     * Checks page heading structure
     */
    private void checkHeadingStructure(WebDriver driver, AccessibilityAnalysis analysis) {
        try {
            // Check if H1 exists
            List<WebElement> h1s = driver.findElements(By.tagName("h1"));
            
            if (h1s.isEmpty()) {
                analysis.addIssue(
                    "Missing H1",
                    "Page does not have an H1 heading",
                    "Critical"
                );
            } else if (h1s.size() > 1) {
                analysis.addIssue(
                    "Multiple H1 Elements",
                    "Page has " + h1s.size() + " H1 headings (should have only one)",
                    "Warning"
                );
            }
            
            // Check heading levels don't skip (e.g., H1 to H3 without H2)
            boolean hasH1 = !h1s.isEmpty();
            boolean hasH2 = !driver.findElements(By.tagName("h2")).isEmpty();
            boolean hasH3 = !driver.findElements(By.tagName("h3")).isEmpty();
            boolean hasH4 = !driver.findElements(By.tagName("h4")).isEmpty();
            boolean hasH5 = !driver.findElements(By.tagName("h5")).isEmpty();
            boolean hasH6 = !driver.findElements(By.tagName("h6")).isEmpty();
            
            if (!hasH1 && (hasH2 || hasH3 || hasH4 || hasH5 || hasH6)) {
                analysis.addIssue(
                    "Skipped Heading Level",
                    "Page uses heading levels without an H1",
                    "Critical"
                );
            }
            
            if (!hasH2 && (hasH3 || hasH4 || hasH5 || hasH6)) {
                analysis.addIssue(
                    "Skipped Heading Level",
                    "Page skips from H1 to H3 or lower without H2",
                    "Warning"
                );
            }
            
            if (!hasH3 && (hasH4 || hasH5 || hasH6)) {
                analysis.addIssue(
                    "Skipped Heading Level",
                    "Page skips from H2 to H4 or lower without H3",
                    "Warning"
                );
            }
        } catch (Exception e) {
            logger.error("Error checking heading structure", e);
        }
    }
    
    /**
     * Checks keyboard navigability
     */
    private void checkKeyboardNavigation(WebDriver driver, AccessibilityAnalysis analysis) {
        try {
            // Check for tabindex greater than 0 (can disrupt natural tab order)
            List<WebElement> elementsWithTabIndex = driver.findElements(By.cssSelector("[tabindex]"));
            
            for (WebElement element : elementsWithTabIndex) {
                String tabIndex = element.getAttribute("tabindex");
                
                try {
                    int tabIndexValue = Integer.parseInt(tabIndex);
                    
                    if (tabIndexValue > 0) {
                        analysis.addIssue(
                            "Positive Tabindex",
                            "Element has tabindex value greater than 0, which can disrupt keyboard navigation",
                            "Warning"
                        );
                    }
                } catch (NumberFormatException e) {
                    // Not a valid number, skip
                }
            }
            
            // Check for clickable elements without keyboard access
            List<WebElement> clickableElements = driver.findElements(By.cssSelector(
                "[onclick], [class*='button'], [class*='btn']"));
            
            for (WebElement element : clickableElements) {
                String tagName = element.getTagName().toLowerCase();
                
                // Non-interactive elements with click handlers need role or tabindex
                if (!tagName.equals("a") && !tagName.equals("button") && 
                    !tagName.equals("input") && !tagName.equals("select")) {
                    
                    String role = element.getAttribute("role");
                    String tabIndex = element.getAttribute("tabindex");
                    
                    if ((role == null || !role.equals("button")) && 
                        (tabIndex == null || tabIndex.isEmpty())) {
                        
                        analysis.addIssue(
                            "Inaccessible Interactive Element",
                            "Clickable element is not keyboard accessible",
                            "Critical"
                        );
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error checking keyboard navigation", e);
        }
    }
    
    /**
     * Checks ARIA attributes usage
     */
    private void checkARIAAttributes(WebDriver driver, AccessibilityAnalysis analysis) {
        try {
            // Check for elements with ARIA roles
            List<WebElement> ariaElements = driver.findElements(By.cssSelector("[role]"));
            
            for (WebElement element : ariaElements) {
                String role = element.getAttribute("role");
                
                // Check for valid roles
                if (role != null && !isValidAriaRole(role)) {
                    analysis.addIssue(
                        "Invalid ARIA Role",
                        "Element has invalid ARIA role: " + role,
                        "Critical"
                    );
                }
                
                // Check for required ARIA attributes for certain roles
                if ("checkbox".equals(role) || "switch".equals(role)) {
                    String ariaChecked = element.getAttribute("aria-checked");
                    
                    if (ariaChecked == null || ariaChecked.isEmpty()) {
                        analysis.addIssue(
                            "Missing Required ARIA Attribute",
                            "Element with role '" + role + "' is missing required aria-checked attribute",
                            "Critical"
                        );
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error checking ARIA attributes", e);
        }
    }
    
    /**
     * Checks if an ARIA role is valid
     */
    private boolean isValidAriaRole(String role) {
        String[] validRoles = {
            "alert", "alertdialog", "application", "article", "banner", "button", "cell", "checkbox", 
            "columnheader", "combobox", "complementary", "contentinfo", "definition", "dialog", 
            "directory", "document", "feed", "figure", "form", "grid", "gridcell", "group", 
            "heading", "img", "link", "list", "listbox", "listitem", "log", "main", "marquee", 
            "math", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "navigation", 
            "none", "note", "option", "presentation", "progressbar", "radio", "radiogroup", "region", 
            "row", "rowgroup", "rowheader", "scrollbar", "search", "searchbox", "separator", "slider", 
            "spinbutton", "status", "switch", "tab", "table", "tablist", "tabpanel", "term", 
            "textbox", "timer", "toolbar", "tooltip", "tree", "treegrid", "treeitem"
        };
        
        return Arrays.asList(validRoles).contains(role.toLowerCase());
    }
    
    /**
     * Calculates overall compliance score
     */
    private void calculateComplianceScore(AccessibilityAnalysis analysis) {
        int criticalIssues = 0;
        int warnings = 0;
        
        for (AccessibilityIssue issue : analysis.getIssues()) {
            if ("Critical".equals(issue.getSeverity())) {
                criticalIssues++;
            } else if ("Warning".equals(issue.getSeverity())) {
                warnings++;
            }
        }
        
        // Calculate score (simplified)
        if (criticalIssues == 0 && warnings == 0) {
            analysis.setComplianceScore(100);
            analysis.setComplianceStatus("Fully Compliant");
        } else if (criticalIssues == 0 && warnings <= 2) {
            analysis.setComplianceScore(90);
            analysis.setComplianceStatus("Mostly Compliant");
        } else if (criticalIssues <= 2 && warnings <= 5) {
            analysis.setComplianceScore(70);
            analysis.setComplianceStatus("Partially Compliant");
        } else if (criticalIssues <= 5) {
            analysis.setComplianceScore(50);
            analysis.setComplianceStatus("Minimally Compliant");
        } else {
            analysis.setComplianceScore(30);
            analysis.setComplianceStatus("Non-Compliant");
        }
    }
    
    /**
     * Enum for action types in test paths
     */
    public enum ActionType {
        CLICK,
        ENTER_TEXT,
        SELECT,
        NAVIGATE,
        SUBMIT,
        VERIFY,
        WAIT,
        REFRESH,
        BROWSER_BACK,
        BROWSER_FORWARD,
        MULTI_SESSION,
        CONCURRENT
    }
    
    /**
     * Enum for edge case types
     */
    public enum EdgeCaseType {
        VALIDATION,
        AUTHENTICATION,
        NAVIGATION,
        SECURITY,
        PERFORMANCE,
        USABILITY
    }
    
    /**
     * Class representing a test path through the application
     */
    public static class TestPath {
        private String name;
        private String description;
        private List<PageAction> actions;
        private int priorityScore = 1;
        
        public TestPath(List<PageAction> actions) {
            this.actions = actions;
        }
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public void setDescription(String description) {
            this.description = description;
        }
        
        public List<PageAction> getActions() {
            return actions;
        }
        
        public int getPriorityScore() {
            return priorityScore;
        }
        
        public void setPriorityScore(int priorityScore) {
            this.priorityScore = priorityScore;
        }
        
        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            builder.append("Test Path: ").append(name != null ? name : "Unnamed").append("\n");
            
            if (description != null) {
                builder.append("Description: ").append(description).append("\n");
            }
            
            builder.append("Priority: ").append(priorityScore).append("\n");
            builder.append("Actions:\n");
            
            for (int i = 0; i < actions.size(); i++) {
                builder.append("  ").append(i + 1).append(". ").append(actions.get(i)).append("\n");
            }
            
            return builder.toString();
        }
    }
    
    /**
     * Class representing a single action in a test path
     */
    public static class PageAction {
        private final String elementTag;
        private final String elementDescription;
        private final ActionType actionType;
        private final String value;
        
        public PageAction(String elementTag, String elementDescription, 
                         ActionType actionType, String value) {
            this.elementTag = elementTag;
            this.elementDescription = elementDescription;
            this.actionType = actionType;
            this.value = value;
        }
        
        public String getElementTag() {
            return elementTag;
        }
        
        public String getElementDescription() {
            return elementDescription;
        }
        
        public ActionType getActionType() {
            return actionType;
        }
        
        public String getValue() {
            return value;
        }
        
        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            
            switch (actionType) {
                case CLICK:
                    builder.append("Click on ").append(elementDescription);
                    break;
                case ENTER_TEXT:
                    builder.append("Enter \"").append(value).append("\" into ").append(elementDescription);
                    break;
                case SELECT:
                    builder.append("Select \"").append(value).append("\" from ").append(elementDescription);
                    break;
                case NAVIGATE:
                    builder.append("Navigate to ").append(value);
                    break;
                case SUBMIT:
                    builder.append("Submit ").append(elementDescription);
                    break;
                case VERIFY:
                    builder.append("Verify ").append(value);
                    break;
                case WAIT:
                    builder.append("Wait for ").append(value);
                    break;
                case REFRESH:
                    builder.append("Refresh page");
                    break;
                case BROWSER_BACK:
                    builder.append("Navigate browser back");
                    break;
                case BROWSER_FORWARD:
                    builder.append("Navigate browser forward");
                    break;
                case MULTI_SESSION:
                    builder.append("Open ").append(value).append(" browser sessions");
                    break;
                case CONCURRENT:
                    builder.append("Perform concurrent access to ").append(value);
                    break;
                default:
                    builder.append(actionType).append(" ").append(elementDescription);
            }
            
            return builder.toString();
        }
    }
    
    /**
     * Class representing page analysis results
     */
    private static class PageAnalysis {
        private String title;
        private String url;
        private List<FormInfo> forms = new ArrayList<>();
        private List<WebElement> interactiveElements = new ArrayList<>();
        private List<WebElement> validationPoints = new ArrayList<>();
        
        public String getTitle() {
            return title;
        }
        
        public void setTitle(String title) {
            this.title = title;
        }
        
        public String getUrl() {
            return url;
        }
        
        public void setUrl(String url) {
            this.url = url;
        }
        
        public List<FormInfo> getForms() {
            return forms;
        }
        
        public void addForm(FormInfo form) {
            this.forms.add(form);
        }
        
        public List<WebElement> getInteractiveElements() {
            return interactiveElements;
        }
        
        public void setInteractiveElements(List<WebElement> interactiveElements) {
            this.interactiveElements = interactiveElements;
        }
        
        public List<WebElement> getValidationPoints() {
            return validationPoints;
        }
        
        public void setValidationPoints(List<WebElement> validationPoints) {
            this.validationPoints = validationPoints;
        }
    }
    
    /**
     * Class representing a form detected during analysis
     */
    public static class FormInfo {
        private String id;
        private String name;
        private String purpose;
        private List<FieldInfo> fields = new ArrayList<>();
        private WebElement submitButton;
        
        public String getId() {
            return id;
        }
        
        public void setId(String id) {
            this.id = id;
        }
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getPurpose() {
            return purpose;
        }
        
        public void setPurpose(String purpose) {
            this.purpose = purpose;
        }
        
        public List<FieldInfo> getFields() {
            return fields;
        }
        
        public void addField(FieldInfo field) {
            this.fields.add(field);
        }
        
        public WebElement getSubmitButton() {
            return submitButton;
        }
        
        public void setSubmitButton(WebElement submitButton) {
            this.submitButton = submitButton;
        }
    }
    
    /**
     * Class representing a form field detected during analysis
     */
    public static class FieldInfo {
        private String name;
        private String type;
        private boolean required;
        private WebElement element;
        private Map<String, String> options = new HashMap<>();
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getType() {
            return type;
        }
        
        public void setType(String type) {
            this.type = type;
        }
        
        public boolean isRequired() {
            return required;
        }
        
        public void setRequired(boolean required) {
            this.required = required;
        }
        
        public WebElement getElement() {
            return element;
        }
        
        public void setElement(WebElement element) {
            this.element = element;
        }
        
        public Map<String, String> getOptions() {
            return options;
        }
        
        public void addOption(String value, String text) {
            this.options.put(value, text);
        }
    }
    
    /**
     * Class representing an edge case for testing
     */
    public static class EdgeCase {
        private final String name;
        private final String description;
        private final TestPath testPath;
        private final EdgeCaseType type;
        private final int priority;
        
        public EdgeCase(String name, String description, TestPath testPath, 
                      EdgeCaseType type, int priority) {
            this.name = name;
            this.description = description;
            this.testPath = testPath;
            this.type = type;
            this.priority = priority;
        }
        
        public String getName() {
            return name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public TestPath getTestPath() {
            return testPath;
        }
        
        public EdgeCaseType getType() {
            return type;
        }
        
        public int getPriority() {
            return priority;
        }
        
        @Override
        public String toString() {
            return "Edge Case: " + name + " (" + type + ", Priority: " + priority + ")\n" +
                   "Description: " + description + "\n";
        }
    }
    
    /**
     * Class representing risk analysis for a test path
     */
    public static class RiskAnalysis {
        private String name;
        private TestPath testPath;
        private int businessImpact;
        private int likelihood;
        private int riskScore;
        private String recommendation;
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public TestPath getTestPath() {
            return testPath;
        }
        
        public void setTestPath(TestPath testPath) {
            this.testPath = testPath;
        }
        
        public int getBusinessImpact() {
            return businessImpact;
        }
        
        public void setBusinessImpact(int businessImpact) {
            this.businessImpact = businessImpact;
        }
        
        public int getLikelihood() {
            return likelihood;
        }
        
        public void setLikelihood(int likelihood) {
            this.likelihood = likelihood;
        }
        
        public int getRiskScore() {
            return riskScore;
        }
        
        public void setRiskScore(int riskScore) {
            this.riskScore = riskScore;
        }
        
        public String getRecommendation() {
            return recommendation;
        }
        
        public void setRecommendation(String recommendation) {
            this.recommendation = recommendation;
        }
        
        @Override
        public String toString() {
            return "Risk Analysis: " + name + "\n" +
                   "Business Impact: " + businessImpact + "/10\n" +
                   "Likelihood: " + likelihood + "/10\n" +
                   "Risk Score: " + riskScore + "/100\n" +
                   "Recommendation: " + recommendation + "\n";
        }
    }
    
    /**
     * Class representing accessibility analysis results
     */
    public static class AccessibilityAnalysis {
        private String url;
        private String complianceLevel;
        private int complianceScore;
        private String complianceStatus;
        private List<AccessibilityIssue> issues = new ArrayList<>();
        
        public String getUrl() {
            return url;
        }
        
        public void setUrl(String url) {
            this.url = url;
        }
        
        public String getComplianceLevel() {
            return complianceLevel;
        }
        
        public void setComplianceLevel(String complianceLevel) {
            this.complianceLevel = complianceLevel;
        }
        
        public int getComplianceScore() {
            return complianceScore;
        }
        
        public void setComplianceScore(int complianceScore) {
            this.complianceScore = complianceScore;
        }
        
        public String getComplianceStatus() {
            return complianceStatus;
        }
        
        public void setComplianceStatus(String complianceStatus) {
            this.complianceStatus = complianceStatus;
        }
        
        public List<AccessibilityIssue> getIssues() {
            return issues;
        }
        
        public void addIssue(String type, String description, String severity) {
            this.issues.add(new AccessibilityIssue(type, description, severity));
        }
        
        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            builder.append("Accessibility Analysis for: ").append(url).append("\n");
            builder.append("Compliance Level: ").append(complianceLevel).append("\n");
            builder.append("Compliance Score: ").append(complianceScore).append("/100\n");
            builder.append("Status: ").append(complianceStatus).append("\n\n");
            
            builder.append("Issues Found: ").append(issues.size()).append("\n");
            
            for (int i = 0; i < issues.size(); i++) {
                AccessibilityIssue issue = issues.get(i);
                builder.append(i + 1).append(". ").append(issue.getType())
                      .append(" (").append(issue.getSeverity()).append("): ")
                      .append(issue.getDescription()).append("\n");
            }
            
            return builder.toString();
        }
    }
    
    /**
     * Class representing an accessibility issue
     */
    public static class AccessibilityIssue {
        private final String type;
        private final String description;
        private final String severity;
        
        public AccessibilityIssue(String type, String description, String severity) {
            this.type = type;
            this.description = description;
            this.severity = severity;
        }
        
        public String getType() {
            return type;
        }
        
        public String getDescription() {
            return description;
        }
        
        public String getSeverity() {
            return severity;
        }
    }
}


package com.cssmart.framework.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for transformation operations on test data
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Transformation {
    /**
     * Type of transformation to apply
     */
    TransformType type();
    
    /**
     * Field(s) to apply the transformation to
     */
    String[] fields();
    
    /**
     * Optional parameters for the transformation
     */
    String[] params() default {};
}

/**
 * Enum for transformation types
 */
enum TransformType {
    /**
     * Analyzes text for sentiment (positive/negative/neutral)
     */
    SENTIMENT_ANALYSIS,
    
    /**
     * Generates variations of test data
     */
    DATA_AUGMENTATION,
    
    /**
     * Creates boundary values for numeric fields
     */
    BOUNDARY_VALUES,
    
    /**
     * Creates random data within constraints
     */
    RANDOMIZATION,
    
    /**
     * Maintains relationships between fields
     */
    RELATIONAL_MAPPING
}

/**
 * Annotation for constraint definitions on test data
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Constraint {
    /**
     * Field to apply the constraint to
     */
    String field();
    
    /**
     * Type of constraint
     */
    String type() default "";
    
    /**
     * Minimum value for numeric constraints
     */
    String min() default "";
    
    /**
     * Maximum value for numeric constraints
     */
    String max() default "";
    
    /**
     * Pattern for string validation
     */
    String pattern() default "";
    
    /**
     * List of allowed values
     */
    String[] allowedValues() default {};
}

/**
 * Enum for data source types
 */
enum DataSourceType {
    /**
     * Data from JSON file
     */
    JSON,
    
    /**
     * Data from Excel file
     */
    EXCEL,
    
    /**
     * Data from CSV file
     */
    CSV,
    
    /**
     * Data from database
     */
    DATABASE,
    
    /**
     * AI-generated test data
     */
    SMART_GENERATION
}

/**
 * Enum for test coverage types
 */
enum Coverage {
    /**
     * Standard positive test cases
     */
    NORMAL,
    
    /**
     * Test cases at boundary values
     */
    BOUNDARY_VALUES,
    
    /**
     * Test cases with invalid input
     */
    NEGATIVE,
    
    /**
     * Comprehensive test coverage
     */
    COMPREHENSIVE
}

/**
 * Smart data provider annotation for AI-enhanced test data generation
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface CSSmartDataProvider {
    /**
     * Type of data source
     */
    DataSourceType type();
    
    /**
     * Path to data source file (for file-based sources)
     */
    String path() default "";
    
    /**
     * Target form for smart data generation
     */
    String targetForm() default "";
    
    /**
     * Desired coverage level
     */
    Coverage coverage() default Coverage.NORMAL;
    
    /**
     * Preprocessing transformations to apply to the data
     */
    Transformation[] preprocessing() default {};
    
    /**
     * Filtering expression for the data
     */
    String filtering() default "";
    
    /**
     * Constraints for generated data
     */
    Constraint[] constraints() default {};
}



    
    /**
     * Importance level of the step
     */
    Importance importance() default Importance.NORMAL;
    
    /**
     * Whether to take screenshots during the step
     */
    ScreenshotType takeScreenshot() default ScreenshotType.NONE;
    
    /**
     * Specific step mappings for BDD integration
     */
    StepMapping[] mappingStrategies() default {};
}



package com.cssmart.framework.data;

import com.cssmart.framework.annotation.*;
import com.cssmart.framework.logging.CSSmartLogger;

import java.io.*;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Engine for AI-powered test data generation and transformation
 */
public class CSSmartDataEngine {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartDataEngine.class);
    
    /**
     * Processes a data provider annotation to retrieve test data
     */
    public static List<Object[]> getTestData(CSSmartDataProvider annotation, Method testMethod) {
        try {
            // Extract data based on source type
            List<Map<String, Object>> rawData;
            
            switch (annotation.type()) {
                case JSON:
                    rawData = loadJsonData(annotation.path());
                    break;
                case EXCEL:
                    rawData = loadExcelData(annotation.path());
                    break;
                case CSV:
                    rawData = loadCsvData(annotation.path());
                    break;
                case DATABASE:
                    rawData = loadDatabaseData(annotation.path());
                    break;
                case SMART_GENERATION:
                    rawData = generateSmartData(annotation, testMethod);
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported data source type: " + annotation.type());
            }
            
            // Apply preprocessing transformations
            rawData = applyPreprocessing(rawData, annotation.preprocessing());
            
            // Apply filtering
            if (!annotation.filtering().isEmpty()) {
                rawData = applyFiltering(rawData, annotation.filtering());
            }
            
            // Convert to Object arrays for TestNG
            return convertToTestNGFormat(rawData, testMethod);
            
        } catch (Exception e) {
            logger.error("Error processing data provider", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Loads data from a JSON file
     */
    private static List<Map<String, Object>> loadJsonData(String path) throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        
        try (InputStream is = CSSmartDataEngine.class.getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new FileNotFoundException("JSON file not found: " + path);
            }
            
            // This is a simple implementation - in a real system, use a proper JSON parser
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            StringBuilder content = new StringBuilder();
            String line;
            
            while ((line = reader.readLine()) != null) {
                content.append(line);
            }
            
            // Parse the JSON (simplified parsing for illustration)
            return parseJson(content.toString());
        }
    }
    
    /**
     * Simple JSON parser (for illustration only - use a proper JSON library in production)
     */
    private static List<Map<String, Object>> parseJson(String json) {
        List<Map<String, Object>> result = new ArrayList<>();
        
        // This is a very simplified parser for illustration
        // Look for array of objects
        Pattern pattern = Pattern.compile("\\[\\s*\\{(.+?)\\}\\s*\\]", Pattern.DOTALL);
        Matcher matcher = pattern.matcher(json);
        
        if (matcher.find()) {
            String arrayContent = matcher.group(1);
            String[] items = arrayContent.split("\\}\\s*,\\s*\\{");
            
            for (String item : items) {
                Map<String, Object> itemMap = new HashMap<>();
                Pattern keyValuePattern = Pattern.compile("\"(.*?)\"\\s*:\\s*\"?(.*?)\"?\\s*,");
                Matcher keyValueMatcher = keyValuePattern.matcher(item + ",");
                
                while (keyValueMatcher.find()) {
                    String key = keyValueMatcher.group(1);
                    String value = keyValueMatcher.group(2);
                    itemMap.put(key, value);
                }
                
                result.add(itemMap);
            }
        }
        
        return result;
    }
    
    /**
     * Loads data from an Excel file
     * Note: This is a stub implementation - in a real system, use a proper Excel library
     */
    private static List<Map<String, Object>> loadExcelData(String path) {
        logger.info("Loading Excel data from: " + path);
        
        // This would use a library like Apache POI in a real implementation
        // For illustration, we'll return dummy data
        List<Map<String, Object>> result = new ArrayList<>();
        
        Map<String, Object> row1 = new HashMap<>();
        row1.put("username", "testuser1");
        row1.put("password", "password1");
        row1.put("email", "testuser1@example.com");
        row1.put("age", 25);
        
        Map<String, Object> row2 = new HashMap<>();
        row2.put("username", "testuser2");
        row2.put("password", "password2");
        row2.put("email", "testuser2@example.com");
        row2.put("age", 30);
        
        result.add(row1);
        result.add(row2);
        
        return result;
    }
    
    /**
     * Loads data from a CSV file
     * Note: This is a stub implementation - in a real system, use a proper CSV library
     */
    private static List<Map<String, Object>> loadCsvData(String path) {
        logger.info("Loading CSV data from: " + path);
        
        // This would use a library like Apache Commons CSV in a real implementation
        // For illustration, we'll return dummy data
        List<Map<String, Object>> result = new ArrayList<>();
        
        try (InputStream is = CSSmartDataEngine.class.getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new FileNotFoundException("CSV file not found: " + path);
            }
            
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            
            // Read header
            String headerLine = reader.readLine();
            if (headerLine == null) {
                return result;
            }
            
            String[] headers = headerLine.split(",");
            
            // Read data rows
            String line;
            while ((line = reader.readLine()) != null) {
                String[] values = line.split(",");
                Map<String, Object> row = new HashMap<>();
                
                for (int i = 0; i < headers.length && i < values.length; i++) {
                    row.put(headers[i], values[i]);
                }
                
                result.add(row);
            }
            
            return result;
            
        } catch (IOException e) {
            logger.error("Error reading CSV file", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Loads data from a database
     * Note: This is a stub implementation - in a real system, use JDBC
     */
    private static List<Map<String, Object>> loadDatabaseData(String query) {
        logger.info("Loading database data with query: " + query);
        
        // This would use JDBC in a real implementation
        // For illustration, we'll return dummy data
        List<Map<String, Object>> result = new ArrayList<>();
        
        Map<String, Object> row1 = new HashMap<>();
        row1.put("id", 1);
        row1.put("username", "dbuser1");
        row1.put("email", "dbuser1@example.com");
        
        Map<String, Object> row2 = new HashMap<>();
        row2.put("id", 2);
        row2.put("username", "dbuser2");
        row2.put("email", "dbuser2@example.com");
        
        result.add(row1);
        result.add(row2);
        
        return result;
    }
    
    /**
     * Generates smart test data based on annotation parameters and test method
     */
    private static List<Map<String, Object>> generateSmartData(CSSmartDataProvider annotation, Method testMethod) {
        logger.info("Generating smart test data for method: " + testMethod.getName());
        
        List<Map<String, Object>> result = new ArrayList<>();
        String targetForm = annotation.targetForm();
        Coverage coverage = annotation.coverage();
        Constraint[] constraints = annotation.constraints();
        
        // Determine what fields we need to generate
        Set<String> requiredFields = extractRequiredFields(annotation, testMethod);
        
        // Generate data based on coverage type
        switch (coverage) {
            case NORMAL:
                // Generate standard positive test cases
                result.add(generatePositiveTestCase(requiredFields, constraints));
                break;
                
            case BOUNDARY_VALUES:
                // Generate boundary value test cases
                result.addAll(generateBoundaryTestCases(requiredFields, constraints));
                break;
                
            case NEGATIVE:
                // Generate negative test cases
                result.addAll(generateNegativeTestCases(requiredFields, constraints));
                break;
                
            case COMPREHENSIVE:
                // Generate comprehensive set of test cases
                result.add(generatePositiveTestCase(requiredFields, constraints));
                result.addAll(generateBoundaryTestCases(requiredFields, constraints));
                result.addAll(generateNegativeTestCases(requiredFields, constraints));
                break;
                
            default:
                result.add(generatePositiveTestCase(requiredFields, constraints));
        }
        
        return result;
    }
    
    /**
     * Extracts required fields from method parameters and annotations
     */
    private static Set<String> extractRequiredFields(CSSmartDataProvider annotation, Method testMethod) {
        Set<String> fields = new HashSet<>();
        
        // Extract from constraints
        for (Constraint constraint : annotation.constraints()) {
            fields.add(constraint.field());
        }
        
        // If no specific fields are mentioned, use generic field names based on form type
        if (fields.isEmpty()) {
            String targetForm = annotation.targetForm();
            
            // Determine fields based on form type
            if ("loginForm".equalsIgnoreCase(targetForm)) {
                fields.add("username");
                fields.add("password");
            } else if ("registrationForm".equalsIgnoreCase(targetForm)) {
                fields.add("username");
                fields.add("password");
                fields.add("email");
                fields.add("firstName");
                fields.add("lastName");
            } else if ("contactForm".equalsIgnoreCase(targetForm)) {
                fields.add("name");
                fields.add("email");
                fields.add("subject");
                fields.add("message");
            } else if ("paymentForm".equalsIgnoreCase(targetForm)) {
                fields.add("cardNumber");
                fields.add("cardholderName");
                fields.add("expiryDate");
                fields.add("cvv");
                fields.add("amount");
            } else if ("addressForm".equalsIgnoreCase(targetForm)) {
                fields.add("street");
                fields.add("city");
                fields.add("state");
                fields.add("zipCode");
                fields.add("country");
            } else {
                // Default generic fields
                fields.add("name");
                fields.add("value");
                fields.add("description");
            }
        }
        
        return fields;
    }
    
    /**
     * Generates a positive test case with valid data
     */
    private static Map<String, Object> generatePositiveTestCase(Set<String> fields, Constraint[] constraints) {
        Map<String, Object> testCase = new HashMap<>();
        
        for (String field : fields) {
            Constraint constraint = findConstraintForField(field, constraints);
            testCase.put(field, generateValidValue(field, constraint));
        }
        
        return testCase;
    }
    
    /**
     * Generates test cases with boundary values
     */
    private static List<Map<String, Object>> generateBoundaryTestCases(Set<String> fields, Constraint[] constraints) {
        List<Map<String, Object>> testCases = new ArrayList<>();
        
        // Create a base test case with all valid values
        Map<String, Object> baseCase = generatePositiveTestCase(fields, constraints);
        
        // For each field with numeric constraints, generate boundary test cases
        for (String field : fields) {
            Constraint constraint = findConstraintForField(field, constraints);
            
            if (constraint != null && (!constraint.min().isEmpty() || !constraint.max().isEmpty())) {
                // Test with minimum value
                if (!constraint.min().isEmpty()) {
                    Map<String, Object> minCase = new HashMap<>(baseCase);
                    minCase.put(field, parseConstraintValue(constraint.min()));
                    testCases.add(minCase);
                    
                    // Test with minimum value + 1
                    Map<String, Object> minPlusOneCase = new HashMap<>(baseCase);
                    minPlusOneCase.put(field, incrementValue(parseConstraintValue(constraint.min())));
                    testCases.add(minPlusOneCase);
                }
                
                // Test with maximum value
                if (!constraint.max().isEmpty()) {
                    Map<String, Object> maxCase = new HashMap<>(baseCase);
                    maxCase.put(field, parseConstraintValue(constraint.max()));
                    testCases.add(maxCase);
                    
                    // Test with maximum value - 1
                    Map<String, Object> maxMinusOneCase = new HashMap<>(baseCase);
                    maxMinusOneCase.put(field, decrementValue(parseConstraintValue(constraint.max())));
                    testCases.add(maxMinusOneCase);
                }
            } else if (constraint != null && "string".equals(constraint.type())) {
                // For string fields, test length boundaries
                int maxLength = 255; // Default max length
                if (!constraint.max().isEmpty()) {
                    try {
                        maxLength = Integer.parseInt(constraint.max());
                    } catch (NumberFormatException e) {
                        // Use default
                    }
                }
                
                // Test with empty string
                Map<String, Object> emptyCase = new HashMap<>(baseCase);
                emptyCase.put(field, "");
                testCases.add(emptyCase);
                
                // Test with max length string
                Map<String, Object> maxLengthCase = new HashMap<>(baseCase);
                maxLengthCase.put(field, generateStringOfLength(maxLength));
                testCases.add(maxLengthCase);
            }
        }
        
        return testCases;
    }
    
    /**
     * Generates test cases with invalid data
     */
    private static List<Map<String, Object>> generateNegativeTestCases(Set<String> fields, Constraint[] constraints) {
        List<Map<String, Object>> testCases = new ArrayList<>();
        
        // Create a base test case with all valid values
        Map<String, Object> baseCase = generatePositiveTestCase(fields, constraints);
        
        // For each field, generate invalid values
        for (String field : fields) {
            Constraint constraint = findConstraintForField(field, constraints);
            
            // Test with null value
            Map<String, Object> nullCase = new HashMap<>(baseCase);
            nullCase.put(field, null);
            testCases.add(nullCase);
            
            if (constraint != null) {
                // Test based on constraint type
                switch (constraint.type()) {
                    case "number":
                    case "integer":
                        // Test with value below minimum
                        if (!constraint.min().isEmpty()) {
                            Map<String, Object> belowMinCase = new HashMap<>(baseCase);
                            Object minValue = parseConstraintValue(constraint.min());
                            belowMinCase.put(field, decrementValue(minValue));
                            testCases.add(belowMinCase);
                        }
                        
                        // Test with value above maximum
                        if (!constraint.max().isEmpty()) {
                            Map<String, Object> aboveMaxCase = new HashMap<>(baseCase);
                            Object maxValue = parseConstraintValue(constraint.max());
                            aboveMaxCase.put(field, incrementValue(maxValue));
                            testCases.add(aboveMaxCase);
                        }
                        
                        // Test with non-numeric value
                        Map<String, Object> nonNumericCase = new HashMap<>(baseCase);
                        nonNumericCase.put(field, "not-a-number");
                        testCases.add(nonNumericCase);
                        break;
                        
                    case "string":
                        // Test with invalid pattern
                        if (!constraint.pattern().isEmpty()) {
                            Map<String, Object> invalidPatternCase = new HashMap<>(baseCase);
                            invalidPatternCase.put(field, generateInvalidPattern(constraint.pattern()));
                            testCases.add(invalidPatternCase);
                        }
                        
                        // Test with string too long
                        if (!constraint.max().isEmpty()) {
                            try {
                                int maxLength = Integer.parseInt(constraint.max());
                                Map<String, Object> tooLongCase = new HashMap<>(baseCase);
                                tooLongCase.put(field, generateStringOfLength(maxLength + 1));
                                testCases.add(tooLongCase);
                            } catch (NumberFormatException e) {
                                // Skip this test case
                            }
                        }
                        break;
                        
                    case "email":
                        // Test with invalid email format
                        Map<String, Object> invalidEmailCase = new HashMap<>(baseCase);
                        invalidEmailCase.put(field, "invalid-email-format");
                        testCases.add(invalidEmailCase);
                        break;
                        
                    case "date":
                        // Test with invalid date format
                        Map<String, Object> invalidDateCase = new HashMap<>(baseCase);
                        invalidDateCase.put(field, "invalid-date");
                        testCases.add(invalidDateCase);
                        break;
                        
                    case "enum":
                        // Test with value not in allowed values
                        if (constraint.allowedValues().length > 0) {
                            Map<String, Object> invalidEnumCase = new HashMap<>(baseCase);
                            invalidEnumCase.put(field, "invalid-enum-value");
                            testCases.add(invalidEnumCase);
                        }
                        break;
                }
            } else {
                // No specific constraint, generate general invalid case
                Map<String, Object> invalidCase = new HashMap<>(baseCase);
                
                // Try to guess field type from name
                String fieldLower = field.toLowerCase();
                if (fieldLower.contains("email")) {
                    invalidCase.put(field, "invalid@email@format.com");
                } else if (fieldLower.contains("phone")) {
                    invalidCase.put(field, "not-a-phone-number");
                } else if (fieldLower.contains("zip") || fieldLower.contains("postal")) {
                    invalidCase.put(field, "not-a-zip");
                } else if (fieldLower.contains("age") || fieldLower.contains("number")) {
                    invalidCase.put(field, "not-a-number");
                } else if (fieldLower.contains("date")) {
                    invalidCase.put(field, "not-a-date");
                } else {
                    // Use a very long string as invalid case
                    invalidCase.put(field, generateStringOfLength(1000));
                }
                
                testCases.add(invalidCase);
            }
        }
        
        return testCases;
    }
    
    /**
     * Finds constraint for a specific field
     */
    private static Constraint findConstraintForField(String field, Constraint[] constraints) {
        for (Constraint constraint : constraints) {
            if (field.equals(constraint.field())) {
                return constraint;
            }
        }
        return null;
    }
    
    /**
     * Parses a constraint value to appropriate type
     */
    private static Object parseConstraintValue(String value) {
        // Try to parse as integer
        try {
            return Integer.parseInt(value);
        } catch (NumberFormatException e1) {
            // Try to parse as double
            try {
                return Double.parseDouble(value);
            } catch (NumberFormatException e2) {
                // Return as string
                return value;
            }
        }
    }
    
    /**
     * Increments a numeric value
     */
    private static Object incrementValue(Object value) {
        if (value instanceof Integer) {
            return (Integer) value + 1;
        } else if (value instanceof Double) {
            return (Double) value + 1.0;
        } else if (value instanceof Long) {
            return (Long) value + 1L;
        } else {
            // Can't increment non-numeric value
            return value;
        }
    }
    
    /**
     * Decrements a numeric value
     */
    private static Object decrementValue(Object value) {
        if (value instanceof Integer) {
            return (Integer) value - 1;
        } else if (value instanceof Double) {
            return (Double) value - 1.0;
        } else if (value instanceof Long) {
            return (Long) value - 1L;
        } else {
            // Can't decrement non-numeric value
            return value;
        }
    }
    
    /**
     * Generates a string of specific length
     */
    private static String generateStringOfLength(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append('a');
        }
        return sb.toString();
    }
    
    /**
     * Generates a string that doesn't match the given pattern
     */
    private static String generateInvalidPattern(String pattern) {
        // This is a simplified implementation
        // In a real system, you'd need more sophisticated pattern analysis
        if (pattern.contains("\\d")) {
            // Pattern likely expects digits, so provide letters
            return "abcdefghij";
        } else if (pattern.contains("[a-z]") || pattern.contains("[A-Z]")) {
            // Pattern likely expects letters, so provide digits
            return "12345678";
        } else {
            // Default invalid value
            return "!@#$%^&*()";
        }
    }
    
    /**
     * Generates a valid value for a field
     */
    private static Object generateValidValue(String field, Constraint constraint) {
        // First check if there's a specific constraint
        if (constraint != null) {
            // Generate based on constraint type
            switch (constraint.type()) {
                case "string":
                    if (constraint.allowedValues().length > 0) {
                        // Use first allowed value
                        return constraint.allowedValues()[0];
                    } else {
                        // Generate a random string
                        return generateRandomString(field, 10);
                    }
                    
                case "number":
                case "integer":
                    // Generate a number within constraints
                    int min = 0;
                    int max = 100;
                    
                    if (!constraint.min().isEmpty()) {
                        try {
                            min = Integer.parseInt(constraint.min());
                        } catch (NumberFormatException e) {
                            // Use default
                        }
                    }
                    
                    if (!constraint.max().isEmpty()) {
                        try {
                            max = Integer.parseInt(constraint.max());
                        } catch (NumberFormatException e) {
                            // Use default
                        }
                    }
                    
                    // Use average of min and max for a valid value
                    return (min + max) / 2;
                    
                case "email":
                    return "test_" + UUID.randomUUID().toString().substring(0, 8) + "@example.com";
                    
                case "boolean":
                    return true;
                    
                case "date":
                    return new SimpleDateFormat("yyyy-MM-dd").format(new Date());
                    
                case "enum":
                    if (constraint.allowedValues().length > 0) {
                        // Use first allowed value
                        return constraint.allowedValues()[0];
                    } else {
                        return "DEFAULT";
                    }
                    
                default:
                    // Use field-based generation for unknown types
                    return generateValueBasedOnFieldName(field);
            }
        } else {
            // No constraint, generate based on field name
            return generateValueBasedOnFieldName(field);
        }
    }
    
    /**
     * Generates a value based on field name
     */
    private static Object generateValueBasedOnFieldName(String field) {
        String fieldLower = field.toLowerCase();
        
        // Common field types
        if (fieldLower.contains("username") || fieldLower.equals("user") || fieldLower.equals("login")) {
            return "testuser_" + UUID.randomUUID().toString().substring(0, 6);
        } else if (fieldLower.contains("password") || fieldLower.equals("pwd") || fieldLower.equals("pass")) {
            return "Password123!";
        } else if (fieldLower.contains("email")) {
            return "test_" + UUID.randomUUID().toString().substring(0, 8) + "@example.com";
        } else if (fieldLower.contains("name")) {
            if (fieldLower.contains("first") || fieldLower.contains("fname")) {
                return "John";
            } else if (fieldLower.contains("last") || fieldLower.contains("lname")) {
                return "Doe";
            } else {
                return "John Doe";
            }
        } else if (fieldLower.contains("phone") || fieldLower.contains("mobile")) {
            return "1234567890";
        } else if (fieldLower.contains("address") || fieldLower.contains("street")) {
            return "123 Test Street";
        } else if (fieldLower.contains("city")) {
            return "Test City";
        } else if (fieldLower.contains("state") || fieldLower.contains("province")) {
            return "Test State";
        } else if (fieldLower.contains("zip") || fieldLower.contains("postal")) {
            return "12345";
        } else if (fieldLower.contains("country")) {
            return "United States";
        } else if (fieldLower.contains("card") && fieldLower.contains("number")) {
            return "4111111111111111"; // Test credit card number
        } else if (fieldLower.contains("cvv") || fieldLower.contains("cvc")) {
            return "123";
        } else if (fieldLower.contains("expiry") || fieldLower.contains("expiration")) {
            return "12/25";
        } else if (fieldLower.contains("amount") || fieldLower.contains("price")) {
            return 99.99;
        } else if (fieldLower.contains("quantity") || fieldLower.contains("count")) {
            return 1;
        } else if (fieldLower.contains("age")) {
            return 30;
        } else if (fieldLower.contains("date")) {
            return new SimpleDateFormat("yyyy-MM-dd").format(new Date());
        } else if (fieldLower.contains("time")) {
            return new SimpleDateFormat("HH:mm:ss").format(new Date());
        } else if (fieldLower.contains("comment") || fieldLower.contains("message")) {
            return "This is a test comment.";
        } else if (fieldLower.contains("subject") || fieldLower.contains("title")) {
            return "Test Subject";
        } else if (fieldLower.contains("description")) {
            return "This is a test description.";
        } else {
            // Default value for unknown fields
            return "Test_" + field;
        }
    }
    
    /**
     * Generates a random string
     */
    private static String generateRandomString(String field, int length) {
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        
        for (int i = 0; i < length; i++) {
            char c = (char) (random.nextInt(26) + 'a');
            sb.append(c);
        }
        
        return sb.toString();
    }
    
    /**
     * Applies preprocessing transformations to the data
     */
    private static List<Map<String, Object>> applyPreprocessing(
            List<Map<String, Object>> data, Transformation[] transformations) {
        
        if (transformations.length == 0) {
            return data;
        }
        
        List<Map<String, Object>> result = new ArrayList<>(data);
        
        for (Transformation transformation : transformations) {
            switch (transformation.type()) {
                case SENTIMENT_ANALYSIS:
                    result = applySentimentAnalysis(result, transformation.fields());
                    break;
                    
                case DATA_AUGMENTATION:
                    result = applyDataAugmentation(result, transformation.fields());
                    break;
                    
                case BOUNDARY_VALUES:
                    result = applyBoundaryValues(result, transformation.fields());
                    break;
                    
                case RANDOMIZATION:
                    result = applyRandomization(result, transformation.fields());
                    break;
                    
                case RELATIONAL_MAPPING:
                    result = applyRelationalMapping(result, transformation.fields(), transformation.params());
                    break;
            }
        }
        
        return result;
    }
    
    /**
     * Applies sentiment analysis to text fields
     */
    private static List<Map<String, Object>> applySentimentAnalysis(
            List<Map<String, Object>> data, String[] fields) {
        
        List<Map<String, Object>> result = new ArrayList<>();
        
        for (Map<String, Object> row : data) {
            Map<String, Object> enhancedRow = new HashMap<>(row);
            
            // Create a sentiment metadata object
            Map<String, Double> sentimentScores = new HashMap<>();
            
            for (String field : fields) {
                Object value = row.get(field);
                if (value instanceof String) {
                    double sentiment = analyzeSentiment((String) value);
                    sentimentScores.put(field, sentiment);
                }
            }
            
            // Add sentiment metadata to the row
            enhancedRow.put("@sentiment", sentimentScores);
            result.add(enhancedRow);
        }
        
        return result;
    }
    
    /**
     * Analyzes the sentiment of a text (simplified implementation)
     * Returns score between -1.0 (negative) and 1.0 (positive)
     */
    private static double analyzeSentiment(String text) {
        // This is a very simplified sentiment analysis
        // In a real system, use a proper NLP library
        
        String[] positiveWords = {
            "good", "great", "excellent", "wonderful", "amazing", "fantastic",
            "happy", "love", "like", "awesome", "best", "success", "positive"
        };
        
        String[] negativeWords = {
            "bad", "terrible", "awful", "horrible", "poor", "worst",
            "hate", "dislike", "failure", "negative", "disappointed", "upset", "angry"
        };
        
        String lowerText = text.toLowerCase();
        int positiveCount = 0;
        int negativeCount = 0;
        
        for (String word : positiveWords) {
            if (lowerText.contains(word)) {
                positiveCount++;
            }
        }
        
        for (String word : negativeWords) {
            if (lowerText.contains(word)) {
                negativeCount++;
            }
        }
        
        if (positiveCount == 0 && negativeCount == 0) {
            return 0.0; // Neutral
        }
        
        return (double) (positiveCount - negativeCount) / (positiveCount + negativeCount);
    }
    
    /**
     * Applies data augmentation to create variations
     */
    private static List<Map<String, Object>> applyDataAugmentation(
            List<Map<String, Object>> data, String[] fields) {
        
        List<Map<String, Object>> result = new ArrayList<>(data);
        
        for (Map<String, Object> row : data) {
            // Create variations
            for (String field : fields) {
                Object value = row.get(field);
                if (value instanceof String) {
                    // Create uppercase variation
                    Map<String, Object> uppercaseVariation = new HashMap<>(row);
                    uppercaseVariation.put(field, ((String) value).toUpperCase());
                    result.add(uppercaseVariation);
                    
                    // Create lowercase variation
                    Map<String, Object> lowercaseVariation = new HashMap<>(row);
                    lowercaseVariation.put(field, ((String) value).toLowerCase());
                    result.add(lowercaseVariation);
                    
                    // Create capitalized variation
                    Map<String, Object> capitalizedVariation = new HashMap<>(row);
                    String capitalizedValue = ((String) value).substring(0, 1).toUpperCase() +
                                             ((String) value).substring(1).toLowerCase();
                    capitalizedVariation.put(field, capitalizedValue);
                    result.add(capitalizedVariation);
                } else if (value instanceof Number) {
                    // Create incremented variation
                    Map<String, Object> incrementedVariation = new HashMap<>(row);
                    incrementedVariation.put(field, incrementValue(value));
                    result.add(incrementedVariation);
                    
                    // Create decremented variation
                    Map<String, Object> decrementedVariation = new HashMap<>(row);
                    decrementedVariation.put(field, decrementValue(value));
                    result.add(decrementedVariation);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Applies boundary value analysis to numeric fields
     */
    private static List<Map<String, Object>> applyBoundaryValues(
            List<Map<String, Object>> data, String[] fields) {
        
        List<Map<String, Object>> result = new ArrayList<>(data);
        
        for (Map<String, Object> row : data) {
            for (String field : fields) {
                Object value = row.get(field);
                if (value instanceof Number) {
                    // Create minimum variation
                    Map<String, Object> minVariation = new HashMap<>(row);
                    if (value instanceof Integer) {
                        minVariation.put(field, Integer.MIN_VALUE);
                    } else if (value instanceof Long) {
                        minVariation.put(field, Long.MIN_VALUE);
                    } else if (value instanceof Double) {
                        minVariation.put(field, Double.MIN_VALUE);
                    }
                    result.add(minVariation);
                    
                    // Create maximum variation
                    Map<String, Object> maxVariation = new HashMap<>(row);
                    if (value instanceof Integer) {
                        maxVariation.put(field, Integer.MAX_VALUE);
                    } else if (value instanceof Long) {
                        maxVariation.put(field, Long.MAX_VALUE);
                    } else if (value instanceof Double) {
                        maxVariation.put(field, Double.MAX_VALUE);
                    }
                    result.add(maxVariation);
                    
                    // Create zero variation
                    Map<String, Object> zeroVariation = new HashMap<>(row);
                    if (value instanceof Integer) {
                        zeroVariation.put(field, 0);
                    } else if (value instanceof Long) {
                        zeroVariation.put(field, 0L);
                    } else if (value instanceof Double) {
                        zeroVariation.put(field, 0.0);
                    }
                    result.add(zeroVariation);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Applies randomization to fields
     */
    private static List<Map<String, Object>> applyRandomization(
            List<Map<String, Object>> data, String[] fields) {
        
        Random random = new Random();
        List<Map<String, Object>> result = new ArrayList<>();
        
        for (Map<String, Object> row : data) {
            Map<String, Object> randomizedRow = new HashMap<>(row);
            
            for (String field : fields) {
                Object value = row.get(field);
                
                if (value instanceof String) {
                    // Randomize string
                    randomizedRow.put(field, generateRandomString(field, 10));
                } else if (value instanceof Integer) {
                    // Randomize integer
                    randomizedRow.put(field, random.nextInt(1000));
                } else if (value instanceof Long) {
                    // Randomize long
                    randomizedRow.put(field, random.nextLong() % 1000);
                } else if (value instanceof Double) {
                    // Randomize double
                    randomizedRow.put(field, random.nextDouble() * 1000);
                } else if (value instanceof Boolean) {
                    // Randomize boolean
                    randomizedRow.put(field, random.nextBoolean());
                }
            }
            
            result.add(randomizedRow);
        }
        
        return result;
    }
    
    /**
     * Applies relational mapping to maintain relationships between fields
     */
    private static List<Map<String, Object>> applyRelationalMapping(
            List<Map<String, Object>> data, String[] fields, String[] params) {
        
        // This is a simplified implementation
        // In a real system, this would be more sophisticated
        
        if (fields.length < 2 || params.length == 0) {
            return data;
        }
        
        List<Map<String, Object>> result = new ArrayList<>();
        
        String relationshipType = params[0];
        
        for (Map<String, Object> row : data) {
            Map<String, Object> mappedRow = new HashMap<>(row);
            
            if ("address".equals(relationshipType)) {
                // Handle address-related fields (city, state, zip)
                String city = "";
                String state = "";
                String zipCode = "";
                
                // Map well-known US city/state/zip combinations
                if (containsField(fields, "city")) {
                    city = "Seattle";
                    mappedRow.put("city", city);
                }
                
                if (containsField(fields, "state")) {
                    state = "Washington";
                    mappedRow.put("state", state);
                }
                
                if (containsField(fields, "zipCode") || containsField(fields, "zip")) {
                    zipCode = "98101";
                    if (containsField(fields, "zipCode")) {
                        mappedRow.put("zipCode", zipCode);
                    }
                    if (containsField(fields, "zip")) {
                        mappedRow.put("zip", zipCode);
                    }
                }
            } else if ("name".equals(relationshipType)) {
                // Handle name-related fields (firstName, lastName, fullName)
                String firstName = "John";
                String lastName = "Doe";
                
                if (containsField(fields, "firstName")) {
                    mappedRow.put("firstName", firstName);
                }
                
                if (containsField(fields, "lastName")) {
                    mappedRow.put("lastName", lastName);
                }
                
                if (containsField(fields, "fullName")) {
                    mappedRow.put("fullName", firstName + " " + lastName);
                }
            } else if ("payment".equals(relationshipType)) {
                // Handle payment-related fields
                if (containsField(fields, "cardType")) {
                    mappedRow.put("cardType", "Visa");
                }
                
                if (containsField(fields, "cardNumber")) {
                    mappedRow.put("cardNumber", "4111111111111111");
                }
                
                if (containsField(fields, "expiryDate")) {
                    mappedRow.put("expiryDate", "12/25");
                }
                
                if (containsField(fields, "cvv")) {
                    mappedRow.put("cvv", "123");
                }
            }
            
            result.add(mappedRow);
        }
        
        return result;
    }
    
    /**
     * Checks if a field name is in the array
     */
    private static boolean containsField(String[] fields, String fieldName) {
        for (String field : fields) {
            if (field.equals(fieldName)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Applies filtering to the data
     */
    private static List<Map<String, Object>> applyFiltering(List<Map<String, Object>> data, String filter) {
        // This is a simplified implementation
        // In a real system, this would be a proper expression evaluator
        
        if (filter.isEmpty()) {
            return data;
        }
        
        return data.stream()
            .filter(row -> evaluateFilter(row, filter))
            .collect(Collectors.toList());
    }
    
    /**
     * Evaluates a filter expression
     */
    private static boolean evaluateFilter(Map<String, Object> row, String filter) {
        // Very simplified filter evaluation
        // Only handles basic comparisons like "field > value"
        
        // Extract field, operator, and value from filter
        Pattern pattern = Pattern.compile("@([\\w.]+)\\s*([<>=!]+)\\s*([\\w.\"']+)");
        Matcher matcher = pattern.matcher(filter);
        
        if (matcher.find()) {
            String fieldPath = matcher.group(1);
            String operator = matcher.group(2);
            String valueStr = matcher.group(3);
            
            // Handle quoted strings
            if (valueStr.startsWith("\"") && valueStr.endsWith("\"") ||
                valueStr.startsWith("'") && valueStr.endsWith("'")) {
                valueStr = valueStr.substring(1, valueStr.length() - 1);
            }
            
            // Resolve field path (supports nested fields like sentiment.comment)
            Object fieldValue = resolveFieldPath(row, fieldPath);
            
            if (fieldValue == null) {
                return false;
            }
            
            // Try to convert value to appropriate type
            Object value;
            if (fieldValue instanceof Number) {
                try {
                    value = Double.parseDouble(valueStr);
                } catch (NumberFormatException e) {
                    return false;
                }
            } else {
                value = valueStr;
            }
            
            // Compare based on operator
            switch (operator) {
                case "==":
                case "=":
                    return fieldValue.equals(value);
                case "!=":
                    return !fieldValue.equals(value);
                case ">":
                    if (fieldValue instanceof Number && value instanceof Number) {
                        return ((Number) fieldValue).doubleValue() > ((Number) value).doubleValue();
                    }
                    return false;
                case "<":
                    if (fieldValue instanceof Number && value instanceof Number) {
                        return ((Number) fieldValue).doubleValue() < ((Number) value).doubleValue();
                    }
                    return false;
                case ">=":
                    if (fieldValue instanceof Number && value instanceof Number) {
                        return ((Number) fieldValue).doubleValue() >= ((Number) value).doubleValue();
                    }
                    return false;
                case "<=":
                    if (fieldValue instanceof Number && value instanceof Number) {
                        return ((Number) fieldValue).doubleValue() <= ((Number) value).doubleValue();
                    }
                    return false;
                default:
                    return false;
            }
        }
        
        // Handle AND operator
        if (filter.contains("&&")) {
            String[] parts = filter.split("&&");
            return evaluateFilter(row, parts[0].trim()) && evaluateFilter(row, parts[1].trim());
        }
        
        // Handle OR operator
        if (filter.contains("||")) {
            String[] parts = filter.split("\\|\\|");
            return evaluateFilter(row, parts[0].trim()) || evaluateFilter(row, parts[1].trim());
        }
        
        return true; // Default pass if filter is not recognized
    }
    
    /**
     * Resolves a field path to get the value
     */
    @SuppressWarnings("unchecked")
    private static Object resolveFieldPath(Map<String, Object> row, String fieldPath) {
        String[] parts = fieldPath.split("\\.");
        Object current = row;
        
        for (String part : parts) {
            if (current instanceof Map) {
                current = ((Map<String, Object>) current).get(part);
                if (current == null) {
                    return null;
                }
            } else {
                return null;
            }
        }
        
        return current;
    }
    
    /**
     * Converts the data to TestNG format
     */
    private static List<Object[]> convertToTestNGFormat(List<Map<String, Object>> data, Method testMethod) {
        List<Object[]> result = new ArrayList<>();
        
        // Determine parameter types
        Class<?>[] parameterTypes = testMethod.getParameterTypes();
        
        for (Map<String, Object> row : data) {
            if (parameterTypes.length == 1 && Map.class.isAssignableFrom(parameterTypes[0])) {
                // Method expects a single Map parameter
                result.add(new Object[] { row });
            } else {
                // Method expects individual parameters
                Object[] rowData = new Object[parameterTypes.length];
                
                // Match parameters by name
                java.lang.reflect.Parameter[] parameters = testMethod.getParameters();
                
                for (int i = 0; i < parameters.length; i++) {
                    String paramName = parameters[i].getName();
                    Object value = row.get(paramName);
                    
                    // Convert value to expected type if needed
                    if (value != null && !parameterTypes[i].isAssignableFrom(value.getClass())) {
                        value = convertToType(value, parameterTypes[i]);
                    }
                    
                    rowData[i] = value;
                }
                
                result.add(rowData);
            }
        }
        
        return result;
    }
    
    /**
     * Converts a value to the expected type
     */
    private static Object convertToType(Object value, Class<?> targetType) {
        if (value == null) {
            return null;
        }
        
        if (targetType.isAssignableFrom(value.getClass())) {
            return value;
        }
        
        if (targetType == String.class) {
            return value.toString();
        } else if (targetType == Integer.class || targetType == int.class) {
            if (value instanceof Number) {
                return ((Number) value).intValue();
            } else {
                return Integer.parseInt(value.toString());
            }
        } else if (targetType == Long.class || targetType == long.class) {
            if (value instanceof Number) {
                return ((Number) value).longValue();
            } else {
                return Long.parseLong(value.toString());
            }
        } else if (targetType == Double.class || targetType == double.class) {
            if (value instanceof Number) {
                return ((Number) value).doubleValue();
            } else {
                return Double.parseDouble(value.toString());
            }
        } else if (targetType == Float.class || targetType == float.class) {
            if (value instanceof Number) {
                return ((Number) value).floatValue();
            } else {
                return Float.parseFloat(value.toString());
            }
        } else if (targetType == Boolean.class || targetType == boolean.class) {
            if (value instanceof Number) {
                return ((Number) value).intValue() != 0;
            } else {
                return Boolean.parseBoolean(value.toString());
            }
        } else if (targetType == Date.class) {
            try {
                return new SimpleDateFormat("yyyy-MM-dd").parse(value.toString());
            } catch (Exception e) {
                return null;
            }
        }
        
        return value; // Return as is if no conversion available
    }
}


package com.cssmart.framework.testng;

import com.cssmart.framework.annotation.CSSmartDataProvider;
import com.cssmart.framework.data.CSSmartDataEngine;
import com.cssmart.framework.logging.CSSmartLogger;
import org.testng.ITestNGMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.ITestAnnotation;
import org.testng.internal.annotations.IAnnotationTransformer;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.List;

/**
 * TestNG integration for the CSSmartDataProvider
 */
public class CSSmartDataProviderFactory implements IAnnotationTransformer {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartDataProviderFactory.class);
    private static final String SMART_DATA_PROVIDER_NAME = "csmartDataProvider";
    
    /**
     * Transforms TestNG annotations to integrate with CSSmartDataProvider
     */
    @Override
    public void transform(ITestAnnotation annotation, Class testClass, Constructor testConstructor, Method testMethod) {
        CSSmartDataProvider smartDataProvider = testMethod.getAnnotation(CSSmartDataProvider.class);
        
        if (smartDataProvider != null) {
            // Set the data provider name
            annotation.setDataProvider(SMART_DATA_PROVIDER_NAME);
            
            // Set the data provider class to this factory
            annotation.setDataProviderClass(CSSmartDataProviderFactory.class);
        }
    }
    
    /**
     * The TestNG data provider that works with CSSmartDataProvider
     */
    @DataProvider(name = SMART_DATA_PROVIDER_NAME)
    public static Object[][] csmartDataProvider(ITestNGMethod method) {
        try {
            Method testMethod = method.getConstructorOrMethod().getMethod();
            CSSmartDataProvider annotation = testMethod.getAnnotation(CSSmartDataProvider.class);
            
            if (annotation == null) {
                logger.error("CSSmartDataProvider annotation not found on method: " + testMethod.getName());
                return new Object[0][0];
            }
            
            // Get the test data from the engine
            List<Object[]> testData = CSSmartDataEngine.getTestData(annotation, testMethod);
            
            // Convert to 2D array
            Object[][] result = new Object[testData.size()][];
            for (int i = 0; i < testData.size(); i++) {
                result[i] = testData.get(i);
            }
            
            logger.info("Generated " + result.length + " test data rows for method: " + testMethod.getName());
            return result;
            
        } catch (Exception e) {
            logger.error("Error in data provider", e);
            return new Object[0][0];
        }
    }
}



package com.cssmart.example;

import com.cssmart.framework.annotation.*;
import com.cssmart.framework.ai.CSSmartAITestRecommender;
import com.cssmart.framework.bdd.CSSmartBddTestNGBridge;
import com.cssmart.framework.element.CSSmartWebElement;
import com.cssmart.framework.enums.*;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;

/**
 * Example showing how to use the CSSmartFramework with all its AI-powered features
 */
public class CSSmartFrameworkExample extends CSSmartBddTestNGBridge {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartFrameworkExample.class);
    private WebDriver driver;
    
    @BeforeClass
    public void setup() {
        // Initialize WebDriver
        driver = new ChromeDriver();
        driver.manage().window().maximize();
        
        // Register step definitions for BDD
        registerStepDefinitions(new LoginSteps(driver), new HomePageSteps(driver));
    }
    
    @AfterClass
    public void tearDown() {
        // Generate BDD reports
        generateFeatureFiles("target/bdd-features");
        generateHTMLReport("target/bdd-reports");
        
        // Close the driver
        if (driver != null) {
            driver.quit();
        }
    }
    
    /**
     * Example test using CSSmartFindBy with AI-powered element location
     */
    @Test
    public void testAIElementLocation() {
        driver.get("https://example.com/login");
        
        // Access a page with CSSmartFindBy elements
        LoginPage loginPage = new LoginPage(driver);
        
        // Use self-healing elements
        loginPage.enterUsername("testuser");
        loginPage.enterPassword("password");
        loginPage.clickLogin();
        
        // Assert that login was successful
        HomePage homePage = new HomePage(driver);
        Assert.assertTrue(homePage.isWelcomeMessageDisplayed(), "Login failed");
    }
    
    /**
     * Example test using AI-powered data generation and smart test step
     */
    @CSSmartTestStep(
        description = "I test login with generated data", 
        category = StepCategory.ACTION, 
        importance = Importance.CRITICAL,
        takeScreenshot = ScreenshotType.BEFORE_AND_AFTER
    )
    @CSSmartDataProvider(
        type = DataSourceType.SMART_GENERATION,
        targetForm = "loginForm",
        coverage = Coverage.COMPREHENSIVE,
        constraints = {
            @Constraint(field = "username", type = "string"),
            @Constraint(field = "password", type = "string", min = "8")
        }
    )
    @Test
    public void testLoginWithGeneratedData(Map<String, Object> data) {
        driver.get("https://example.com/login");
        
        LoginPage loginPage = new LoginPage(driver);
        
        // Use the generated data
        loginPage.enterUsername((String) data.get("username"));
        loginPage.enterPassword((String) data.get("password"));
        loginPage.clickLogin();
        
        // Assert that login was successful if using valid data
        if (data.containsKey("valid") && (Boolean) data.get("valid")) {
            HomePage homePage = new HomePage(driver);
            Assert.assertTrue(homePage.isWelcomeMessageDisplayed(), "Login failed with valid data");
        } else {
            // Assert that error message is displayed for invalid data
            Assert.assertTrue(loginPage.isErrorMessageDisplayed(), "No error message for invalid data");
        }
    }
    
    /**
     * Example test using BDD-TestNG bridge
     */
    @CSSmartScenario(
        feature = "User Authentication",
        scenario = "Login with valid credentials",
        steps = {
            "Given I am on the login page",
            "When I enter valid user credentials",
            "And I click the login button",
            "Then I should be logged in successfully"
        },
        tags = {"smoke", "authentication"}
    )
    @Test
    public void testLoginWithBdd() {
        // The framework will execute the BDD steps
        // No code needed here as the steps are defined in the step classes
    }
    
    /**
     * Example test using AI test path analyzer
     */
    @Test
    public void testAIPathAnalysis() {
        driver.get("https://example.com");
        
        // Use the AI test recommender to find optimal test paths
        CSSmartAITestRecommender recommender = new CSSmartAITestRecommender();
        List<CSSmartAITestRecommender.TestPath> optimalPaths = recommender.findOptimalTestPaths(driver, "https://example.com");
        
        // Find edge cases
        List<CSSmartAITestRecommender.EdgeCase> edgeCases = recommender.identifyEdgeCases(optimalPaths);
        
        // Perform risk analysis
        List<CSSmartAITestRecommender.RiskAnalysis> riskAnalyses = recommender.performRiskAnalysis(optimalPaths);
        
        // Log the results
        logger.info("Found " + optimalPaths.size() + " optimal test paths");
        logger.info("Identified " + edgeCases.size() + " edge cases");
        logger.info("Completed risk analysis for " + riskAnalyses.size() + " paths");
        
        // Execute the highest priority test path
        if (!optimalPaths.isEmpty()) {
            CSSmartAITestRecommender.TestPath topPath = optimalPaths.get(0);
            logger.info("Executing highest priority path: " + topPath.getName());
            
            // In a real implementation, we'd execute the path actions here
        }
    }
    
    /**
     * Example test using sentiment analysis
     */
    @CSSmartDataProvider(
        type = DataSourceType.JSON,
        path = "user-comments.json",
        preprocessing = {
            @Transformation(type = TransformType.SENTIMENT_ANALYSIS, fields = {"comment"})
        },
        filtering = "@sentiment.comment > 0.5"
    )
    @Test
    public void testUserProfileWithSentimentData(Map<String, Object> userData) {
        // This test would only run with positive sentiment comments
        driver.get("https://example.com/profile");
        
        // Access the sentiment scores
        @SuppressWarnings("unchecked")
        Map<String, Double> sentiment = (Map<String, Double>) userData.get("@sentiment");
        double commentSentiment = sentiment.get("comment");
        
        logger.info("Testing with positive comment (sentiment: " + commentSentiment + ")");
        
        // Use the data for testing
        ProfilePage profilePage = new ProfilePage(driver);
        profilePage.enterComment((String) userData.get("comment"));
        profilePage.submitComment();
        
        // Assert the comment was posted
        Assert.assertTrue(profilePage.isCommentPosted(), "Comment was not posted");
    }
    
    /**
     * Example test using accessibility analysis
     */
    @Test
    public void testAccessibility() {
        driver.get("https://example.com");
        
        // Perform accessibility analysis
        CSSmartAITestRecommender recommender = new CSSmartAITestRecommender();
        CSSmartAITestRecommender.AccessibilityAnalysis analysis = recommender.analyzeAccessibility(driver, "AA");
        
        // Log the results
        logger.info("Accessibility compliance score: " + analysis.getComplianceScore() + "/100");
        logger.info("Compliance status: " + analysis.getComplianceStatus());
        logger.info("Found " + analysis.getIssues().size() + " accessibility issues");
        
        // Assert a minimum compliance score
        Assert.assertTrue(analysis.getComplianceScore() >= 70, 
            "Accessibility score below threshold: " + analysis.getComplianceScore());
    }
}

/**
 * Example login page with self-healing elements
 */
class LoginPage {
    private final WebDriver driver;
    
    @CSSmartFindBy(
        description = "Username field in the login form", 
        useAI = true,
        contextAware = true,
        fingerprint = true,
        failureHandling = FailureHandling.SELF_HEAL,
        priority = {LocatorStrategy.SEMANTIC, LocatorStrategy.DOM, LocatorStrategy.VISUAL},
        alternateLocators = {
            @AlternateLocator(id = "username"),
            @AlternateLocator(name = "username"),
            @AlternateLocator(css = "input[type='text']")
        }
    )
    private CSSmartWebElement usernameField;
    
    @CSSmartFindBy(
        description = "Password field in the login form", 
        useAI = true,
        contextAware = true,
        fingerprint = true,
        failureHandling = FailureHandling.SELF_HEAL,
        priority = {LocatorStrategy.SEMANTIC, LocatorStrategy.DOM, LocatorStrategy.VISUAL},
        alternateLocators = {
            @AlternateLocator(id = "password"),
            @AlternateLocator(name = "password"),
            @AlternateLocator(css = "input[type='password']")
        }
    )
    private CSSmartWebElement passwordField;
    
    @CSSmartFindBy(
        description = "Login button on the login form", 
        useAI = true,
        contextAware = true,
        fingerprint = true,
        failureHandling = FailureHandling.SELF_HEAL,
        priority = {LocatorStrategy.SEMANTIC, LocatorStrategy.DOM, LocatorStrategy.VISUAL},
        alternateLocators = {
            @AlternateLocator(id = "login-button"),
            @AlternateLocator(css = "button[type='submit']"),
            @AlternateLocator(xpath = "//button[contains(text(), 'Login')]")
        }
    )
    private CSSmartWebElement loginButton;
    
    @CSSmartFindBy(
        description = "Error message on the login form", 
        useAI = true,
        failureHandling = FailureHandling.CONTINUE
    )
    private CSSmartWebElement errorMessage;
    
    public LoginPage(WebDriver driver) {
        this.driver = driver;
        // In a real implementation, we'd use a page factory to initialize elements
    }
    
    public void enterUsername(String username) {
        usernameField.smartWait().clear();
        usernameField.sendKeys(username);
    }
    
    public void enterPassword(String password) {
        passwordField.smartWait().clear();
        passwordField.sendKeys(password);
    }
    
    public void clickLogin() {
        loginButton.smartWait().click();
    }
    
    public boolean isErrorMessageDisplayed() {
        try {
            return errorMessage.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * Example home page with self-healing elements
 */
class HomePage {
    private final WebDriver driver;
    
    @CSSmartFindBy(
        description = "Welcome message on the home page", 
        useAI = true,
        failureHandling = FailureHandling.SELF_HEAL
    )
    private CSSmartWebElement welcomeMessage;
    
    public HomePage(WebDriver driver) {
        this.driver = driver;
        // In a real implementation, we'd use a page factory to initialize elements
    }
    
    public boolean isWelcomeMessageDisplayed() {
        try {
            return welcomeMessage.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * Example profile page with self-healing elements
 */
class ProfilePage {
    private final WebDriver driver;
    
    @CSSmartFindBy(
        description = "Comment field on the profile page", 
        useAI = true,
        failureHandling = FailureHandling.SELF_HEAL
    )
    private CSSmartWebElement commentField;
    
    @CSSmartFindBy(
        description = "Submit comment button", 
        useAI = true,
        failureHandling = FailureHandling.SELF_HEAL
    )
    private CSSmartWebElement submitButton;
    
    @CSSmartFindBy(
        description = "Posted comment confirmation", 
        useAI = true,
        failureHandling = FailureHandling.CONTINUE
    )
    private CSSmartWebElement postedComment;
    
    public ProfilePage(WebDriver driver) {
        this.driver = driver;
        // In a real implementation, we'd use a page factory to initialize elements
    }
    
    public void enterComment(String comment) {
        commentField.smartWait().clear();
        commentField.sendKeys(comment);
    }
    
    public void submitComment() {
        submitButton.smartWait().click();
    }
    
    public boolean isCommentPosted() {
        try {
            return postedComment.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}

/**
 * Example BDD step definitions for login
 */
class LoginSteps {
    private final WebDriver driver;
    private LoginPage loginPage;
    
    public LoginSteps(WebDriver driver) {
        this.driver = driver;
    }
    
    @CSSmartTestStep(description = "I am on the login page")
    public void navigateToLoginPage() {
        driver.get("https://example.com/login");
        loginPage = new LoginPage(driver);
    }
    
    @CSSmartTestStep(description = "I enter valid user credentials")
    public void enterValidCredentials() {
        loginPage.enterUsername("testuser");
        loginPage.enterPassword("password");
    }
    
    @CSSmartTestStep(description = "I click the login button")
    public void clickLoginButton() {
        loginPage.clickLogin();
    }
}

/**
 * Example BDD step definitions for home page
 */
class HomePageSteps {
    private final WebDriver driver;
    private HomePage homePage;
    
    public HomePageSteps(WebDriver driver) {
        this.driver = driver;
    }
    
    @CSSmartTestStep(description = "I should be logged in successfully")
    public void verifySuccessfulLogin() {
        homePage = new HomePage(driver);
        Assert.assertTrue(homePage.isWelcomeMessageDisplayed(), "Login was not successful");
    }
}



