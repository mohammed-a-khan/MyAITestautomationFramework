# CSSmartFramework Project Structure

```
src/
├── main/
│   ├── java/
│   │   └── com/
│   │       └── cssmart/
│   │           ├── base/
│   │           │   ├── CSSmartBasePage.java
│   │           │   ├── CSSmartBaseTest.java
│   │           │   ├── CSSmartElement.java
│   │           │   ├── CSSmartPageFactory.java
│   │           │   ├── CSSmartBaseSetup.java
│   │           │   └── CSSmartBaseTeardown.java
│   │           ├── exceptions/
│   │           │   ├── CSSmartException.java
│   │           │   ├── CSSmartDriverException.java
│   │           │   ├── CSSmartElementException.java
│   │           │   ├── CSSmartConfigException.java
│   │           │   ├── CSSmartAPIException.java
│   │           │   ├── CSSmartDBException.java
│   │           │   └── CSSmartBDDException.java
│   │           ├── logging/
│   │           │   └── CSSmartLogger.java
│   │           ├── reporting/
│   │           │   ├── CSSmartReport.java
│   │           │   ├── CSSmartReportManager.java
│   │           │   └── templates/
│   │           │       ├── report.html
│   │           │       └── dashboard.html
│   │           ├── config/
│   │           │   ├── CSSmartConfig.java
│   │           │   └── CSSmartPropertyManager.java
│   │           ├── driver/
│   │           │   ├── CSSmartDriver.java
│   │           │   ├── CSSmartWebElement.java
│   │           │   ├── CSSmartFindBy.java
│   │           │   ├── CSSmartFindByProcessor.java
│   │           │   └── CSSmartWait.java
│   │           ├── ai/
│   │           │   ├── CSSmartAIAnalyzer.java
│   │           │   ├── CSSmartAIElementFinder.java
│   │           │   ├── CSSmartAIContextAnalyzer.java
│   │           │   └── CSSmartAITestRecommender.java
│   │           ├── annotations/
│   │           │   ├── CSSmartTestStep.java
│   │           │   ├── CSSmartDataProvider.java
│   │           │   ├── CSSmartADOTest.java
│   │           │   └── CSSmartAnnotationProcessor.java
│   │           ├── bdd/
│   │           │   ├── CSSmartBDDTestFactory.java
│   │           │   ├── CSSmartBDDScanner.java
│   │           │   ├── CSSmartBDDExecutor.java
│   │           │   ├── CSSmartBDDParser.java
│   │           │   ├── CSSmartBDDHooks.java
│   │           │   ├── CSSmartBDDContext.java
│   │           │   └── CSSmartCodelessRunner.java
│   │           ├── api/
│   │           │   ├── CSSmartAPIClient.java
│   │           │   ├── CSSmartAPIRequest.java
│   │           │   ├── CSSmartAPIResponse.java
│   │           │   ├── CSSmartAPIValidator.java
│   │           │   ├── CSSmartAPIAssertion.java
│   │           │   ├── CSSmartAPIAuth.java
│   │           │   └── CSSmartAPIChaining.java
│   │           ├── data/
│   │           │   ├── CSSmartDataProvider.java
│   │           │   ├── CSSmartExcelReader.java
│   │           │   ├── CSSmartCSVReader.java
│   │           │   ├── CSSmartJSONReader.java
│   │           │   ├── CSSmartDBDataSource.java
│   │           │   ├── CSSmartDataTransformer.java
│   │           │   └── CSSmartDataProviderRegistry.java
│   │           ├── db/
│   │           │   ├── CSSmartDBConnection.java
│   │           │   ├── CSSmartDBQuery.java
│   │           │   ├── CSSmartDBComparator.java
│   │           │   └── CSSmartDBProcedure.java
│   │           ├── mobile/
│   │           │   ├── CSSmartMobileDriver.java
│   │           │   ├── CSSmartMobileElement.java
│   │           │   ├── CSSmartMobileGestures.java
│   │           │   └── CSSmartDeviceFarm.java
│   │           ├── parallel/
│   │           │   ├── CSSmartParallelExecutor.java
│   │           │   ├── CSSmartThreadManager.java
│   │           │   └── CSSmartResourceManager.java
│   │           ├── testng/
│   │           │   ├── CSSmartTestNGExecutor.java
│   │           │   ├── CSSmartTestNGListener.java
│   │           │   └── CSSmartTestNGReporter.java
│   │           ├── ado/
│   │           │   ├── CSSmartADOIntegration.java
│   │           │   ├── CSSmartADOTestPlan.java
│   │           │   ├── CSSmartADOTestCase.java
│   │           │   ├── CSSmartADOTestResult.java
│   │           │   └── CSSmartADOAttachment.java
│   │           └── advanced/
│   │               ├── CSSmartVisualTesting.java
│   │               ├── CSSmartPerformanceMonitor.java
│   │               ├── CSSmartCodelessBuilder.java
│   │               └── CSSmartDocGenerator.java
│   └── resources/
│       ├── application.properties
│       ├── config.yaml
│       ├── log4j2.xml
│       └── templates/
│           ├── report-template.html
│           └── dashboard-template.html
└── test/
    ├── java/
    │   └── com/
    │       └── cssmart/
    │           ├── examples/
    │           │   ├── web/
    │           │   │   ├── pages/
    │           │   │   │   ├── LoginPage.java
    │           │   │   │   └── HomePage.java
    │           │   │   └── tests/
    │           │   │       └── LoginTest.java
    │           │   ├── api/
    │           │   │   └── APITestExample.java
    │           │   ├── bdd/
    │           │   │   └── StepDefinitions.java
    │           │   └── mobile/
    │           │       └── MobileTestExample.java
    │           └── unit/
    │               └── ... (unit tests for framework components)
    └── resources/
        ├── features/
        │   ├── login.feature
        │   └── api-test.feature
        ├── testng.xml
        └── test-data/
            ├── users.json
            ├── test-data.xlsx
            └── api-payloads/
                ├── create-user.json
                └── update-user.json
```

This structure organizes the framework into logical modules, with each module containing related components. The framework follows standard Maven project layout with source code in `src/main/java` and test code in `src/test/java`. Configuration files and resources are stored in the corresponding resources directories.


/**
 * CSSmartBasePage.java
 * Base class for all page objects with common page operations
 */
package com.cssmart.base;

import com.cssmart.driver.CSSmartDriver;
import com.cssmart.driver.CSSmartWebElement;
import com.cssmart.driver.CSSmartWait;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.support.PageFactory;

public abstract class CSSmartBasePage {
    protected CSSmartDriver driver;
    protected CSSmartWait wait;
    protected CSSmartLogger logger;
    protected CSSmartReport report;
    protected String pageName;
    
    public CSSmartBasePage(CSSmartDriver driver, String pageName) {
        this.driver = driver;
        this.wait = new CSSmartWait(driver);
        this.logger = CSSmartLogger.getInstance();
        this.report = CSSmartReport.getInstance();
        this.pageName = pageName;
        
        // Initialize page elements
        CSSmartPageFactory.initElements(driver, this);
        
        report.logInfo("Initialized page: " + pageName);
    }
    
    /**
     * Verify that the page is loaded
     * @return true if the page is loaded successfully
     */
    public abstract boolean isPageLoaded();
    
    /**
     * Get page title
     * @return the title of the page
     */
    public String getPageTitle() {
        String title = driver.getTitle();
        report.logInfo("Page title: " + title);
        return title;
    }
    
    /**
     * Navigate to a URL
     * @param url the URL to navigate to
     */
    public void navigateTo(String url) {
        driver.get(url);
        report.logInfo("Navigated to URL: " + url);
    }
    
    /**
     * Execute JavaScript
     * @param script the JavaScript to execute
     * @param args the arguments to pass to the script
     * @return the result of the script execution
     */
    public Object executeScript(String script, Object... args) {
        report.logInfo("Executing JavaScript: " + script);
        return ((JavascriptExecutor) driver.getWrappedDriver()).executeScript(script, args);
    }
    
    /**
     * Find a CSSmartWebElement by locator
     * @param locator the By locator
     * @return a CSSmartWebElement
     */
    protected CSSmartWebElement findElement(By locator) {
        return driver.findElement(locator);
    }
    
    /**
     * Take a screenshot of the current page
     * @param screenshotName the name of the screenshot
     * @return the path to the saved screenshot
     */
    public String takeScreenshot(String screenshotName) {
        return report.takeScreenshot(driver, screenshotName);
    }
}

/**
 * CSSmartBaseTest.java
 * Base class for all test classes with common test functionality
 */
package com.cssmart.base;

import com.cssmart.driver.CSSmartDriver;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;

import java.lang.reflect.Method;

public abstract class CSSmartBaseTest {
    protected CSSmartDriver driver;
    protected CSSmartLogger logger;
    protected CSSmartReport report;
    protected CSSmartBaseSetup setup;
    protected CSSmartBaseTeardown teardown;
    
    @BeforeSuite(alwaysRun = true)
    public void suiteSetup() {
        report = CSSmartReport.getInstance();
        logger = CSSmartLogger.getInstance();
        setup = new CSSmartBaseSetup();
        teardown = new CSSmartBaseTeardown();
        
        report.startSuite(getClass().getSimpleName());
        logger.info("Suite setup completed for: " + getClass().getSimpleName());
    }
    
    @BeforeMethod(alwaysRun = true)
    public void methodSetup(Method method) {
        // Initialize driver
        driver = setup.initializeDriver();
        
        // Start test reporting
        report.startTest(method.getName(), method.getAnnotation(org.testng.annotations.Test.class).description());
        logger.info("Test started: " + method.getName());
    }
    
    @AfterMethod(alwaysRun = true)
    public void methodTeardown(ITestResult result) {
        // Capture screenshot on failure
        if (result.getStatus() == ITestResult.FAILURE) {
            report.takeScreenshot(driver, "FAILURE_" + result.getName());
            logger.error("Test failed: " + result.getName());
        }
        
        // End test reporting
        report.endTest(result);
        
        // Quit driver
        teardown.quitDriver(driver);
        
        logger.info("Test completed: " + result.getName() + " with status: " + getTestStatusName(result.getStatus()));
    }
    
    @AfterSuite(alwaysRun = true)
    public void suiteTeardown() {
        report.endSuite();
        logger.info("Suite teardown completed for: " + getClass().getSimpleName());
    }
    
    private String getTestStatusName(int status) {
        switch (status) {
            case 1:
                return "SUCCESS";
            case 2:
                return "FAILURE";
            case 3:
                return "SKIP";
            default:
                return "UNKNOWN";
        }
    }
}

/**
 * CSSmartElement.java
 * Base element class with enhanced interactions
 */
package com.cssmart.base;

import com.cssmart.driver.CSSmartWebElement;
import com.cssmart.driver.CSSmartDriver;
import com.cssmart.driver.CSSmartWait;
import com.cssmart.exceptions.CSSmartElementException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;

public class CSSmartElement {
    protected CSSmartWebElement element;
    protected CSSmartDriver driver;
    protected CSSmartWait wait;
    protected CSSmartLogger logger;
    protected CSSmartReport report;
    protected String elementName;
    
    public CSSmartElement(CSSmartDriver driver, By locator, String elementName) {
        this.driver = driver;
        this.wait = new CSSmartWait(driver);
        this.logger = CSSmartLogger.getInstance();
        this.report = CSSmartReport.getInstance();
        this.elementName = elementName;
        
        try {
            this.element = driver.findElement(locator);
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to initialize element: " + elementName, e);
        }
    }
    
    public CSSmartElement(CSSmartWebElement element, String elementName) {
        this.element = element;
        this.elementName = elementName;
        this.logger = CSSmartLogger.getInstance();
        this.report = CSSmartReport.getInstance();
    }
    
    /**
     * Click on the element
     * @return this element for chaining
     */
    public CSSmartElement click() {
        try {
            wait.waitForElementClickable(element);
            element.click();
            report.logInfo("Clicked on element: " + elementName);
            return this;
        } catch (Exception e) {
            report.logError("Failed to click on element: " + elementName);
            throw new CSSmartElementException("Failed to click on element: " + elementName, e);
        }
    }
    
    /**
     * Type text into the element
     * @param text the text to type
     * @return this element for chaining
     */
    public CSSmartElement sendKeys(String text) {
        try {
            wait.waitForElementVisible(element);
            element.clear();
            element.sendKeys(text);
            report.logInfo("Typed text into element: " + elementName + ", text: " + text);
            return this;
        } catch (Exception e) {
            report.logError("Failed to type text into element: " + elementName);
            throw new CSSmartElementException("Failed to type text into element: " + elementName, e);
        }
    }
    
    /**
     * Get text from the element
     * @return the text of the element
     */
    public String getText() {
        try {
            wait.waitForElementVisible(element);
            String text = element.getText();
            report.logInfo("Got text from element: " + elementName + ", text: " + text);
            return text;
        } catch (Exception e) {
            report.logError("Failed to get text from element: " + elementName);
            throw new CSSmartElementException("Failed to get text from element: " + elementName, e);
        }
    }
    
    /**
     * Check if the element is displayed
     * @return true if the element is displayed
     */
    public boolean isDisplayed() {
        try {
            boolean displayed = element.isDisplayed();
            report.logInfo("Element " + elementName + " is displayed: " + displayed);
            return displayed;
        } catch (Exception e) {
            report.logInfo("Element " + elementName + " is not displayed");
            return false;
        }
    }
    
    /**
     * Get the underlying WebElement
     * @return the WebElement
     */
    public WebElement getWebElement() {
        return element.getWrappedElement();
    }
}

/**
 * CSSmartPageFactory.java
 * Custom page factory for initializing page objects
 */
package com.cssmart.base;

import com.cssmart.driver.CSSmartDriver;
import com.cssmart.driver.CSSmartFindBy;
import com.cssmart.driver.CSSmartFindByProcessor;
import com.cssmart.driver.CSSmartWebElement;
import com.cssmart.exceptions.CSSmartElementException;
import com.cssmart.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.pagefactory.DefaultElementLocatorFactory;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class CSSmartPageFactory {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartFindByProcessor findByProcessor = new CSSmartFindByProcessor();
    
    /**
     * Initialize page elements
     * @param driver the CSSmartDriver
     * @param pageObject the page object to initialize
     */
    public static void initElements(CSSmartDriver driver, Object pageObject) {
        logger.info("Initializing page elements for: " + pageObject.getClass().getSimpleName());
        
        // First use Selenium's PageFactory for standard annotations
        PageFactory.initElements(driver.getWrappedDriver(), pageObject);
        
        // Then process our custom annotations
        processCSSmartAnnotations(driver, pageObject);
    }
    
    /**
     * Process custom annotations
     * @param driver the CSSmartDriver
     * @param pageObject the page object to process
     */
    private static void processCSSmartAnnotations(CSSmartDriver driver, Object pageObject) {
        Class<?> pageObjectClass = pageObject.getClass();
        
        for (Field field : pageObjectClass.getDeclaredFields()) {
            if (field.isAnnotationPresent(CSSmartFindBy.class)) {
                CSSmartFindBy annotation = field.getAnnotation(CSSmartFindBy.class);
                By locator = findByProcessor.processAnnotation(annotation);
                
                if (locator != null) {
                    try {
                        field.setAccessible(true);
                        
                        if (field.getType() == CSSmartWebElement.class) {
                            CSSmartWebElement element = createCSSmartWebElement(driver, locator, field.getName());
                            field.set(pageObject, element);
                        }
                    } catch (IllegalAccessException e) {
                        throw new CSSmartElementException("Failed to set field value for: " + field.getName(), e);
                    }
                }
            }
        }
    }
    
    /**
     * Create a CSSmartWebElement
     * @param driver the CSSmartDriver
     * @param locator the By locator
     * @param elementName the name of the element
     * @return a CSSmartWebElement
     */
    private static CSSmartWebElement createCSSmartWebElement(CSSmartDriver driver, By locator, String elementName) {
        return new CSSmartWebElement(driver, locator, elementName);
    }
}

/**
 * CSSmartBaseSetup.java
 * Setup and initialization utilities
 */
package com.cssmart.base;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.driver.CSSmartDriver;
import com.cssmart.exceptions.CSSmartDriverException;
import com.cssmart.logging.CSSmartLogger;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.safari.SafariDriver;

public class CSSmartBaseSetup {
    private final CSSmartLogger logger;
    private final CSSmartConfig config;
    
    public CSSmartBaseSetup() {
        this.logger = CSSmartLogger.getInstance();
        this.config = CSSmartConfig.getInstance();
    }
    
    /**
     * Initialize the WebDriver based on configuration
     * @return a CSSmartDriver instance
     */
    public CSSmartDriver initializeDriver() {
        String browserType = config.getProperty("browser.type", "chrome").toLowerCase();
        WebDriver driver;
        
        logger.info("Initializing driver for browser: " + browserType);
        
        try {
            switch (browserType) {
                case "chrome":
                    driver = new ChromeDriver();
                    break;
                case "firefox":
                    driver = new FirefoxDriver();
                    break;
                case "edge":
                    driver = new EdgeDriver();
                    break;
                case "safari":
                    driver = new SafariDriver();
                    break;
                default:
                    logger.warning("Unsupported browser type: " + browserType + ". Defaulting to Chrome.");
                    driver = new ChromeDriver();
            }
            
            // Configure browser window
            configureWindow(driver);
            
            // Create and return CSSmartDriver
            return new CSSmartDriver(driver);
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to initialize driver for browser: " + browserType, e);
        }
    }
    
    /**
     * Configure the browser window
     * @param driver the WebDriver
     */
    private void configureWindow(WebDriver driver) {
        boolean maximizeWindow = Boolean.parseBoolean(config.getProperty("browser.maximize", "true"));
        
        if (maximizeWindow) {
            driver.manage().window().maximize();
            logger.info("Browser window maximized");
        } else {
            int width = Integer.parseInt(config.getProperty("browser.width", "1366"));
            int height = Integer.parseInt(config.getProperty("browser.height", "768"));
            driver.manage().window().setSize(new org.openqa.selenium.Dimension(width, height));
            logger.info("Browser window size set to: " + width + "x" + height);
        }
    }
}

/**
 * CSSmartBaseTeardown.java
 * Cleanup and resource management
 */
package com.cssmart.base;

import com.cssmart.driver.CSSmartDriver;
import com.cssmart.exceptions.CSSmartDriverException;
import com.cssmart.logging.CSSmartLogger;

public class CSSmartBaseTeardown {
    private final CSSmartLogger logger;
    
    public CSSmartBaseTeardown() {
        this.logger = CSSmartLogger.getInstance();
    }
    
    /**
     * Quit the driver
     * @param driver the CSSmartDriver to quit
     */
    public void quitDriver(CSSmartDriver driver) {
        if (driver != null) {
            try {
                logger.info("Quitting driver...");
                driver.quit();
                logger.info("Driver quit successfully");
            } catch (Exception e) {
                throw new CSSmartDriverException("Failed to quit driver", e);
            }
        }
    }
    
    /**
     * Clean up resources
     */
    public void cleanupResources() {
        logger.info("Cleaning up resources...");
        // Add any additional cleanup logic here
    }
}

/**
 * CSSmartException.java
 * Base exception class for all framework exceptions
 */
package com.cssmart.exceptions;

public class CSSmartException extends RuntimeException {
    private final Severity severity;
    
    /**
     * Enum representing exception severity levels
     */
    public enum Severity {
        INFO,       // Informational, non-fatal
        WARNING,    // Warning, potentially recoverable
        ERROR,      // Error, may be recoverable
        CRITICAL    // Critical, non-recoverable
    }
    
    /**
     * Constructor with message, cause, and severity
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     */
    public CSSmartException(String message, Throwable cause, Severity severity) {
        super(message, cause);
        this.severity = severity;
    }
    
    /**
     * Constructor with message and severity
     * @param message the exception message
     * @param severity the severity level
     */
    public CSSmartException(String message, Severity severity) {
        super(message);
        this.severity = severity;
    }
    
    /**
     * Constructor with message and cause (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartException(String message, Throwable cause) {
        this(message, cause, Severity.ERROR);
    }
    
    /**
     * Constructor with message (default severity: ERROR)
     * @param message the exception message
     */
    public CSSmartException(String message) {
        this(message, Severity.ERROR);
    }
    
    /**
     * Get the severity level
     * @return the severity level
     */
    public Severity getSeverity() {
        return severity;
    }
    
    /**
     * Check if the exception is critical
     * @return true if the severity is CRITICAL
     */
    public boolean isCritical() {
        return severity == Severity.CRITICAL;
    }
    
    /**
     * Get a formatted message including severity
     * @return the formatted message
     */
    public String getFormattedMessage() {
        return "[" + severity + "] " + getMessage();
    }
}

/**
 * CSSmartDriverException.java
 * Exception for driver-related issues
 */
package com.cssmart.exceptions;

public class CSSmartDriverException extends CSSmartException {
    /**
     * Constructor with message, cause, and severity
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     */
    public CSSmartDriverException(String message, Throwable cause, Severity severity) {
        super("[Driver] " + message, cause, severity);
    }
    
    /**
     * Constructor with message and severity
     * @param message the exception message
     * @param severity the severity level
     */
    public CSSmartDriverException(String message, Severity severity) {
        super("[Driver] " + message, severity);
    }
    
    /**
     * Constructor with message and cause (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartDriverException(String message, Throwable cause) {
        super("[Driver] " + message, cause);
    }
    
    /**
     * Constructor with message (default severity: ERROR)
     * @param message the exception message
     */
    public CSSmartDriverException(String message) {
        super("[Driver] " + message);
    }
}

/**
 * CSSmartElementException.java
 * Exception for element-related issues
 */
package com.cssmart.exceptions;

public class CSSmartElementException extends CSSmartException {
    /**
     * Constructor with message, cause, and severity
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     */
    public CSSmartElementException(String message, Throwable cause, Severity severity) {
        super("[Element] " + message, cause, severity);
    }
    
    /**
     * Constructor with message and severity
     * @param message the exception message
     * @param severity the severity level
     */
    public CSSmartElementException(String message, Severity severity) {
        super("[Element] " + message, severity);
    }
    
    /**
     * Constructor with message and cause (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartElementException(String message, Throwable cause) {
        super("[Element] " + message, cause);
    }
    
    /**
     * Constructor with message (default severity: ERROR)
     * @param message the exception message
     */
    public CSSmartElementException(String message) {
        super("[Element] " + message);
    }
}

/**
 * CSSmartConfigException.java
 * Exception for configuration-related issues
 */
package com.cssmart.exceptions;

public class CSSmartConfigException extends CSSmartException {
    /**
     * Constructor with message, cause, and severity
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     */
    public CSSmartConfigException(String message, Throwable cause, Severity severity) {
        super("[Config] " + message, cause, severity);
    }
    
    /**
     * Constructor with message and severity
     * @param message the exception message
     * @param severity the severity level
     */
    public CSSmartConfigException(String message, Severity severity) {
        super("[Config] " + message, severity);
    }
    
    /**
     * Constructor with message and cause (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartConfigException(String message, Throwable cause) {
        super("[Config] " + message, cause);
    }
    
    /**
     * Constructor with message (default severity: ERROR)
     * @param message the exception message
     */
    public CSSmartConfigException(String message) {
        super("[Config] " + message);
    }
}

/**
 * CSSmartAPIException.java
 * Exception for API-related issues
 */
package com.cssmart.exceptions;

public class CSSmartAPIException extends CSSmartException {
    private final int statusCode;
    
    /**
     * Constructor with message, cause, severity, and status code
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     * @param statusCode the HTTP status code
     */
    public CSSmartAPIException(String message, Throwable cause, Severity severity, int statusCode) {
        super("[API] " + message, cause, severity);
        this.statusCode = statusCode;
    }
    
    /**
     * Constructor with message, severity, and status code
     * @param message the exception message
     * @param severity the severity level
     * @param statusCode the HTTP status code
     */
    public CSSmartAPIException(String message, Severity severity, int statusCode) {
        super("[API] " + message, severity);
        this.statusCode = statusCode;
    }
    
    /**
     * Constructor with message, cause, and status code (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     * @param statusCode the HTTP status code
     */
    public CSSmartAPIException(String message, Throwable cause, int statusCode) {
        super("[API] " + message, cause);
        this.statusCode = statusCode;
    }
    
    /**
     * Constructor with message and status code (default severity: ERROR)
     * @param message the exception message
     * @param statusCode the HTTP status code
     */
    public CSSmartAPIException(String message, int statusCode) {
        super("[API] " + message);
        this.statusCode = statusCode;
    }
    
    /**
     * Constructor with message and cause (status code: 0)
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartAPIException(String message, Throwable cause) {
        this(message, cause, 0);
    }
    
    /**
     * Constructor with message (status code: 0)
     * @param message the exception message
     */
    public CSSmartAPIException(String message) {
        this(message, 0);
    }
    
    /**
     * Get the HTTP status code
     * @return the HTTP status code
     */
    public int getStatusCode() {
        return statusCode;
    }
    
    @Override
    public String getFormattedMessage() {
        return "[" + getSeverity() + "] " + getMessage() + (statusCode > 0 ? " (Status Code: " + statusCode + ")" : "");
    }
}

/**
 * CSSmartDBException.java
 * Exception for database-related issues
 */
package com.cssmart.exceptions;

public class CSSmartDBException extends CSSmartException {
    private final String sqlState;
    
    /**
     * Constructor with message, cause, severity, and SQL state
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     * @param sqlState the SQL state code
     */
    public CSSmartDBException(String message, Throwable cause, Severity severity, String sqlState) {
        super("[DB] " + message, cause, severity);
        this.sqlState = sqlState;
    }
    
    /**
     * Constructor with message, severity, and SQL state
     * @param message the exception message
     * @param severity the severity level
     * @param sqlState the SQL state code
     */
    public CSSmartDBException(String message, Severity severity, String sqlState) {
        super("[DB] " + message, severity);
        this.sqlState = sqlState;
    }
    
    /**
     * Constructor with message, cause, and SQL state (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     * @param sqlState the SQL state code
     */
    public CSSmartDBException(String message, Throwable cause, String sqlState) {
        super("[DB] " + message, cause);
        this.sqlState = sqlState;
    }
    
    /**
     * Constructor with message and SQL state (default severity: ERROR)
     * @param message the exception message
     * @param sqlState the SQL state code
     */
    public CSSmartDBException(String message, String sqlState) {
        super("[DB] " + message);
        this.sqlState = sqlState;
    }
    
    /**
     * Constructor with message and cause (SQL state: null)
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartDBException(String message, Throwable cause) {
        this(message, cause, null);
    }
    
    /**
     * Constructor with message (SQL state: null)
     * @param message the exception message
     */
    public CSSmartDBException(String message) {
        this(message, (String) null);
    }
    
    /**
     * Get the SQL state code
     * @return the SQL state code
     */
    public String getSqlState() {
        return sqlState;
    }
    
    @Override
    public String getFormattedMessage() {
        return "[" + getSeverity() + "] " + getMessage() + (sqlState != null ? " (SQL State: " + sqlState + ")" : "");
    }
}

/**
 * CSSmartBDDException.java
 * Exception for BDD-related issues
 */
package com.cssmart.exceptions;

public class CSSmartBDDException extends CSSmartException {
    private final String feature;
    private final String scenario;
    private final int lineNumber;
    
    /**
     * Constructor with all parameters
     * @param message the exception message
     * @param cause the cause of the exception
     * @param severity the severity level
     * @param feature the feature name
     * @param scenario the scenario name
     * @param lineNumber the line number in the feature file
     */
    public CSSmartBDDException(String message, Throwable cause, Severity severity, 
                              String feature, String scenario, int lineNumber) {
        super("[BDD] " + message, cause, severity);
        this.feature = feature;
        this.scenario = scenario;
        this.lineNumber = lineNumber;
    }
    
    /**
     * Constructor with message, severity, and BDD details
     * @param message the exception message
     * @param severity the severity level
     * @param feature the feature name
     * @param scenario the scenario name
     * @param lineNumber the line number in the feature file
     */
    public CSSmartBDDException(String message, Severity severity, 
                              String feature, String scenario, int lineNumber) {
        super("[BDD] " + message, severity);
        this.feature = feature;
        this.scenario = scenario;
        this.lineNumber = lineNumber;
    }
    
    /**
     * Constructor with message, cause, and BDD details (default severity: ERROR)
     * @param message the exception message
     * @param cause the cause of the exception
     * @param feature the feature name
     * @param scenario the scenario name
     * @param lineNumber the line number in the feature file
     */
    public CSSmartBDDException(String message, Throwable cause, 
                              String feature, String scenario, int lineNumber) {
        super("[BDD] " + message, cause);
        this.feature = feature;
        this.scenario = scenario;
        this.lineNumber = lineNumber;
    }
    
    /**
     * Constructor with message and BDD details (default severity: ERROR)
     * @param message the exception message
     * @param feature the feature name
     * @param scenario the scenario name
     * @param lineNumber the line number in the feature file
     */
    public CSSmartBDDException(String message, String feature, String scenario, int lineNumber) {
        super("[BDD] " + message);
        this.feature = feature;
        this.scenario = scenario;
        this.lineNumber = lineNumber;
    }
    
    /**
     * Constructor with message and cause
     * @param message the exception message
     * @param cause the cause of the exception
     */
    public CSSmartBDDException(String message, Throwable cause) {
        this(message, cause, null, null, -1);
    }
    
    /**
     * Constructor with message
     * @param message the exception message
     */
    public CSSmartBDDException(String message) {
        this(message, null, null, -1);
    }
    
    /**
     * Get the feature name
     * @return the feature name
     */
    public String getFeature() {
        return feature;
    }
    
    /**
     * Get the scenario name
     * @return the scenario name
     */
    public String getScenario() {
        return scenario;
    }
    
    /**
     * Get the line number
     * @return the line number in the feature file
     */
    public int getLineNumber() {
        return lineNumber;
    }
    
    @Override
    public String getFormattedMessage() {
        StringBuilder sb = new StringBuilder();
        sb.append("[").append(getSeverity()).append("] ").append(getMessage());
        
        if (feature != null) {
            sb.append(" (Feature: ").append(feature);
            /**
 * CSSmartLogger.java
 * Thread-context aware logger with enhanced formatting
 */
package com.cssmart.logging;

import com.cssmart.exceptions.CSSmartException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class CSSmartLogger {
    private static final ThreadLocal<CSSmartLogger> INSTANCE = ThreadLocal.withInitial(CSSmartLogger::new);
    private final Logger logger;
    private final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private CSSmartLogger() {
        this.logger = LogManager.getLogger(CSSmartLogger.class);
    }
    
    /**
     * Get the singleton instance
     * @return the CSSmartLogger instance
     */
    public static CSSmartLogger getInstance() {
        return INSTANCE.get();
    }
    
    /**
     * Set thread context for logging
     * @param testName the test name
     * @param testClass the test class name
     */
    public void setContext(String testName, String testClass) {
        ThreadContext.put("testName", testName);
        ThreadContext.put("testClass", testClass);
        ThreadContext.put("threadId", String.valueOf(Thread.currentThread().getId()));
    }
    
    /**
     * Clear thread context
     */
    public void clearContext() {
        ThreadContext.clearAll();
    }
    
    /**
     * Log a message at INFO level
     * @param message the message to log
     */
    public void info(String message) {
        logger.info(formatMessage(message));
    }
    
    /**
     * Log a message at DEBUG level
     * @param message the message to log
     */
    public void debug(String message) {
        logger.debug(formatMessage(message));
    }
    
    /**
     * Log a message at WARN level
     * @param message the message to log
     */
    public void warning(String message) {
        logger.warn(formatMessage(message));
    }
    
    /**
     * Log a message at ERROR level
     * @param message the message to log
     */
    public void error(String message) {
        logger.error(formatMessage(message));
    }
    
    /**
     * Log a message at ERROR level with an exception
     * @param message the message to log
     * @param e the exception to log
     */
    public void error(String message, Throwable e) {
        if (e instanceof CSSmartException) {
            logger.error(formatMessage(message + " - " + ((CSSmartException) e).getFormattedMessage()), e);
        } else {
            logger.error(formatMessage(message), e);
        }
    }
    
    /**
     * Log a message at FATAL level
     * @param message the message to log
     */
    public void fatal(String message) {
        logger.fatal(formatMessage(message));
    }
    
    /**
     * Log a message at FATAL level with an exception
     * @param message the message to log
     * @param e the exception to log
     */
    public void fatal(String message, Throwable e) {
        if (e instanceof CSSmartException) {
            logger.fatal(formatMessage(message + " - " + ((CSSmartException) e).getFormattedMessage()), e);
        } else {
            logger.fatal(formatMessage(message), e);
        }
    }
    
    /**
     * Format a log message
     * @param message the message to format
     * @return the formatted message
     */
    private String formatMessage(String message) {
        String threadId = ThreadContext.get("threadId");
        String testName = ThreadContext.get("testName");
        String testClass = ThreadContext.get("testClass");
        
        StringBuilder sb = new StringBuilder();
        sb.append("[").append(LocalDateTime.now().format(formatter)).append("]");
        
        if (threadId != null) {
            sb.append(" [Thread-").append(threadId).append("]");
        }
        
        if (testClass != null) {
            sb.append(" [").append(testClass);
            
            if (testName != null) {
                sb.append(":").append(testName);
            }
            
            sb.append("]");
        }
        
        sb.append(" - ").append(message);
        
        return sb.toString();
    }
}

/**
 * CSSmartReport.java
 * Custom HTML report generator with screenshots and test steps
 */
package com.cssmart.reporting;

import com.cssmart.driver.CSSmartDriver;
import com.cssmart.exceptions.CSSmartException;
import com.cssmart.logging.CSSmartLogger;
import org.apache.commons.io.FileUtils;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.testng.ITestResult;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class CSSmartReport {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final ThreadLocal<CSSmartReport> INSTANCE = ThreadLocal.withInitial(CSSmartReport::new);
    private static final String BASE_REPORT_DIR = "target/cssmart-reports/";
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss");
    
    private final Map<String, SuiteReport> suiteReports = new ConcurrentHashMap<>();
    private final ThreadLocal<String> currentSuite = new ThreadLocal<>();
    private final ThreadLocal<String> currentTest = new ThreadLocal<>();
    private final ThreadLocal<List<TestStep>> currentSteps = ThreadLocal.withInitial(ArrayList::new);
    private final String reportDir;
    private final String screenshotDir;
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private CSSmartReport() {
        String timestamp = LocalDateTime.now().format(DATE_FORMAT);
        this.reportDir = BASE_REPORT_DIR + timestamp + "/";
        this.screenshotDir = reportDir + "screenshots/";
        
        try {
            Files.createDirectories(Paths.get(reportDir));
            Files.createDirectories(Paths.get(screenshotDir));
        } catch (IOException e) {
            logger.error("Failed to create report directories", e);
        }
    }
    
    /**
     * Get the singleton instance
     * @return the CSSmartReport instance
     */
    public static CSSmartReport getInstance() {
        return INSTANCE.get();
    }
    
    /**
     * Start a test suite
     * @param suiteName the name of the suite
     */
    public void startSuite(String suiteName) {
        currentSuite.set(suiteName);
        suiteReports.putIfAbsent(suiteName, new SuiteReport(suiteName));
        logger.info("Started suite: " + suiteName);
    }
    
    /**
     * End a test suite
     */
    public void endSuite() {
        String suiteName = currentSuite.get();
        if (suiteName != null) {
            SuiteReport suiteReport = suiteReports.get(suiteName);
            if (suiteReport != null) {
                generateSuiteReport(suiteReport);
                logger.info("Ended suite: " + suiteName);
            }
        }
        
        generateDashboard();
        currentSuite.remove();
    }
    
    /**
     * Start a test
     * @param testName the name of the test
     * @param description the test description
     */
    public void startTest(String testName, String description) {
        String suiteName = currentSuite.get();
        if (suiteName != null) {
            SuiteReport suiteReport = suiteReports.get(suiteName);
            if (suiteReport != null) {
                TestReport testReport = new TestReport(testName, description);
                testReport.setStartTime(System.currentTimeMillis());
                suiteReport.addTest(testReport);
                currentTest.set(testName);
                currentSteps.get().clear();
                logger.info("Started test: " + testName);
            }
        }
    }
    
    /**
     * End a test
     * @param result the test result
     */
    public void endTest(ITestResult result) {
        String suiteName = currentSuite.get();
        String testName = currentTest.get();
        
        if (suiteName != null && testName != null) {
            SuiteReport suiteReport = suiteReports.get(suiteName);
            if (suiteReport != null) {
                TestReport testReport = suiteReport.getTest(testName);
                if (testReport != null) {
                    testReport.setEndTime(System.currentTimeMillis());
                    testReport.setStatus(convertTestStatus(result.getStatus()));
                    testReport.setSteps(new ArrayList<>(currentSteps.get()));
                    
                    if (result.getThrowable() != null) {
                        testReport.setException(result.getThrowable().toString());
                    }
                    
                    logger.info("Ended test: " + testName + " with status: " + testReport.getStatus());
                }
            }
        }
        
        currentSteps.get().clear();
        currentTest.remove();
    }
    
    /**
     * Log an informational step
     * @param message the message to log
     */
    public void logInfo(String message) {
        logStep(message, StepStatus.INFO);
    }
    
    /**
     * Log a warning step
     * @param message the message to log
     */
    public void logWarning(String message) {
        logStep(message, StepStatus.WARNING);
    }
    
    /**
     * Log an error step
     * @param message the message to log
     */
    public void logError(String message) {
        logStep(message, StepStatus.ERROR);
    }
    
    /**
     * Log a test step
     * @param message the step message
     * @param status the step status
     */
    private void logStep(String message, StepStatus status) {
        TestStep step = new TestStep(message, status);
        currentSteps.get().add(step);
        
        switch (status) {
            case INFO:
                logger.info(message);
                break;
            case WARNING:
                logger.warning(message);
                break;
            case ERROR:
                logger.error(message);
                break;
        }
    }
    
    /**
     * Take a screenshot
     * @param driver the CSSmartDriver
     * @param screenshotName the name of the screenshot
     * @return the path to the saved screenshot
     */
    public String takeScreenshot(CSSmartDriver driver, String screenshotName) {
        if (driver == null) {
            logger.error("Driver is null, screenshot cannot be taken");
            return null;
        }
        
        try {
            WebDriver wrappedDriver = driver.getWrappedDriver();
            File screenshot = ((TakesScreenshot) wrappedDriver).getScreenshotAs(OutputType.FILE);
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HHmmss"));
            String fileName = screenshotName + "_" + timestamp + ".png";
            String filePath = screenshotDir + fileName;
            
            File destFile = new File(filePath);
            FileUtils.copyFile(screenshot, destFile);
            
            String relativeScreenshotPath = "screenshots/" + fileName;
            TestStep step = new TestStep("Screenshot taken: " + screenshotName, StepStatus.INFO);
            step.setScreenshotPath(relativeScreenshotPath);
            currentSteps.get().add(step);
            
            logger.info("Screenshot taken: " + filePath);
            return filePath;
        } catch (Exception e) {
            logger.error("Failed to take screenshot: " + screenshotName, e);
            return null;
        }
    }
    
    /**
     * Generate all reports
     */
    public void generateAllReports() {
        for (SuiteReport suiteReport : suiteReports.values()) {
            generateSuiteReport(suiteReport);
        }
        
        generateDashboard();
    }
    
    /**
     * Generate a suite report
     * @param suiteReport the suite report to generate
     */
    private void generateSuiteReport(SuiteReport suiteReport) {
        try {
            String suiteReportPath = reportDir + suiteReport.getName() + ".html";
            StringBuilder html = new StringBuilder();
            
            // HTML header
            html.append("<!DOCTYPE html>\n");
            html.append("<html lang=\"en\">\n");
            html.append("<head>\n");
            html.append("    <meta charset=\"UTF-8\">\n");
            html.append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
            html.append("    <title>Test Suite Report: ").append(suiteReport.getName()).append("</title>\n");
            html.append("    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css\">\n");
            html.append("    <style>\n");
            html.append("        .test-success { background-color: #d4edda; }\n");
            html.append("        .test-failure { background-color: #f8d7da; }\n");
            html.append("        .test-skip { background-color: #fff3cd; }\n");
            html.append("        .step-info { color: #0c5460; }\n");
            html.append("        .step-warning { color: #856404; }\n");
            html.append("        .step-error { color: #721c24; }\n");
            html.append("        .screenshot-thumbnail { max-width: 200px; cursor: pointer; }\n");
            html.append("        .modal-img { max-width: 100%; }\n");
            html.append("        .step-time { color: #6c757d; font-size: 0.85em; }\n");
            html.append("        .collapsible { cursor: pointer; }\n");
            html.append("    </style>\n");
            html.append("</head>\n");
            html.append("<body>\n");
            html.append("    <div class=\"container-fluid\">\n");
            html.append("        <h1 class=\"mt-4\">Test Suite Report: ").append(suiteReport.getName()).append("</h1>\n");
            html.append("        <div class=\"row mt-3\">\n");
            html.append("            <div class=\"col\">\n");
            html.append("                <div class=\"card\">\n");
            html.append("                    <div class=\"card-header\">\n");
            html.append("                        <h4>Summary</h4>\n");
            html.append("                    </div>\n");
            html.append("                    <div class=\"card-body\">\n");
            html.append("                        <div class=\"row\">\n");
            html.append("                            <div class=\"col-md-3\">\n");
            html.append("                                <div class=\"alert alert-success\">\n");
            html.append("                                    <h5>Passed: ").append(suiteReport.getPassCount()).append("</h5>\n");
            html.append("                                </div>\n");
            html.append("                            </div>\n");
            html.append("                            <div class=\"col-md-3\">\n");
            html.append("                                <div class=\"alert alert-danger\">\n");
            html.append("                                    <h5>Failed: ").append(suiteReport.getFailCount()).append("</h5>\n");
            html.append("                                </div>\n");
            html.append("                            </div>\n");
            html.append("                            <div class=\"col-md-3\">\n");
            html.append("                                <div class=\"alert alert-warning\">\n");
            html.append("                                    <h5>Skipped: ").append(suiteReport.getSkipCount()).append("</h5>\n");
            html.append("                                </div>\n");
            html.append("                            </div>\n");
            html.append("                            <div class=\"col-md-3\">\n");
            html.append("                                <div class=\"alert alert-info\">\n");
            html.append("                                    <h5>Total: ").append(suiteReport.getTestCount()).append("</h5>\n");
            html.append("                                </div>\n");
            html.append("                            </div>\n");
            html.append("                        </div>\n");
            html.append("                    </div>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("        </div>\n");
            
            // Test details
            html.append("        <div class=\"row mt-4\">\n");
            html.append("            <div class=\"col\">\n");
            html.append("                <div class=\"card\">\n");
            html.append("                    <div class=\"card-header\">\n");
            html.append("                        <h4>Test Details</h4>\n");
            html.append("                    </div>\n");
            html.append("                    <div class=\"card-body\">\n");
            html.append("                        <div class=\"accordion\" id=\"testAccordion\">\n");
            
            // For each test
            int testIndex = 0;
            for (TestReport testReport : suiteReport.getTests()) {
                String testClassName = "test-" + testReport.getStatus().toString().toLowerCase();
                String testId = "test-" + testIndex;
                
                html.append("                            <div class=\"card mb-3 ").append(testClassName).append("\">\n");
                html.append("                                <div class=\"card-header collapsible\" id=\"heading-").append(testId).append("\" data-toggle=\"collapse\" data-target=\"#collapse-").append(testId).append("\" aria-expanded=\"true\" aria-controls=\"collapse-").append(testId).append("\">\n");
                html.append("                                    <div class=\"row\">\n");
                html.append("                                        <div class=\"col-md-6\">\n");
                html.append("                                            <h5>").append(testReport.getName()).append("</h5>\n");
                html.append("                                        </div>\n");
                html.append("                                        <div class=\"col-md-2\">\n");
                html.append("                                            <span class=\"badge badge-").append(getStatusBadgeClass(testReport.getStatus())).append("\">").append(testReport.getStatus()).append("</span>\n");
                html.append("                                        </div>\n");
                html.append("                                        <div class=\"col-md-2\">\n");
                html.append("                                            <span>").append(formatDuration(testReport.getDuration())).append("</span>\n");
                html.append("                                        </div>\n");
                html.append("                                        <div class=\"col-md-2 text-right\">\n");
                html.append("                                            <span class=\"badge badge-secondary\">").append(testReport.getSteps().size()).append(" steps</span>\n");
                html.append("                                        </div>\n");
                html.append("                                    </div>\n");
                html.append("                                </div>\n");
                html.append("                                <div id=\"collapse-").append(testId).append("\" class=\"collapse\" aria-labelledby=\"heading-").append(testId).append("\" data-parent=\"#testAccordion\">\n");
                html.append("                                    <div class=\"card-body\">\n");
                
                // Description
                if (testReport.getDescription() != null && !testReport.getDescription().isEmpty()) {
                    html.append("                                        <div class=\"alert alert-secondary\">\n");
                    html.append("                                            <strong>Description:</strong> ").append(testReport.getDescription()).append("\n");
                    html.append("                                        </div>\n");
                }
                
                // Exception
                if (testReport.getException() != null) {
                    html.append("                                        <div class=\"alert alert-danger\">\n");
                    html.append("                                            <strong>Exception:</strong>\n");
                    html.append("                                            <pre>").append(testReport.getException()).append("</pre>\n");
                    html.append("                                        </div>\n");
                }
                
                // Steps
                html.append("                                        <table class=\"table table-bordered table-hover\">\n");
                html.append("                                            <thead>\n");
                html.append("                                                <tr>\n");
                html.append("                                                    <th width=\"5%\">#</th>\n");
                html.append("                                                    <th width=\"75%\">Step</th>\n");
                html.append("                                                    <th width=\"10%\">Status</th>\n");
                html.append("                                                    <th width=\"10%\">Screenshot</th>\n");
                html.append("                                                </tr>\n");
                html.append("                                            </thead>\n");
                html.append("                                            <tbody>\n");
                
                // For each step
                int stepIndex = 0;
                for (TestStep step : testReport.getSteps()) {
                    String stepClassName = "step-" + step.getStatus().toString().toLowerCase();
                    
                    html.append("                                                <tr class=\"").append(stepClassName).append("\">\n");
                    html.append("                                                    <td>").append(++stepIndex).append("</td>\n");
                    html.append("                                                    <td>").append(step.getMessage()).append("\n");
                    html.append("                                                        <span class=\"step-time\">").append(step.getTimestamp()).append("</span>\n");
                    html.append("                                                    </td>\n");
                    html.append("                                                    <td>").append(step.getStatus()).append("</td>\n");
                    html.append("                                                    <td>\n");
                    
                    if (step.getScreenshotPath() != null) {
                        String modalId = "modal-" + testId + "-" + stepIndex;
                        html.append("                                                        <img src=\"").append(step.getScreenshotPath()).append("\" class=\"screenshot-thumbnail\" data-toggle=\"modal\" data-target=\"#").append(modalId).append("\">\n");
                        html.append("                                                        <div class=\"modal fade\" id=\"").append(modalId).append("\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\">\n");
                        html.append("                                                            <div class=\"modal-dialog modal-lg\">\n");
                        html.append("                                                                <div class=\"modal-content\">\n");
                        html.append("                                                                    <div class=\"modal-header\">\n");
                        html.append("                                                                        <h5 class=\"modal-title\">Screenshot</h5>\n");
                        html.append("                                                                        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n");
                        html.append("                                                                            <span aria-hidden=\"true\">&times;</span>\n");
                        html.append("                                                                        </button>\n");
                        html.append("                                                                    </div>\n");
                        html.append("                                                                    <div class=\"modal-body text-center\">\n");
                        html.append("                                                                        <img src=\"").append(step.getScreenshotPath()).append("\" class=\"modal-img\">\n");
                        html.append("                                                                    </div>\n");
                        html.append("                                                                </div>\n");
                        html.append("                                                            </div>\n");
                        html.append("                                                        </div>\n");
                    }
                    
                    html.append("                                                    </td>\n");
                    html.append("                                                </tr>\n");
                }
                
                html.append("                                            </tbody>\n");
                html.append("                                        </table>\n");
                html.append("                                    </div>\n");
                html.append("                                </div>\n");
                html.append("                            </div>\n");
                
                testIndex++;
            }
            
            html.append("                        </div>\n");
            html.append("                    </div>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("        </div>\n");
            html.append("    </div>\n");
            
            // JavaScript for functionality
            html.append("    <script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\"></script>\n");
            html.append("    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js\"></script>\n");
            html.append("</body>\n");
            html.append("</html>");
            
            // Write to file
            try (FileWriter writer = new FileWriter(suiteReportPath)) {
                writer.write(html.toString());
            }
            
            logger.info("Generated suite report: " + suiteReportPath);
        } catch (IOException e) {
            logger.error("Failed to generate suite report", e);
        }
    }
    
    /**
     * Generate the dashboard report
     */
    private void generateDashboard() {
        try {
            String dashboardPath = reportDir + "index.html";
            StringBuilder html = new StringBuilder();
            
            // HTML header
            html.append("<!DOCTYPE html>\n");
            html.append("<html lang=\"en\">\n");
            html.append("<head>\n");
            html.append("    <meta charset=\"UTF-8\">\n");
            html.append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
            html.append("    <title>CSSmartFramework Test Dashboard</title>\n");
            html.append("    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css\">\n");
            html.append("    <script src=\"https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js\"></script>\n");
            html.append("    <style>\n");
            html.append("        .summary-card { text-align: center; padding: 20px; }\n");
            html.append("        .summary-card h2 { font-size: 3rem; }\n");
            html.append("        .passed { background-color: #d4edda; color: #155724; }\n");
            html.append("        .failed { background-color: #f8d7da; color: #721c24; }\n");
            html.append("        .skipped { background-color: #fff3cd; color: #856404; }\n");
            html.append("        .total { background-color: #e2e3e5; color: #383d41; }\n");
            html.append("        .chart-container { height: 300px; }\n");
            html.append("    </style>\n");
            html.append("</head>\n");
            html.append("<body>\n");
            html.append("    <div class=\"container-fluid\">\n");
            html.append("        <h1 class=\"mt-4\">CSSmartFramework Test Dashboard</h1>\n");
            
            // Summary statistics
            int totalPassed = 0;
            int totalFailed = 0;
            int totalSkipped = 0;
            int totalTests = 0;
            
            for (SuiteReport suiteReport : suiteReports.values()) {
                totalPassed += suiteReport.getPassCount();
                totalFailed += suiteReport.getFailCount();
                totalSkipped += suiteReport.getSkipCount();
                totalTests += suiteReport.getTestCount();
            }
            
            // Summary cards
            html.append("        <div class=\"row mt-4\">\n");
            html.append("            <div class=\"col-md-3\">\n");
            html.append("                <div class=\"card summary-card passed\">\n");
            html.append("                    <h5>Passed</h5>\n");
            html.append("                    <h2>").append(totalPassed).append("</h2>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("            <div class=\"col-md-3\">\n");
            html.append("                <div class=\"card summary-card failed\">\n");
            html.append("                    <h5>Failed</h5>\n");
            html.append("                    <h2>").append(totalFailed).append("</h2>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("            <div class=\"col-md-3\">\n");
            html.append("                <div class=\"card summary-card skipped\">\n");
            html.append("                    <h5>Skipped</h5>\n");
            html.append("                    <h2>").append(totalSkipped).append("</h2>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("            <div class=\"col-md-3\">\n");
            html.append("                <div class=\"card summary-card total\">\n");
            html.append("                    <h5>Total</h5>\n");
            html.append("                    <h2>").append(totalTests).append("</h2>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("        </div>\n");
            
            // Charts
            html.append("        <div class=\"row mt-4\">\n");
            html.append("            <div class=\"col-md-6\">\n");
            html.append("                <div class=\"card\">\n");
            html.append("                    <div class=\"card-header\">\n");
            html.append("                        <h4>Test Results Overview</h4>\n");
            html.append("                    </div>\n");
            html.append("                    <div class=\"card-body\">\n");
            html.append("                        <div class=\"chart-container\">\n");
            html.append("                            <canvas id=\"resultsPieChart\"></canvas>\n");
            html.append("                        </div>\n");
            html.append("                    </div>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("            <div class=\"col-md-6\">\n");
            html.append("                <div class=\"card\">\n");
            html.append("                    <div class=\"card-header\">\n");
            html.append("                        <h4>Suite Results</h4>\n");
            html.append("                    </div>\n");
            html.append("                    <div class=\"card-body\">\n");
            html.append("                        <div class=\"chart-container\">\n");
            html.append("                            <canvas id=\"suiteBarChart\"></canvas>\n");
            html.append("                        </div>\n");
            html.append("                    </div>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("        </div>\n");
            
            // Suite list
            html.append("        <div class=\"row mt-4\">\n");
            html.append("            <div class=\"col\">\n");
            html.append("                <div class=\"card\">\n");
            html.append("                    <div class=\"card-header\">\n");
            html.append("                        <h4>Test Suites</h4>\n");
            html.append("                    </div>\n");
            html.append("                    <div class=\"card-body\">\n");
            html.append("                        <table class=\"table table-bordered table-hover\">\n");
            html.append("                            <thead>\n");
            html.append("                                <tr>\n");
            html.append("                                    <th>Suite Name</th>\n");
            html.append("                                    <th>Passed</th>\n");
            html.append("                                    <th>Failed</th>\n");
            html.append("                                    <th>Skipped</th>\n");
            html.append("                                    <th>Total</th>\n");
            html.append("                                    <th>Pass Rate</th>\n");
            html.append("                                    <th>Report</th>\n");
            html.append("                                </tr>\n");
            html.append("                            </thead>\n");
            html.append("                            <tbody>\n");
            
            // For each suite
            for (SuiteReport suiteReport : suiteReports.values()) {
                double passRate = suiteReport.getTestCount() > 0 
                    ? (double) suiteReport.getPassCount() / suiteReport.getTestCount() * 100 
                    : 0;
                
                html.append("                                <tr>\n");
                html.append("                                    <td>").append(suiteReport.getName()).append("</td>\n");
                html.append("                                    <td class=\"text-success\">").append(suiteReport.getPassCount()).append("</td>\n");
                html.append("                                    <td class=\"text-danger\">").append(suiteReport.getFailCount()).append("</td>\n");
                html.append("                                    <td class=\"text-warning\">").append(suiteReport.getSkipCount()).append("</td>\n");
                html.append("                                    <td>").append(suiteReport.getTestCount()).append("</td>\n");
                html.append("                                    <td>").append(String.format("%.2f%%", passRate)).append("</td>\n");
                html.append("                                    <td><a href=\"").append(suiteReport.getName()).append(".html\" class=\"btn btn-sm btn-primary\">View</a></td>\n");
                html.append("                                </tr>\n");
            }
            
            html.append("                            </tbody>\n");
            html.append("                        </table>\n");
            html.append("                    </div>\n");
            html.append("                </div>\n");
            html.append("            </div>\n");
            html.append("        </div>\n");
            html.append("    </div>\n");
            
            // JavaScript for charts
            html.append("    <script>\n");
            html.append("        // Test results pie chart\n");
            html.append("        const resultsPieCtx = document.getElementById('resultsPieChart').getContext('2d');\n");
            html.append("        const resultsPieChart = new Chart(resultsPieCtx, {\n");
            html.append("            type: 'pie',\n");
            html.append("            data: {\n");
            html.append("                labels: ['Passed', 'Failed', 'Skipped'],\n");
            html.append("                datasets: [{\n");
            html.append("                    data: [").append(totalPassed).append(", ").append(totalFailed).append(", ").append(totalSkipped).append("],\n");
            html.append("                    backgroundColor: ['#28a745', '#dc3545', '#ffc107']\n");
            html.append("                }]\n");
            html.append("            },\n");
            html.append("            options: {\n");
            html.append("                responsive: true,\n");
            html.append("                maintainAspectRatio: false,\n");
            html.append("                legend: {\n");
            html.append("                    position: 'right'\n");
            html.append("                }\n");
            html.append("            }\n");
            html.append("        });\n");
            
            // Suite bar chart
            html.append("        // Suite results bar chart\n");
            html.append("        const suiteBarCtx = document.getElementById('suiteBarChart').getContext('2d');\n");
            html.append("        const suiteBarChart = new Chart(suiteBarCtx, {\n");
            html.append("            type: 'bar',\n");
            html.append("            data: {\n");
            html.append("                labels: [");
            
            boolean first = true;
            for (SuiteReport suiteReport : suiteReports.values()) {
                if (!first) {
                    html.append(", ");
                }
                html.append("'").append(suiteReport.getName()).append("'");
                first = false;
            }
            
            html.append("],\n");
            html.append("                datasets: [\n");
            html.append("                    {\n");
            html.append("                        label: 'Passed',\n");
            html.append("                        backgroundColor: '#28a745',\n");
            html.append("                        data: [");
            
            first = true;
            for (SuiteReport suiteReport : suiteReports.values()) {
                if (!first) {
                    html.append(", ");
                }
                html.append(suiteReport.getPassCount());
                first = false;
            }
            
            html.append("]\n");
            html.append("                    },\n");
            html.append("                    {\n");
            html.append("                        label: 'Failed',\n");
            html.append("                        backgroundColor: '#dc3545',\n");
            html.append("                        data: [");
            
            first = true;
            for (SuiteReport suiteReport : suiteReports.values()) {
                if (!first) {
                    html.append(", ");
                }
                html.append(suiteReport.getFailCount());
                first = false;
            }
            
            html.append("]\n");
            html.append("                    },\n");
            html.append("                    {\n");
            html.append("                        label: 'Skipped',\n");
            html.append("                        backgroundColor: '#ffc107',\n");
            html.append("                        data: [");
            
            first = true;
            for (SuiteReport suiteReport : suiteReports.values()) {
                if (!first) {
                    html.append(", ");
                }
                html.append(suiteReport.getSkipCount());
                first = false;
            }
            
            html.append("]\n");
            html.append("                    }\n");
            html.append("                ]\n");
            html.append("            },\n");
            html.append("            options: {\n");
            html.append("                responsive: true,\n");
            html.append("                maintainAspectRatio: false,\n");
            html.append("                scales: {\n");
            html.append("                    xAxes: [{ stacked: true }],\n");
            html.append("                    yAxes: [{ stacked: true }]\n");
            html.append("                }\n");
            html.append("            }\n");
            html.append("        });\n");
            html.append("    </script>\n");
            
            // jQuery and Bootstrap
            html.append("    <script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\"></script>\n");
            html.append("    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js\"></script>\n");
            html.append("</body>\n");
            html.append("</html>");
            
            // Write to file
            try (FileWriter writer = new FileWriter(dashboardPath)) {
                writer.write(html.toString());
            }
            
            logger.info("Generated dashboard: " + dashboardPath);
        } catch (IOException e) {
            logger.error("Failed to generate dashboard", e);
        }
    }
    
    /**
     * Convert TestNG status to our status enum
     * @param status the TestNG status code
     * @return the corresponding TestStatus
     */
    private TestStatus convertTestStatus(int status) {
        switch (status) {
            case 1:
                return TestStatus.PASSED;
            case 2:
                return TestStatus.FAILED;
            case 3:
                return TestStatus.SKIPPED;
            default:
                return TestStatus.SKIPPED;
        }
    }
    
    /**
     * Format duration in milliseconds to a readable string
     * @param duration the duration in milliseconds
     * @return the formatted duration string
     */
    private String formatDuration(long duration) {
        long seconds = duration / 1000;
        long minutes = seconds / 60;
        seconds %= 60;
        
        return String.format("%dm %ds", minutes, seconds);
    }
    
    /**
     * Get the Bootstrap badge class for a test status
     * @param status the test status
     * @return the corresponding badge class
     */
    private String getStatusBadgeClass(TestStatus status) {
        switch (status) {
            case PASSED:
                return "success";
            case FAILED:
                return "danger";
            case SKIPPED:
                return "warning";
            default:
                return "secondary";
        }
    }
    
    /**
     * Enum for test status
     */
    public enum TestStatus {
        PASSED,
        FAILED,
        SKIPPED
    }
    
    /**
     * Enum for step status
     */
    public enum StepStatus {
        INFO,
        WARNING,
        ERROR
    }
    
    /**
     * Inner class representing a test suite report
     */
    private static class SuiteReport {
        private final String name;
        private final Map<String, TestReport> tests = new HashMap<>();
        
        public SuiteReport(String name) {
            this.name = name;
        }
        
        public String getName() {
            return name;
        }
        
        public void addTest(TestReport test) {
            tests.put(test.getName(), test);
        }
        
        public TestReport getTest(String testName) {
            return tests.get(testName);
        }
        
        public List<TestReport> getTests() {
            return new ArrayList<>(tests.values());
        }
        
        public int getTestCount() {
            return tests.size();
        }
        
        public int getPassCount() {
            return (int) tests.values().stream()
                .filter(test -> test.getStatus() == TestStatus.PASSED)
                .count();
        }
        
        public int getFailCount() {
            return (int) tests.values().stream()
                .filter(test -> test.getStatus() == TestStatus.FAILED)
                .count();
        }
        
        public int getSkipCount() {
            return (int) tests.values().stream()
                .filter(test -> test.getStatus() == TestStatus.SKIPPED)
                .count();
        }
    }
    
    /**
     * Inner class representing a test report
     */
    private static class TestReport {
        private final String name;
        private final String description;
        private long startTime;
        private long endTime;
        private TestStatus status;
        private String exception;
        private List<TestStep> steps = new ArrayList<>();
        
        public TestReport(String name, String description) {
            this.name = name;
            this.description = description;
        }
        
        public String getName() {
            return name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public long getStartTime() {
            return startTime;
        }
        
        public void setStartTime(long startTime) {
            this.startTime = startTime;
        }
        
        public long getEndTime() {
            return endTime;
        }
        
        public void setEndTime(long endTime) {
            this.endTime = endTime;
        }
        
        public long getDuration() {
            return endTime - startTime;
        }
        
        public TestStatus getStatus() {
            return status;
        }
        
        public void setStatus(TestStatus status) {
            this.status = status;
        }
        
        public String getException() {
            return exception;
        }
        
        public void setException(String exception) {
            this.exception = exception;
        }
        
        public List<TestStep> getSteps() {
            return steps;
        }
        
        public void setSteps(List<TestStep> steps) {
            this.steps = steps;
        }
        
        public void addStep(TestStep step) {
            steps.add(step);
        }
    }
    
    /**
     * Inner class representing a test step
     */
    private static class TestStep {
        private final String message;
        private final StepStatus status;
        private final String timestamp;
        private String screenshotPath;
        
        public TestStep(String message, StepStatus status) {
            this.message = message;
            this.status = status;
            this.timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss.SSS"));
        }
        
        public String getMessage() {
            return message;
        }
        
        public StepStatus getStatus() {
            return status;
        }
        
        public String getTimestamp() {
            return timestamp;
        }
        
        public String getScreenshotPath() {
            return screenshotPath;
        }
        
        public void setScreenshotPath(String screenshotPath) {
            this.screenshotPath = screenshotPath;
        }
    }
}

/**
 * CSSmartReportManager.java
 * Manages report instances and handles resource cleanup
 */
package com.cssmart.reporting;

import com.cssmart.logging.CSSmartLogger;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

public class CSSmartReportManager {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReportManager INSTANCE = new CSSmartReportManager();
    private final ConcurrentHashMap<Long, CSSmartReport> reportInstances = new ConcurrentHashMap<>();
    private final AtomicBoolean initialized = new AtomicBoolean(false);
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private CSSmartReportManager() {
    }
    
    /**
     * Get the singleton instance
     * @return the CSSmartReportManager instance
     */
    public static CSSmartReportManager getInstance() {
        return INSTANCE;
    }
    
    /**
     * Initialize the report manager
     */
    public void initialize() {
        if (initialized.compareAndSet(false, true)) {
            logger.info("Initializing CSSmartReportManager");
            // Register shutdown hook to ensure reports are generated on JVM exit
            Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
        }
    }
    
    /**
     * Register a report instance
     * @param threadId the thread ID
     * @param report the report instance
     */
    public void registerReportInstance(long threadId, CSSmartReport report) {
        reportInstances.put(threadId, report);
    }
    
    /**
     * Get a report instance for the current thread
     * @return the report instance
     */
    public CSSmartReport getReportForCurrentThread() {
        long threadId = Thread.currentThread().getId();
        CSSmartReport report = reportInstances.get(threadId);
        
        if (report == null) {
            report = CSSmartReport.getInstance();
            registerReportInstance(threadId, report);
        }
        
        return report;
    }
    
    /**
     * Shutdown hook to generate all reports on JVM exit
     */
    public void shutdown() {
        logger.info("Shutting down CSSmartReportManager");
        
        // Generate all reports
        for (CSSmartReport report : reportInstances.values()) {
            try {
                report.generateAllReports();
            } catch (Exception e) {
                logger.error("Failed to generate reports during shutdown", e);
            }
        }
        
        logger.info("CSSmartReportManager shutdown complete");
    }
}
            if (scenario != null) {
                sb.append(", Scenario: ").append(scenario);
            }
            
            if (lineNumber >= 0) {
                sb.append(", Line: ").append(lineNumber);
            }
            
            sb.append(")");
        }
        
        return sb.toString();
    }
}


/**
 * CSSmartConfig.java
 * Environment-aware configuration management with multiple format support
 */
package com.cssmart.config;

import com.cssmart.exceptions.CSSmartConfigException;
import com.cssmart.logging.CSSmartLogger;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

public class CSSmartConfig {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final ThreadLocal<CSSmartConfig> INSTANCE = ThreadLocal.withInitial(CSSmartConfig::new);
    
    private final Map<String, String> configMap = new ConcurrentHashMap<>();
    private final String environment;
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private CSSmartConfig() {
        // Load environment
        this.environment = System.getProperty("cssmart.env", "default").toLowerCase();
        logger.info("Initializing configuration for environment: " + environment);
        
        // Load properties
        loadPropertiesFile("application.properties");
        loadPropertiesFile("application-" + environment + ".properties");
        
        // Load YAML configurations
        loadYamlFile("config.yaml");
        loadYamlFile("config-" + environment + ".yaml");
        
        // Load JSON configurations
        loadJsonFile("config.json");
        loadJsonFile("config-" + environment + ".json");
        
        // Override with system properties
        loadSystemProperties();
        
        // Override with environment variables
        loadEnvironmentVariables();
        
        logger.info("Configuration initialized with " + configMap.size() + " properties");
    }
    
    /**
     * Get the singleton instance
     * @return the CSSmartConfig instance
     */
    public static CSSmartConfig getInstance() {
        return INSTANCE.get();
    }
    
    /**
     * Get a property value
     * @param key the property key
     * @return the property value or null if not found
     */
    public String getProperty(String key) {
        return configMap.get(key);
    }
    
    /**
     * Get a property value with a default value
     * @param key the property key
     * @param defaultValue the default value to return if the key is not found
     * @return the property value or the default value if not found
     */
    public String getProperty(String key, String defaultValue) {
        return configMap.getOrDefault(key, defaultValue);
    }
    
    /**
     * Get a property as an integer
     * @param key the property key
     * @param defaultValue the default value to return if the key is not found or cannot be parsed
     * @return the property value as an integer or the default value
     */
    public int getIntProperty(String key, int defaultValue) {
        String value = getProperty(key);
        if (value != null) {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e) {
                logger.warning("Failed to parse integer property: " + key + " = " + value);
            }
        }
        return defaultValue;
    }
    
    /**
     * Get a property as a boolean
     * @param key the property key
     * @param defaultValue the default value to return if the key is not found
     * @return the property value as a boolean or the default value
     */
    public boolean getBooleanProperty(String key, boolean defaultValue) {
        String value = getProperty(key);
        if (value != null) {
            return Boolean.parseBoolean(value);
        }
        return defaultValue;
    }
    
    /**
     * Set a property value
     * @param key the property key
     * @param value the property value
     */
    public void setProperty(String key, String value) {
        configMap.put(key, value);
    }
    
    /**
     * Check if a property exists
     * @param key the property key
     * @return true if the property exists
     */
    public boolean hasProperty(String key) {
        return configMap.containsKey(key);
    }
    
    /**
     * Get the current environment
     * @return the environment name
     */
    public String getEnvironment() {
        return environment;
    }
    
    /**
     * Get all properties
     * @return a map of all properties
     */
    public Map<String, String> getAllProperties() {
        return new HashMap<>(configMap);
    }
    
    /**
     * Load properties from a properties file
     * @param filename the file name
     */
    private void loadPropertiesFile(String filename) {
        try (InputStream inputStream = getResourceStream(filename)) {
            if (inputStream != null) {
                Properties properties = new Properties();
                properties.load(inputStream);
                
                for (String name : properties.stringPropertyNames()) {
                    configMap.put(name, properties.getProperty(name));
                }
                
                logger.info("Loaded properties from: " + filename);
            }
        } catch (IOException e) {
            logger.info("Properties file not found or could not be loaded: " + filename);
        }
    }
    
    /**
     * Load properties from a YAML file
     * @param filename the file name
     */
    private void loadYamlFile(String filename) {
        try (InputStream inputStream = getResourceStream(filename)) {
            if (inputStream != null) {
                ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
                Map<String, Object> yamlMap = mapper.readValue(inputStream, Map.class);
                
                // Flatten the YAML map
                flattenMap("", yamlMap);
                
                logger.info("Loaded YAML configuration from: " + filename);
            }
        } catch (IOException e) {
            logger.info("YAML file not found or could not be loaded: " + filename);
        }
    }
    
    /**
     * Load properties from a JSON file
     * @param filename the file name
     */
    private void loadJsonFile(String filename) {
        try (InputStream inputStream = getResourceStream(filename)) {
            if (inputStream != null) {
                ObjectMapper mapper = new ObjectMapper();
                Map<String, Object> jsonMap = mapper.readValue(inputStream, Map.class);
                
                // Flatten the JSON map
                flattenMap("", jsonMap);
                
                logger.info("Loaded JSON configuration from: " + filename);
            }
        } catch (IOException e) {
            logger.info("JSON file not found or could not be loaded: " + filename);
        }
    }
    
    /**
     * Load properties from system properties
     */
    private void loadSystemProperties() {
        Properties systemProperties = System.getProperties();
        for (String name : systemProperties.stringPropertyNames()) {
            if (name.startsWith("cssmart.")) {
                String key = name.substring("cssmart.".length());
                configMap.put(key, systemProperties.getProperty(name));
            }
        }
        logger.info("Loaded system properties");
    }
    
    /**
     * Load properties from environment variables
     */
    private void loadEnvironmentVariables() {
        Map<String, String> env = System.getenv();
        for (Map.Entry<String, String> entry : env.entrySet()) {
            String name = entry.getKey();
            if (name.startsWith("CSSMART_")) {
                String key = name.substring("CSSMART_".length()).toLowerCase().replace('_', '.');
                configMap.put(key, entry.getValue());
            }
        }
        logger.info("Loaded environment variables");
    }
    
    /**
     * Get a resource as an input stream
     * @param filename the file name
     * @return the input stream or null if the resource is not found
     */
    private InputStream getResourceStream(String filename) {
        // First try to load from classpath
        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(filename);
        
        // If not found, try to load from file system
        if (inputStream == null) {
            try {
                File file = new File(filename);
                if (file.exists()) {
                    inputStream = new FileInputStream(file);
                }
            } catch (IOException e) {
                logger.debug("File not found in file system: " + filename);
            }
        }
        
        return inputStream;
    }
    
    /**
     * Flatten a nested map into a single level map with dot notation
     * @param prefix the prefix for keys
     * @param map the map to flatten
     */
    private void flattenMap(String prefix, Map<String, Object> map) {
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            String key = prefix.isEmpty() ? entry.getKey() : prefix + "." + entry.getKey();
            Object value = entry.getValue();
            
            if (value instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> nestedMap = (Map<String, Object>) value;
                flattenMap(key, nestedMap);
            } else {
                configMap.put(key, value != null ? value.toString() : null);
            }
        }
    }
    
    /**
     * Reload all configurations
     */
    public void reload() {
        configMap.clear();
        
        // Load properties
        loadPropertiesFile("application.properties");
        loadPropertiesFile("application-" + environment + ".properties");
        
        // Load YAML configurations
        loadYamlFile("config.yaml");
        loadYamlFile("config-" + environment + ".yaml");
        
        // Load JSON configurations
        loadJsonFile("config.json");
        loadJsonFile("config-" + environment + ".json");
        
        // Override with system properties
        loadSystemProperties();
        
        // Override with environment variables
        loadEnvironmentVariables();
        
        logger.info("Configuration reloaded with " + configMap.size() + " properties");
    }
}

/**
 * CSSmartPropertyManager.java
 * Manages application properties specifically for ADO integration
 */
package com.cssmart.config;

import com.cssmart.exceptions.CSSmartConfigException;
import com.cssmart.logging.CSSmartLogger;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

public class CSSmartPropertyManager {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartPropertyManager INSTANCE = new CSSmartPropertyManager();
    
    private final Properties properties = new Properties();
    private String propertiesFilePath = "src/main/resources/application.properties";
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private CSSmartPropertyManager() {
        loadProperties();
    }
    
    /**
     * Get the singleton instance
     * @return the CSSmartPropertyManager instance
     */
    public static CSSmartPropertyManager getInstance() {
        return INSTANCE;
    }
    
    /**
     * Load properties from the application.properties file
     */
    public void loadProperties() {
        try (InputStream input = new FileInputStream(propertiesFilePath)) {
            properties.load(input);
            logger.info("Loaded properties from: " + propertiesFilePath);
        } catch (IOException e) {
            logger.info("Properties file not found, creating new one: " + propertiesFilePath);
            
            try {
                Path directory = Paths.get(propertiesFilePath).getParent();
                if (directory != null && !Files.exists(directory)) {
                    Files.createDirectories(directory);
                }
                saveProperties();
            } catch (IOException ex) {
                throw new CSSmartConfigException("Failed to create properties file: " + propertiesFilePath, ex);
            }
        }
    }
    
    /**
     * Save properties to the application.properties file
     */
    public void saveProperties() {
        try (OutputStream output = new FileOutputStream(propertiesFilePath)) {
            properties.store(output, "CSSmartFramework Properties");
            logger.info("Saved properties to: " + propertiesFilePath);
        } catch (IOException e) {
            throw new CSSmartConfigException("Failed to save properties to: " + propertiesFilePath, e);
        }
    }
    
    /**
     * Set the properties file path
     * @param path the path to the properties file
     */
    public void setPropertiesFilePath(String path) {
        this.propertiesFilePath = path;
        loadProperties();
    }
    
    /**
     * Get a property value
     * @param key the property key
     * @return the property value or null if not found
     */
    public String getProperty(String key) {
        return properties.getProperty(key);
    }
    
    /**
     * Get a property value with a default value
     * @param key the property key
     * @param defaultValue the default value to return if the key is not found
     * @return the property value or the default value if not found
     */
    public String getProperty(String key, String defaultValue) {
        return properties.getProperty(key, defaultValue);
    }
    
    /**
     * Set a property value
     * @param key the property key
     * @param value the property value
     */
    public void setProperty(String key, String value) {
        properties.setProperty(key, value);
    }
    
    /**
     * Remove a property
     * @param key the property key
     */
    public void removeProperty(String key) {
        properties.remove(key);
    }
    
    /**
     * Check if a property exists
     * @param key the property key
     * @return true if the property exists
     */
    public boolean containsProperty(String key) {
        return properties.containsKey(key);
    }
    
    /**
     * Get all ADO related properties
     * @return a Properties object containing only ADO related properties
     */
    public Properties getADOProperties() {
        Properties adoProperties = new Properties();
        
        for (String key : properties.stringPropertyNames()) {
            if (key.startsWith("ado.")) {
                adoProperties.setProperty(key, properties.getProperty(key));
            }
        }
        
        return adoProperties;
    }
    
    /**
     * Configure ADO integration
     * @param url the ADO URL
     * @param token the personal access token
     * @param project the project name
     * @param testPlanId the test plan ID
     */
    public void configureADO(String url, String token, String project, String testPlanId) {
        setProperty("ado.url", url);
        setProperty("ado.token", token);
        setProperty("ado.project", project);
        setProperty("ado.testplan.id", testPlanId);
        saveProperties();
        
        logger.info("ADO integration configured");
    }
    
    /**
     * Enable or disable ADO integration
     * @param enabled true to enable, false to disable
     */
    public void setADOEnabled(boolean enabled) {
        setProperty("ado.enabled", String.valueOf(enabled));
        saveProperties();
        
        logger.info("ADO integration " + (enabled ? "enabled" : "disabled"));
    }
    
    /**
     * Check if ADO integration is enabled
     * @return true if ADO integration is enabled
     */
    public boolean isADOEnabled() {
        return Boolean.parseBoolean(getProperty("ado.enabled", "false"));
    }
    
    /**
     * Set ADO synchronization mode
     * @param mode the synchronization mode (MANUAL, AUTO)
     */
    public void setADOSyncMode(String mode) {
        setProperty("ado.sync.mode", mode.toUpperCase());
        saveProperties();
        
        logger.info("ADO synchronization mode set to: " + mode);
    }
}


/**
 * CSSmartDriver.java
 * Thread-safe wrapper with enhanced navigation capabilities
 */
package com.cssmart.driver;

import com.cssmart.exceptions.CSSmartDriverException;
import com.cssmart.logging.CSSmartLogger;
import com.cssmart.reporting.CSSmartReport;
import org.openqa.selenium.By;
import org.openqa.selenium.Capabilities;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.safari.SafariDriver;

import java.net.URL;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

public class CSSmartDriver implements WebDriver {
    private static final CSSmartLogger logger = CSSmartLogger.getInstance();
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static final ThreadLocal<WebDriver> threadDriver = new ThreadLocal<>();
    private static final Map<Long, String> threadBrowserTypes = new ConcurrentHashMap<>();
    
    private final WebDriver driver;
    private final String browserType;
    
    /**
     * Constructor with WebDriver
     * @param driver the WebDriver to wrap
     */
    public CSSmartDriver(WebDriver driver) {
        this.driver = driver;
        this.browserType = getBrowserTypeFromDriver(driver);
        
        // Set default timeouts
        setDefaultTimeouts();
        
        // Store in ThreadLocal
        threadDriver.set(driver);
        threadBrowserTypes.put(Thread.currentThread().getId(), browserType);
        
        logger.info("Created CSSmartDriver for browser: " + browserType);
    }
    
    /**
     * Get a CSSmartDriver instance for the current thread
     * @return the CSSmartDriver instance
     */
    public static CSSmartDriver getInstance() {
        WebDriver driver = threadDriver.get();
        if (driver == null) {
            throw new CSSmartDriverException("No WebDriver instance for current thread. Initialize driver first.");
        }
        return new CSSmartDriver(driver);
    }
    
    /**
     * Create a new driver instance
     * @param browserType the browser type (chrome, firefox, edge, safari)
     * @return a new CSSmartDriver instance
     */
    public static CSSmartDriver createDriver(String browserType) {
        WebDriver driver;
        
        try {
            switch (browserType.toLowerCase()) {
                case "chrome":
                    driver = new ChromeDriver();
                    break;
                case "firefox":
                    driver = new FirefoxDriver();
                    break;
                case "edge":
                    driver = new EdgeDriver();
                    break;
                case "safari":
                    driver = new SafariDriver();
                    break;
                default:
                    throw new CSSmartDriverException("Unsupported browser type: " + browserType);
            }
            
            return new CSSmartDriver(driver);
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to create driver for browser: " + browserType, e);
        }
    }
    
    /**
     * Create a remote driver instance
     * @param remoteUrl the remote WebDriver URL
     * @param capabilities the capabilities
     * @return a new CSSmartDriver instance
     */
    public static CSSmartDriver createRemoteDriver(URL remoteUrl, Capabilities capabilities) {
        try {
            WebDriver driver = new RemoteWebDriver(remoteUrl, capabilities);
            return new CSSmartDriver(driver);
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to create remote driver", e);
        }
    }
    
    /**
     * Switch to a different browser mid-execution
     * @param newBrowserType the new browser type (chrome, firefox, edge, safari)
     * @return a new CSSmartDriver instance
     */
    public CSSmartDriver switchBrowser(String newBrowserType) {
        logger.info("Switching browser from " + browserType + " to " + newBrowserType);
        report.logInfo("Switching browser from " + browserType + " to " + newBrowserType);
        
        // Quit the current driver
        quit();
        
        // Create a new driver
        CSSmartDriver newDriver = createDriver(newBrowserType);
        
        // Update ThreadLocal
        threadDriver.set(newDriver.getWrappedDriver());
        threadBrowserTypes.put(Thread.currentThread().getId(), newBrowserType);
        
        return newDriver;
    }
    
    /**
     * Get the browser type for the current thread
     * @return the browser type
     */
    public static String getCurrentBrowserType() {
        return threadBrowserTypes.getOrDefault(Thread.currentThread().getId(), "unknown");
    }
    
    /**
     * Get the underlying WebDriver
     * @return the WebDriver
     */
    public WebDriver getWrappedDriver() {
        return driver;
    }
    
    /**
     * Get the browser type
     * @return the browser type
     */
    public String getBrowserType() {
        return browserType;
    }
    
    /**
     * Get the browser type from a WebDriver instance
     * @param driver the WebDriver
     * @return the browser type
     */
    private String getBrowserTypeFromDriver(WebDriver driver) {
        String driverClass = driver.getClass().getSimpleName().toLowerCase();
        
        if (driverClass.contains("chrome")) {
            return "chrome";
        } else if (driverClass.contains("firefox")) {
            return "firefox";
        } else if (driverClass.contains("edge")) {
            return "edge";
        } else if (driverClass.contains("safari")) {
            return "safari";
        } else if (driverClass.contains("remote")) {
            Capabilities caps = ((RemoteWebDriver) driver).getCapabilities();
            return caps.getBrowserName().toLowerCase();
        } else {
            return "unknown";
        }
    }
    
    /**
     * Set default timeouts
     */
    private void setDefaultTimeouts() {
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(20));
    }
    
    // Enhanced WebDriver methods
    
    @Override
    public void get(String url) {
        try {
            logger.info("Navigating to URL: " + url);
            report.logInfo("Navigating to URL: " + url);
            driver.get(url);
        } catch (Exception e) {
            report.logError("Failed to navigate to URL: " + url);
            throw new CSSmartDriverException("Failed to navigate to URL: " + url, e);
        }
    }
    
    /**
     * Navigate to a URL with timeout
     * @param url the URL to navigate to
     * @param timeoutSeconds the timeout in seconds
     */
    public void get(String url, int timeoutSeconds) {
        try {
            logger.info("Navigating to URL with timeout: " + url);
            report.logInfo("Navigating to URL with timeout: " + url);
            
            // Set custom timeout for this navigation
            driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(timeoutSeconds));
            driver.get(url);
            
            // Reset to default timeout
            driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));
        } catch (Exception e) {
            report.logError("Failed to navigate to URL with timeout: " + url);
            throw new CSSmartDriverException("Failed to navigate to URL with timeout: " + url, e);
        }
    }
    
    @Override
    public String getCurrentUrl() {
        try {
            String url = driver.getCurrentUrl();
            logger.debug("Current URL: " + url);
            return url;
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to get current URL", e);
        }
    }
    
    @Override
    public String getTitle() {
        try {
            String title = driver.getTitle();
            logger.debug("Page title: " + title);
            return title;
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to get page title", e);
        }
    }
    
    @Override
    public List<WebElement> findElements(By by) {
        try {
            List<WebElement> elements = driver.findElements(by);
            logger.debug("Found " + elements.size() + " elements: " + by);
            
            // Convert to CSSmartWebElement list
            List<WebElement> smartElements = new ArrayList<>();
            for (int i = 0; i < elements.size(); i++) {
                smartElements.add(new CSSmartWebElement(this, elements.get(i), by, "Element " + i));
            }
            
            return smartElements;
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to find elements: " + by, e);
        }
    }
    
    @Override
    public CSSmartWebElement findElement(By by) {
        try {
            logger.debug("Finding element: " + by);
            WebElement element = driver.findElement(by);
            return new CSSmartWebElement(this, element, by, by.toString());
        } catch (Exception e) {
            report.logError("Failed to find element: " + by);
            throw new CSSmartDriverException("Failed to find element: " + by, e);
        }
    }
    
    /**
     * Find element by locator and name
     * @param by the locator
     * @param elementName the element name for reporting
     * @return a CSSmartWebElement
     */
    public CSSmartWebElement findElement(By by, String elementName) {
        try {
            logger.debug("Finding element: " + elementName + " by: " + by);
            WebElement element = driver.findElement(by);
            return new CSSmartWebElement(this, element, by, elementName);
        } catch (Exception e) {
            report.logError("Failed to find element: " + elementName + " by: " + by);
            throw new CSSmartDriverException("Failed to find element: " + elementName + " by: " + by, e);
        }
    }
    
    @Override
    public String getPageSource() {
        try {
            return driver.getPageSource();
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to get page source", e);
        }
    }
    
    @Override
    public void close() {
        try {
            logger.info("Closing browser window");
            report.logInfo("Closing browser window");
            driver.close();
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to close browser window", e);
        }
    }
    
    @Override
    public void quit() {
        try {
            logger.info("Quitting browser");
            report.logInfo("Quitting browser");
            driver.quit();
            
            // Remove from ThreadLocal
            threadDriver.remove();
            threadBrowserTypes.remove(Thread.currentThread().getId());
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to quit browser", e);
        }
    }
    
    @Override
    public Set<String> getWindowHandles() {
        try {
            return driver.getWindowHandles();
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to get window handles", e);
        }
    }
    
    @Override
    public String getWindowHandle() {
        try {
            return driver.getWindowHandle();
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to get window handle", e);
        }
    }
    
    @Override
    public TargetLocator switchTo() {
        return driver.switchTo();
    }
    
    @Override
    public Navigation navigate() {
        return driver.navigate();
    }
    
    @Override
    public Options manage() {
        return driver.manage();
    }
    
    /**
     * Take a screenshot
     * @param screenshotName the name of the screenshot
     * @return the path to the saved screenshot
     */
    public String takeScreenshot(String screenshotName) {
        return report.takeScreenshot(this, screenshotName);
    }
    
    /**
     * Refresh the page
     */
    public void refresh() {
        try {
            logger.info("Refreshing page");
            report.logInfo("Refreshing page");
            driver.navigate().refresh();
        } catch (Exception e) {
            throw new CSSmartDriverException("Failed to refresh page", e);
        }
    }
}

package com.cloudsmart.framework.elements;

import com.cloudsmart.framework.ai.CSSmartAIElementFinder;
import com.cloudsmart.framework.ai.CSSmartAIContextAnalyzer;
import com.cloudsmart.framework.exceptions.ElementInteractionException;
import com.cloudsmart.framework.exceptions.ElementNotFoundException;
import com.cloudsmart.framework.logger.CSLogger;
import com.cloudsmart.framework.utils.Configuration;
import com.cloudsmart.framework.utils.RetryMechanism;
import com.cloudsmart.framework.utils.WaitUtil;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

/**
 * Enhanced WebElement wrapper providing self-healing capabilities,
 * advanced interactions, and AI-powered element discovery.
 */
public class CSSmartWebElement implements WebElement {
    private static final CSLogger logger = CSLogger.getInstance();
    private final String elementName;
    private final CSSmartDriver driver;
    private final By originalLocator;
    private final Map<String, Object> properties;
    private final RetryMechanism retryMechanism;
    private final CSSmartAIElementFinder aiFinder;
    private final CSSmartAIContextAnalyzer contextAnalyzer;
    
    // Cache for found elements to prevent repeated lookups
    private WebElement cachedElement;
    private long cacheTimestamp;
    private static final long CACHE_EXPIRY_MS = 500;
    
    // List of alternative locators for self-healing
    private List<By> alternativeLocators;
    
    /**
     * Constructor for CSSmartWebElement
     * 
     * @param driver The CSSmartDriver instance
     * @param locator The original locator used to find this element
     * @param elementName A descriptive name for this element
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, String elementName) {
        this.driver = driver;
        this.originalLocator = locator;
        this.elementName = elementName;
        this.properties = new ConcurrentHashMap<>();
        this.retryMechanism = new RetryMechanism();
        this.aiFinder = new CSSmartAIElementFinder(driver);
        this.contextAnalyzer = new CSSmartAIContextAnalyzer(driver);
        this.alternativeLocators = new ArrayList<>();
        
        // Initialize properties with basic information
        properties.put("originalLocator", locator.toString());
        properties.put("elementName", elementName);
    }
    
    /**
     * Find the actual WebElement, with self-healing capabilities if the original locator fails
     * 
     * @return The found WebElement
     * @throws ElementNotFoundException if element cannot be found through any mechanism
     */
    private WebElement findElement() {
        // Check if cache is valid
        if (cachedElement != null && System.currentTimeMillis() - cacheTimestamp < CACHE_EXPIRY_MS) {
            try {
                // Verify cached element is still attached to DOM
                cachedElement.isEnabled();
                return cachedElement;
            } catch (StaleElementReferenceException e) {
                logger.debug("Cached element for " + elementName + " is stale, finding again");
                // Let it fall through to find the element again
            }
        }
        
        // Try the original locator first
        try {
            WebElement element = retryMechanism.retry(() -> driver.findElement(originalLocator), 
                    "Finding element with original locator: " + originalLocator);
            updateCache(element);
            return element;
        } catch (ElementNotFoundException e) {
            logger.info("Element not found with original locator: " + originalLocator + ", trying self-healing...");
            
            // Try alternative locators if available
            if (!alternativeLocators.isEmpty()) {
                for (By alternative : alternativeLocators) {
                    try {
                        WebElement element = driver.findElement(alternative);
                        logger.info("Element found using alternative locator: " + alternative);
                        updateCache(element);
                        return element;
                    } catch (Exception ex) {
                        // Continue to next alternative
                    }
                }
            }
            
            // Use AI-powered element finding as last resort
            try {
                // Create a context for the element search
                String pageContext = contextAnalyzer.analyzeCurrentPageContext();
                properties.put("pageContext", pageContext);
                
                WebElement element = aiFinder.findElementByDescription(elementName, pageContext);
                if (element != null) {
                    // Learn from this successful find for future use
                    By newLocator = aiFinder.generateLocatorFromElement(element);
                    if (newLocator != null && !alternativeLocators.contains(newLocator)) {
                        alternativeLocators.add(newLocator);
                        logger.info("Added new alternative locator for " + elementName + ": " + newLocator);
                    }
                    
                    updateCache(element);
                    return element;
                }
            } catch (Exception aiException) {
                logger.error("AI-powered element finding failed for " + elementName, aiException);
            }
            
            // If all methods fail, throw exception
            throw new ElementNotFoundException("Element '" + elementName + "' could not be found with any method", e);
        }
    }
    
    /**
     * Update the cached element and timestamp
     */
    private void updateCache(WebElement element) {
        cachedElement = element;
        cacheTimestamp = System.currentTimeMillis();
    }
    
    /**
     * Clear the element cache to force a fresh lookup
     */
    public void clearCache() {
        cachedElement = null;
    }
    
    /**
     * Add an alternative locator for this element
     * 
     * @param locator Alternative By locator
     */
    public void addAlternativeLocator(By locator) {
        if (!alternativeLocators.contains(locator)) {
            alternativeLocators.add(locator);
        }
    }
    
    /**
     * Get all associated properties for this element
     */
    public Map<String, Object> getProperties() {
        return properties;
    }
    
    /**
     * Set a property for this element
     */
    public void setProperty(String key, Object value) {
        properties.put(key, value);
    }
    
    /**
     * Get a property for this element
     */
    public Object getProperty(String key) {
        return properties.get(key);
    }
    
    /* WebElement interface implementation */
    
    @Override
    public void click() {
        retryMechanism.retry(() -> {
            try {
                WebElement element = findElement();
                scrollIntoView(element);
                waitForElementToBeClickable(element);
                element.click();
                logger.info("Clicked on element: " + elementName);
                return true;
            } catch (ElementClickInterceptedException e) {
                // Try JS click as fallback
                executeJsClick();
                return true;
            }
        }, "Clicking element: " + elementName);
    }
    
    /**
     * Click using JavaScript as a fallback method
     */
    public void executeJsClick() {
        WebElement element = findElement();
        logger.info("Using JavaScript click fallback for: " + elementName);
        driver.executeScript("arguments[0].click();", element);
    }
    
    /**
     * Scroll element into view
     */
    public void scrollIntoView() {
        scrollIntoView(findElement());
    }
    
    private void scrollIntoView(WebElement element) {
        driver.executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element);
        WaitUtil.waitForMillis(300); // Small wait for scroll to complete
    }
    
    /**
     * Wait for element to be clickable
     */
    private void waitForElementToBeClickable(WebElement element) {
        int timeout = Configuration.getInt("element.click.timeout", 10);
        new WebDriverWait(driver, Duration.ofSeconds(timeout))
                .until(ExpectedConditions.elementToBeClickable(element));
    }
    
    @Override
    public void submit() {
        retryMechanism.retry(() -> {
            findElement().submit();
            logger.info("Submitted form using element: " + elementName);
            return true;
        }, "Submitting form with element: " + elementName);
    }
    
    @Override
    public void sendKeys(CharSequence... keysToSend) {
        retryMechanism.retry(() -> {
            WebElement element = findElement();
            element.clear();
            element.sendKeys(keysToSend);
            logger.info("Sent keys to element: " + elementName);
            return true;
        }, "Sending keys to element: " + elementName);
    }
    
    /**
     * Enhanced sendKeys with additional waiting and verification
     */
    public void sendKeysWithVerification(CharSequence... keysToSend) {
        retryMechanism.retry(() -> {
            WebElement element = findElement();
            scrollIntoView(element);
            element.clear();
            element.sendKeys(keysToSend);
            
            // Verify the text was entered correctly
            String enteredText = element.getAttribute("value");
            String expectedText = String.join("", keysToSend);
            
            if (enteredText == null || !enteredText.contains(expectedText)) {
                logger.warn("Text verification failed. Expected: " + expectedText + ", Got: " + enteredText);
                throw new ElementInteractionException("Text verification failed for element: " + elementName);
            }
            
            logger.info("Successfully sent and verified keys to element: " + elementName);
            return true;
        }, "Sending keys with verification to element: " + elementName);
    }
    
    @Override
    public void clear() {
        retryMechanism.retry(() -> {
            findElement().clear();
            logger.info("Cleared element: " + elementName);
            return true;
        }, "Clearing element: " + elementName);
    }
    
    @Override
    public String getTagName() {
        return retryMechanism.retry(() -> 
            findElement().getTagName(),
            "Getting tag name of element: " + elementName
        );
    }
    
    @Override
    public String getAttribute(String name) {
        return retryMechanism.retry(() -> 
            findElement().getAttribute(name),
            "Getting attribute '" + name + "' of element: " + elementName
        );
    }
    
    @Override
    public boolean isSelected() {
        return retryMechanism.retry(() -> 
            findElement().isSelected(),
            "Checking if element is selected: " + elementName
        );
    }
    
    @Override
    public boolean isEnabled() {
        return retryMechanism.retry(() -> 
            findElement().isEnabled(),
            "Checking if element is enabled: " + elementName
        );
    }
    
    @Override
    public String getText() {
        return retryMechanism.retry(() -> {
            String text = findElement().getText();
            logger.debug("Got text from element '" + elementName + "': " + text);
            return text;
        }, "Getting text from element: " + elementName);
    }
    
    @Override
    public List<WebElement> findElements(By by) {
        return retryMechanism.retry(() -> {
            List<WebElement> elements = findElement().findElements(by);
            logger.debug("Found " + elements.size() + " elements with locator " + by + " inside element: " + elementName);
            return elements;
        }, "Finding elements with locator " + by + " inside element: " + elementName);
    }
    
    @Override
    public WebElement findElement(By by) {
        return retryMechanism.retry(() -> {
            WebElement element = findElement().findElement(by);
            logger.debug("Found element with locator " + by + " inside element: " + elementName);
            return element;
        }, "Finding element with locator " + by + " inside element: " + elementName);
    }
    
    @Override
    public boolean isDisplayed() {
        try {
            return retryMechanism.retry(() -> 
                findElement().isDisplayed(),
                "Checking if element is displayed: " + elementName
            );
        } catch (ElementNotFoundException e) {
            return false;
        }
    }
    
    @Override
    public Point getLocation() {
        return retryMechanism.retry(() -> 
            findElement().getLocation(),
            "Getting location of element: " + elementName
        );
    }
    
    @Override
    public Dimension getSize() {
        return retryMechanism.retry(() -> 
            findElement().getSize(),
            "Getting size of element: " + elementName
        );
    }
    
    @Override
    public Rectangle getRect() {
        return retryMechanism.retry(() -> 
            findElement().getRect(),
            "Getting rectangle of element: " + elementName
        );
    }
    
    @Override
    public String getCssValue(String propertyName) {
        return retryMechanism.retry(() -> 
            findElement().getCssValue(propertyName),
            "Getting CSS value '" + propertyName + "' of element: " + elementName
        );
    }
    
    @Override
    public <X> X getScreenshotAs(OutputType<X> target) throws WebDriverException {
        return retryMechanism.retry(() -> {
            WebElement element = findElement();
            scrollIntoView(element);
            return element.getScreenshotAs(target);
        }, "Taking screenshot of element: " + elementName);
    }
    
    /* Enhanced Methods */
    
    /**
     * Wait for element to be visible
     * 
     * @param timeoutInSeconds Timeout in seconds
     */
    public boolean waitForVisibility(int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            wait.until(d -> {
                try {
                    return findElement().isDisplayed();
                } catch (Exception e) {
                    return false;
                }
            });
            return true;
        } catch (TimeoutException e) {
            logger.warn("Element '" + elementName + "' did not become visible within " + timeoutInSeconds + " seconds");
            return false;
        }
    }
    
    /**
     * Wait for element to disappear
     * 
     * @param timeoutInSeconds Timeout in seconds
     */
    public boolean waitForInvisibility(int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            wait.until(d -> {
                try {
                    return !findElement().isDisplayed();
                } catch (ElementNotFoundException | StaleElementReferenceException e) {
                    return true;
                }
            });
            return true;
        } catch (TimeoutException e) {
            logger.warn("Element '" + elementName + "' did not disappear within " + timeoutInSeconds + " seconds");
            return false;
        }
    }
    
    /**
     * Hover over the element
     */
    public void hover() {
        retryMechanism.retry(() -> {
            WebElement element = findElement();
            scrollIntoView(element);
            new Actions(driver).moveToElement(element).perform();
            logger.info("Hovered over element: " + elementName);
            return true;
        }, "Hovering over element: " + elementName);
    }
    
    /**
     * Double click on the element
     */
    public void doubleClick() {
        retryMechanism.retry(() -> {
            WebElement element = findElement();
            scrollIntoView(element);
            new Actions(driver).doubleClick(element).perform();
            logger.info("Double-clicked on element: " + elementName);
            return true;
        }, "Double-clicking element: " + elementName);
    }
    
    /**
     * Right click on the element
     */
    public void rightClick() {
        retryMechanism.retry(() -> {
            WebElement element = findElement();
            scrollIntoView(element);
            new Actions(driver).contextClick(element).perform();
            logger.info("Right-clicked on element: " + elementName);
            return true;
        }, "Right-clicking element: " + elementName);
    }
    
    /**
     * Drag and drop to target element
     * 
     * @param target The target element to drop onto
     */
    public void dragAndDropTo(CSSmartWebElement target) {
        retryMechanism.retry(() -> {
            WebElement sourceElement = findElement();
            WebElement targetElement = target.findElement();
            scrollIntoView(sourceElement);
            
            new Actions(driver)
                .clickAndHold(sourceElement)
                .moveToElement(targetElement)
                .release()
                .perform();
                
            logger.info("Dragged element '" + elementName + "' to element '" + target.elementName + "'");
            return true;
        }, "Dragging element '" + elementName + "' to element '" + target.elementName + "'");
    }
    
    /**
     * Get element's calculated accessibility score
     * 
     * @return Score between 0-100
     */
    public int getAccessibilityScore() {
        return retryMechanism.retry(() -> {
            WebElement element = findElement();
            String axeScript = "return window.axe.run(arguments[0]).then(results => results.score);";
            
            // Check if axe is loaded, if not, load it
            Boolean axeLoaded = (Boolean) driver.executeScript(
                "return typeof window.axe !== 'undefined';"
            );
            
            if (!axeLoaded) {
                driver.executeScript(
                    "var s = document.createElement('script');" +
                    "s.src = 'https://cdnjs.cloudflare.com/ajax/libs/axe-core/4.5.0/axe.min.js';" +
                    "document.head.appendChild(s);" +
                    "return new Promise(resolve => s.onload = resolve);"
                );
            }
            
            Object result = driver.executeAsyncScript(axeScript, element);
            if (result instanceof Number) {
                return ((Number) result).intValue();
            }
            return 0;
        }, "Getting accessibility score for element: " + elementName);
    }
    
    /**
     * Check if element has a specific text
     */
    public boolean hasText(String expectedText) {
        return getText().contains(expectedText);
    }
    
    /**
     * Check if element matches a text exactly
     */
    public boolean hasExactText(String expectedText) {
        return getText().equals(expectedText);
    }
    
    /**
     * Get element name
     */
    public String getElementName() {
        return elementName;
    }
    
    /**
     * Get original locator
     */
    public By getOriginalLocator() {
        return originalLocator;
    }
    
    @Override
    public String toString() {
        return "CSSmartWebElement{" +
               "name='" + elementName + '\'' +
               ", locator=" + originalLocator +
               '}';
    }
}


package com.cloudsmart.framework.ai;

import com.cloudsmart.framework.elements.CSSmartWebElement;
import com.cloudsmart.framework.logger.CSLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Represents the context of a web page, including its structure, content,
 * and semantic relationships. Used for intelligent element finding and
 * page understanding in the AI components.
 */
public class PageContext {
    private static final CSLogger logger = CSLogger.getInstance();
    
    // Page metadata
    private final String url;
    private final String title;
    private final String currentViewport;
    private final Map<String, Object> metadata;
    
    // Page structure
    private final Map<String, ElementInfo> elementInfoMap;
    private final List<ElementRelationship> relationships;
    private final Map<String, String> textContentMap;
    private final Set<String> visibleElementIds;
    
    // Navigation history
    private final List<String> navigationPath;
    
    // Page state
    private final long creationTimestamp;
    private Map<String, Double> elementImportanceScores;
    
    /**
     * Creates a new PageContext for the current state of the web page
     * 
     * @param driver The WebDriver instance
     * @param url The current URL
     * @param title The page title
     */
    public PageContext(WebDriver driver, String url, String title) {
        this.url = url;
        this.title = title;
        this.currentViewport = calculateViewport(driver);
        this.metadata = new ConcurrentHashMap<>();
        this.elementInfoMap = new ConcurrentHashMap<>();
        this.relationships = new ArrayList<>();
        this.textContentMap = new ConcurrentHashMap<>();
        this.visibleElementIds = Collections.newSetFromMap(new ConcurrentHashMap<>());
        this.navigationPath = new ArrayList<>();
        this.elementImportanceScores = new ConcurrentHashMap<>();
        this.creationTimestamp = System.currentTimeMillis();
        
        // Initialize with basic metadata
        metadata.put("userAgent", getUserAgent(driver));
        metadata.put("documentReadyState", getDocumentReadyState(driver));
        metadata.put("hasIframes", hasIframes(driver));
    }
    
    /**
     * Get the user agent from the browser
     */
    private String getUserAgent(WebDriver driver) {
        return (String) ((org.openqa.selenium.JavascriptExecutor) driver)
                .executeScript("return navigator.userAgent;");
    }
    
    /**
     * Get the document ready state
     */
    private String getDocumentReadyState(WebDriver driver) {
        return (String) ((org.openqa.selenium.JavascriptExecutor) driver)
                .executeScript("return document.readyState;");
    }
    
    /**
     * Check if the page has iframes
     */
    private boolean hasIframes(WebDriver driver) {
        return !driver.findElements(By.tagName("iframe")).isEmpty();
    }
    
    /**
     * Calculate the current viewport dimensions
     */
    private String calculateViewport(WebDriver driver) {
        Map<String, Long> dimensions = (Map<String, Long>) ((org.openqa.selenium.JavascriptExecutor) driver)
                .executeScript("return {width: window.innerWidth, height: window.innerHeight};");
        
        return dimensions.get("width") + "x" + dimensions.get("height");
    }
    
    /**
     * Add an element to the context
     * 
     * @param elementId A unique identifier for the element
     * @param element The WebElement
     * @param description Human-readable description of the element
     * @param isVisible Whether the element is currently visible
     */
    public void addElement(String elementId, WebElement element, String description, boolean isVisible) {
        ElementInfo info = new ElementInfo(elementId, element, description);
        elementInfoMap.put(elementId, info);
        
        if (isVisible) {
            visibleElementIds.add(elementId);
        }
        
        // Extract text content if available
        String text = element.getText();
        if (text != null && !text.isEmpty()) {
            textContentMap.put(elementId, text);
        }
        
        logger.debug("Added element to page context: " + elementId + " - " + description);
    }
    
    /**
     * Add a relationship between elements
     * 
     * @param sourceId Source element ID
     * @param targetId Target element ID
     * @param relationshipType Type of relationship (e.g., "contains", "isNextTo", "isAbove")
     */
    public void addRelationship(String sourceId, String targetId, String relationshipType) {
        if (elementInfoMap.containsKey(sourceId) && elementInfoMap.containsKey(targetId)) {
            relationships.add(new ElementRelationship(sourceId, targetId, relationshipType));
            logger.debug("Added relationship: " + sourceId + " " + relationshipType + " " + targetId);
        } else {
            logger.warn("Cannot add relationship - one or both elements not in context: " + 
                       sourceId + " " + relationshipType + " " + targetId);
        }
    }
    
    /**
     * Set importance score for an element (used for prioritizing elements in AI-based finding)
     * 
     * @param elementId Element ID
     * @param score Importance score (0.0 to 1.0)
     */
    public void setElementImportanceScore(String elementId, double score) {
        if (score < 0.0 || score > 1.0) {
            throw new IllegalArgumentException("Importance score must be between 0.0 and 1.0");
        }
        
        elementImportanceScores.put(elementId, score);
    }
    
    /**
     * Get element importance score
     * 
     * @param elementId Element ID
     * @return Importance score (0.0 if not set)
     */
    public double getElementImportanceScore(String elementId) {
        return elementImportanceScores.getOrDefault(elementId, 0.0);
    }
    
    /**
     * Add a navigation step to the history
     * 
     * @param pageIdentifier A string identifying the page (URL, title, etc.)
     */
    public void addNavigationStep(String pageIdentifier) {
        navigationPath.add(pageIdentifier);
    }
    
    /**
     * Set a metadata value
     * 
     * @param key Metadata key
     * @param value Metadata value
     */
    public void setMetadata(String key, Object value) {
        metadata.put(key, value);
    }
    
    /**
     * Get a metadata value
     * 
     * @param key Metadata key
     * @return Metadata value or null if not found
     */
    public Object getMetadata(String key) {
        return metadata.get(key);
    }
    
    /**
     * Find the most likely element matching a description
     * 
     * @param description Text description of the element to find
     * @param similarityThreshold Minimum similarity threshold (0.0 to 1.0)
     * @return The element ID of the best match, or null if none found
     */
    public String findMostLikelyElement(String description, double similarityThreshold) {
        String bestMatchId = null;
        double bestScore = similarityThreshold;
        
        for (Map.Entry<String, ElementInfo> entry : elementInfoMap.entrySet()) {
            String elementId = entry.getKey();
            ElementInfo info = entry.getValue();
            
            // Skip invisible elements
            if (!visibleElementIds.contains(elementId)) {
                continue;
            }
            
            // Calculate similarity between descriptions
            double descriptionSimilarity = calculateTextSimilarity(description, info.getDescription());
            
            // Include text content in similarity if available
            double textSimilarity = 0.0;
            if (textContentMap.containsKey(elementId)) {
                textSimilarity = calculateTextSimilarity(description, textContentMap.get(elementId));
            }
            
            // Include importance score in calculation
            double importanceMultiplier = 1.0 + (getElementImportanceScore(elementId) * 0.5);
            
            // Combined score (description similarity is weighted higher)
            double score = ((descriptionSimilarity * 0.7) + (textSimilarity * 0.3)) * importanceMultiplier;
            
            if (score > bestScore) {
                bestScore = score;
                bestMatchId = elementId;
            }
        }
        
        return bestMatchId;
    }
    
    /**
     * Calculate similarity between two text strings
     * Simple implementation - in production, this would use more sophisticated NLP techniques
     * 
     * @param text1 First text
     * @param text2 Second text
     * @return Similarity score between 0.0 and 1.0
     */
    private double calculateTextSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0.0;
        }
        
        // Convert to lowercase and tokenize
        Set<String> tokens1 = tokenize(text1.toLowerCase());
        Set<String> tokens2 = tokenize(text2.toLowerCase());
        
        // Calculate Jaccard similarity
        Set<String> union = new HashSet<>(tokens1);
        union.addAll(tokens2);
        
        Set<String> intersection = new HashSet<>(tokens1);
        intersection.retainAll(tokens2);
        
        if (union.isEmpty()) {
            return 0.0;
        }
        
        return (double) intersection.size() / union.size();
    }
    
    /**
     * Simple tokenization of text into words
     */
    private Set<String> tokenize(String text) {
        return Arrays.stream(text.split("\\W+"))
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toSet());
    }
    
    /**
     * Get elements that are visually near another element
     * 
     * @param elementId Source element ID
     * @return List of nearby element IDs
     */
    public List<String> getNearbyElements(String elementId) {
        if (!elementInfoMap.containsKey(elementId)) {
            return Collections.emptyList();
        }
        
        return relationships.stream()
                .filter(r -> r.getSourceId().equals(elementId) && 
                       (r.getRelationshipType().equals("isNextTo") || 
                        r.getRelationshipType().equals("isNear")))
                .map(ElementRelationship::getTargetId)
                .collect(Collectors.toList());
    }
    
    /**
     * Get all child elements
     * 
     * @param elementId Parent element ID
     * @return List of child element IDs
     */
    public List<String> getChildElements(String elementId) {
        return relationships.stream()
                .filter(r -> r.getSourceId().equals(elementId) && 
                       r.getRelationshipType().equals("contains"))
                .map(ElementRelationship::getTargetId)
                .collect(Collectors.toList());
    }
    
    /**
     * Get all visible elements
     * 
     * @return Map of visible element IDs to their ElementInfo
     */
    public Map<String, ElementInfo> getVisibleElements() {
        return visibleElementIds.stream()
                .filter(elementInfoMap::containsKey)
                .collect(Collectors.toMap(
                    id -> id,
                    elementInfoMap::get
                ));
    }
    
    /**
     * Get the age of this context in milliseconds
     */
    public long getAgeMillis() {
        return System.currentTimeMillis() - creationTimestamp;
    }
    
    /**
     * Check if this context is stale (older than the specified threshold)
     * 
     * @param thresholdMillis Threshold in milliseconds
     * @return true if context is stale
     */
    public boolean isStale(long thresholdMillis) {
        return getAgeMillis() > thresholdMillis;
    }
    
    /**
     * Get URL
     */
    public String getUrl() {
        return url;
    }
    
    /**
     * Get title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Get current viewport
     */
    public String getCurrentViewport() {
        return currentViewport;
    }
    
    /**
     * Get navigation path
     */
    public List<String> getNavigationPath() {
        return new ArrayList<>(navigationPath);
    }
    
    /**
     * Create a summary of this context
     */
    public String createSummary() {
        StringBuilder summary = new StringBuilder();
        summary.append("Page Context Summary:\n");
        summary.append("URL: ").append(url).append("\n");
        summary.append("Title: ").append(title).append("\n");
        summary.append("Viewport: ").append(currentViewport).append("\n");
        summary.append("Total Elements: ").append(elementInfoMap.size()).append("\n");
        summary.append("Visible Elements: ").append(visibleElementIds.size()).append("\n");
        
        // Include most important elements
        summary.append("Key Elements:\n");
        elementImportanceScores.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(5)
            .forEach(entry -> {
                String elementId = entry.getKey();
                if (elementInfoMap.containsKey(elementId)) {
                    ElementInfo info = elementInfoMap.get(elementId);
                    summary.append("  - ").append(info.getDescription())
                           .append(" (Score: ").append(String.format("%.2f", entry.getValue()))
                           .append(")\n");
                }
            });
        
        return summary.toString();
    }
    
    /**
     * Inner class representing information about a WebElement
     */
    public static class ElementInfo {
        private final String elementId;
        private final String elementType;
        private final String description;
        private final Map<String, String> attributes;
        
        public ElementInfo(String elementId, WebElement element, String description) {
            this.elementId = elementId;
            this.elementType = element.getTagName();
            this.description = description;
            this.attributes = extractAttributes(element);
        }
        
        private Map<String, String> extractAttributes(WebElement element) {
            Map<String, String> attributeMap = new HashMap<>();
            
            // Common attributes to extract
            String[] commonAttributes = {
                "id", "class", "name", "type", "value", "href", "src", "alt", 
                "title", "placeholder", "aria-label", "role", "data-testid"
            };
            
            for (String attr : commonAttributes) {
                String value = element.getAttribute(attr);
                if (value != null && !value.isEmpty()) {
                    attributeMap.put(attr, value);
                }
            }
            
            return attributeMap;
        }
        
        public String getElementId() {
            return elementId;
        }
        
        public String getElementType() {
            return elementType;
        }
        
        public String getDescription() {
            return description;
        }
        
        public Map<String, String> getAttributes() {
            return attributes;
        }
        
        public String getAttribute(String name) {
            return attributes.get(name);
        }
        
        @Override
        public String toString() {
            return "ElementInfo{" +
                   "elementId='" + elementId + '\'' +
                   ", elementType='" + elementType + '\'' +
                   ", description='" + description + '\'' +
                   '}';
        }
    }
    
    /**
     * Inner class representing a relationship between elements
     */
    public static class ElementRelationship {
        private final String sourceId;
        private final String targetId;
        private final String relationshipType;
        
        public ElementRelationship(String sourceId, String targetId, String relationshipType) {
            this.sourceId = sourceId;
            this.targetId = targetId;
            this.relationshipType = relationshipType;
        }
        
        public String getSourceId() {
            return sourceId;
        }
        
        public String getTargetId() {
            return targetId;
        }
        
        public String getRelationshipType() {
            return relationshipType;
        }
        
        @Override
        public String toString() {
            return "ElementRelationship{" +
                   "sourceId='" + sourceId + '\'' +
                   ", targetId='" + targetId + '\'' +
                   ", relationshipType='" + relationshipType + '\'' +
                   '}';
        }
    }
}


package com.cloudsmart.framework.ai;

import com.cloudsmart.framework.elements.CSSmartDriver;
import com.cloudsmart.framework.logger.CSLogger;
import com.cloudsmart.framework.utils.Configuration;
import org.openqa.selenium.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Analyzes the context of the current page to help with intelligent element finding
 * and understanding the semantic structure of the page.
 */
public class CSSmartAIContextAnalyzer {
    private static final CSLogger logger = CSLogger.getInstance();
    private final CSSmartDriver driver;
    
    // Cache the page context to avoid repeated analysis of the same page
    private PageContext currentPageContext;
    private String currentUrl;
    private long pageContextTimestamp;
    
    // Configuration
    private final int maxElementsToAnalyze;
    private final long contextCacheExpiryMillis;
    private final double minElementSimilarityThreshold;
    
    // Counter for generating unique element IDs
    private final AtomicInteger elementIdCounter = new AtomicInteger(0);
    
    /**
     * Constructor for CSSmartAIContextAnalyzer
     * 
     * @param driver The CSSmartDriver instance
     */
    public CSSmartAIContextAnalyzer(CSSmartDriver driver) {
        this.driver = driver;
        
        // Load configuration
        this.maxElementsToAnalyze = Configuration.getInt("ai.context.maxElements", 100);
        this.contextCacheExpiryMillis = Configuration.getLong("ai.context.cacheExpiryMillis", 5000);
        this.minElementSimilarityThreshold = Configuration.getDouble("ai.context.similarityThreshold", 0.6);
        
        logger.debug("Initialized CSSmartAIContextAnalyzer with maxElements=" + maxElementsToAnalyze +
                   ", cacheExpiry=" + contextCacheExpiryMillis + "ms, similarityThreshold=" + minElementSimilarityThreshold);
    }
    
    /**
     * Analyze the current page context and return a string representation
     * 
     * @return A string describing the current page context
     */
    public String analyzeCurrentPageContext() {
        PageContext context = getOrCreatePageContext();
        return context.createSummary();
    }
    
    /**
     * Get the current page context object, creating it if necessary
     * 
     * @return The current PageContext
     */
    public PageContext getOrCreatePageContext() {
        String url = driver.getCurrentUrl();
        long currentTime = System.currentTimeMillis();
        
        // Check if we need to create a new context
        if (currentPageContext == null || 
            !url.equals(currentUrl) || 
            currentTime - pageContextTimestamp > contextCacheExpiryMillis) {
            
            logger.info("Creating new page context for URL: " + url);
            currentPageContext = createPageContext();
            currentUrl = url;
            pageContextTimestamp = currentTime;
        }
        
        return currentPageContext;
    }
    
    /**
     * Create a new PageContext for the current page
     * 
     * @return The new PageContext
     */
    private PageContext createPageContext() {
        String url = driver.getCurrentUrl();
        String title = driver.getTitle();
        
        // Create new context
        PageContext context = new PageContext(driver, url, title);
        
        // Extract page metadata
        extractPageMetadata(context);
        
        // Analyze page elements
        analyzePageElements(context);
        
        // Analyze visual relationships
        analyzeElementRelationships(context);
        
        // Calculate importance scores
        calculateElementImportanceScores(context);
        
        logger.debug("Created page context with " + context.getVisibleElements().size() + " visible elements");
        
        return context;
    }
    
    /**
     * Extract metadata about the current page
     * 
     * @param context The PageContext to update
     */
    private void extractPageMetadata(PageContext context) {
        try {
            // Get page load time
            Long loadTime = (Long) driver.executeScript(
                "return performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart;"
            );
            context.setMetadata("pageLoadTime", loadTime);
            
            // Get page size
            Long pageHeight = (Long) driver.executeScript("return document.body.scrollHeight;");
            Long pageWidth = (Long) driver.executeScript("return document.body.scrollWidth;");
            context.setMetadata("pageHeight", pageHeight);
            context.setMetadata("pageWidth", pageWidth);
            
            // Detect key frameworks/libraries
            context.setMetadata("hasJQuery", detectJQuery());
            context.setMetadata("hasReact", detectReact());
            context.setMetadata("hasAngular", detectAngular());
            
            // Get document language
            String language = (String) driver.executeScript(
                "return document.documentElement.lang || navigator.language;"
            );
            context.setMetadata("language", language);
            
            logger.debug("Extracted page metadata: loadTime=" + loadTime + "ms, size=" + pageWidth + "x" + pageHeight);
        } catch (Exception e) {
            logger.warn("Failed to extract complete page metadata", e);
        }
    }
    
    /**
     * Detect if jQuery is present
     */
    private boolean detectJQuery() {
        return (Boolean) driver.executeScript("return typeof jQuery !== 'undefined';");
    }
    
    /**
     * Detect if React is present
     */
    private boolean detectReact() {
        return (Boolean) driver.executeScript(
            "return !!(window.__REACT_DEVTOOLS_GLOBAL_HOOK__ || " +
            "document.querySelector('[data-reactroot], [data-reactid]'));"
        );
    }
    
    /**
     * Detect if Angular is present
     */
    private boolean detectAngular() {
        return (Boolean) driver.executeScript(
            "return !!(window.angular || document.querySelector('[ng-app], [ng-controller], [ng-model]'));"
        );
    }
    
    /**
     * Analyze the elements on the page
     * 
     * @param context The PageContext to update
     */
    private void analyzePageElements(PageContext context) {
        try {
            // Find interactive elements
            findAndAnalyzeElements(context, "button, a, input, select, textarea", "interactive");
            
            // Find content elements
            findAndAnalyzeElements(context, "h1, h2, h3, p, label, span, div:not(:empty)", "content");
            
            // Find navigation elements
            findAndAnalyzeElements(context, "nav, menu, ul, ol, .navbar, .navigation, header", "navigation");
            
            // Find form elements
            findAndAnalyzeElements(context, "form, fieldset, .form", "form");
            
        } catch (Exception e) {
            logger.warn("Error analyzing page elements", e);
        }
    }
    
    /**
     * Find and analyze elements matching a CSS selector
     * 
     * @param context The PageContext to update
     * @param selector CSS selector to find elements
     * @param category Element category
     */
    private void findAndAnalyzeElements(PageContext context, String selector, String category) {
        try {
            List<WebElement> elements = driver.findElements(By.cssSelector(selector));
            
            // Limit the number of elements to avoid performance issues
            if (elements.size() > maxElementsToAnalyze) {
                logger.debug("Limiting " + category + " elements from " + elements.size() + " to " + maxElementsToAnalyze);
                elements = elements.subList(0, maxElementsToAnalyze);
            }
            
            for (WebElement element : elements) {
                try {
                    // Check if element is visible
                    boolean isVisible = isElementVisible(element);
                    
                    // Generate element description
                    String description = generateElementDescription(element, category);
                    
                    // Add to context
                    String elementId = "elem-" + elementIdCounter.incrementAndGet();
                    context.addElement(elementId, element, description, isVisible);
                    
                } catch (StaleElementReferenceException e) {
                    // Skip stale elements
                }
            }
            
        } catch (Exception e) {
            logger.warn("Error finding elements with selector: " + selector, e);
        }
    }
    
    /**
     * Check if an element is visible
     * 
     * @param element The WebElement to check
     * @return true if element is visible
     */
    private boolean isElementVisible(WebElement element) {
        try {
            return element.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Generate a description for an element
     * 
     * @param element The WebElement
     * @param category Element category
     * @return A human-readable description
     */
    private String generateElementDescription(WebElement element, String category) {
        StringBuilder description = new StringBuilder();
        
        // Start with element type
        String tagName = element.getTagName();
        description.append(tagName);
        
        // Add ID if available
        String id = element.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            description.append(" with id '").append(id).append("'");
        }
        
        // Add classes if available
        String classNames = element.getAttribute("class");
        if (classNames != null && !classNames.isEmpty()) {
            description.append(" with class '").append(classNames).append("'");
        }
        
        // Add text content if available
        String text = element.getText();
        if (text != null && !text.isEmpty() && text.length() < 50) {
            description.append(" containing text '").append(text).append("'");
        }
        
        // Add specific attributes based on element type
        if (tagName.equals("input")) {
            String type = element.getAttribute("type");
            String name = element.getAttribute("name");
            String placeholder = element.getAttribute("placeholder");
            
            if (type != null && !type.isEmpty()) {
                description.append(", type ").append(type);
            }
            
            if (name != null && !name.isEmpty()) {
                description.append(", name '").append(name).append("'");
            }
            
            if (placeholder != null && !placeholder.isEmpty()) {
                description.append(", placeholder '").append(placeholder).append("'");
            }
        } else if (tagName.equals("a")) {
            String href = element.getAttribute("href");
            if (href != null && !href.isEmpty()) {
                description.append(", href '").append(href).append("'");
            }
        } else if (tagName.equals("button")) {
            String type = element.getAttribute("type");
            if (type != null && !type.isEmpty()) {
                description.append(", type ").append(type);
            }
        }
        
        // Add accessibility information
        String ariaLabel = element.getAttribute("aria-label");
        String title = element.getAttribute("title");
        
        if (ariaLabel != null && !ariaLabel.isEmpty()) {
            description.append(", aria-label '").append(ariaLabel).append("'");
        }
        
        if (title != null && !title.isEmpty()) {
            description.append(", title '").append(title).append("'");
        }
        
        // Add category
        description.append(" (").append(category).append(")");
        
        return description.toString();
    }
    
    /**
     * Analyze relationships between elements
     * 
     * @param context The PageContext to update
     */
    private void analyzeElementRelationships(PageContext context) {
        try {
            // Get all visible elements
            Map<String, PageContext.ElementInfo> visibleElements = context.getVisibleElements();
            
            // Filter to a reasonable number for performance
            List<String> elementIds = new ArrayList<>(visibleElements.keySet());
            if (elementIds.size() > maxElementsToAnalyze) {
                elementIds = elementIds.subList(0, maxElementsToAnalyze);
            }
            
            // Calculate containment relationships using JavaScript
            analyzeContainmentRelationships(context, elementIds);
            
            // Calculate spatial relationships (which elements are next to each other)
            analyzeSpatialRelationships(context, elementIds);
            
        } catch (Exception e) {
            logger.warn("Error analyzing element relationships", e);
        }
    }
    
    /**
     * Analyze which elements contain other elements
     * 
     * @param context The PageContext to update
     * @param elementIds List of element IDs to analyze
     */
    private void analyzeContainmentRelationships(PageContext context, List<String> elementIds) {
        try {
            // Prepare JavaScript to get all elements
            StringBuilder script = new StringBuilder();
            script.append("var elements = {}; ");
            
            for (String elementId : elementIds) {
                script.append("elements['").append(elementId).append("'] = arguments[").append(elementIds.indexOf(elementId)).append("]; ");
            }
            
            script.append("var results = []; ");
            script.append("for (var parentId in elements) { ");
            script.append("  var parent = elements[parentId]; ");
            script.append("  for (var childId in elements) { ");
            script.append("    if (parentId !== childId) { ");
            script.append("      var child = elements[childId]; ");
            script.append("      if (parent.contains(child)) { ");
            script.append("        results.push({parent: parentId, child: childId}); ");
            script.append("      } ");
            script.append("    } ");
            script.append("  } ");
            script.append("} ");
            script.append("return results; ");
            
            // Execute script to find containment relationships
            List<WebElement> elementsList = elementIds.stream()
                .map(id -> (WebElement) context.getVisibleElements().get(id))
                .collect(Collectors.toList());
            
            List<Map<String, String>> results = (List<Map<String, String>>) driver.executeScript(script.toString(), elementsList.toArray());
            
            // Add relationships to context
            for (Map<String, String> pair : results) {
                String parentId = pair.get("parent");
                String childId = pair.get("child");
                context.addRelationship(parentId, childId, "contains");
            }
            
        } catch (Exception e) {
            logger.warn("Error analyzing containment relationships", e);
        }
    }
    
    /**
     * Analyze which elements are spatially related (next to each other)
     * 
     * @param context The PageContext to update
     * @param elementIds List of element IDs to analyze
     */
    private void analyzeSpatialRelationships(PageContext context, List<String> elementIds) {
        try {
            // Prepare JavaScript to calculate distances between elements
            StringBuilder script = new StringBuilder();
            script.append("var elements = {}; ");
            
            for (String elementId : elementIds) {
                script.append("elements['").append(elementId).append("'] = arguments[").append(elementIds.indexOf(elementId)).append("]; ");
            }
            
            script.append("var results = []; ");
            script.append("for (var id1 in elements) { ");
            script.append("  var el1 = elements[id1]; ");
            script.append("  var rect1 = el1.getBoundingClientRect(); ");
            script.append("  for (var id2 in elements) { ");
            script.append("    if (id1 !== id2) { ");
            script.append("      var el2 = elements[id2]; ");
            script.append("      var rect2 = el2.getBoundingClientRect(); ");
            script.append("      var horizontalDistance = Math.min( ");
            script.append("        Math.abs(rect1.right - rect2.left), ");
            script.append("        Math.abs(rect1.left - rect2.right) ");
            script.append("      ); ");
            script.append("      var verticalDistance = Math.min( ");
            script.append("        Math.abs(rect1.bottom - rect2.top), ");
            script.append("        Math.abs(rect1.top - rect2.bottom) ");
            script.append("      ); ");
            script.append("      var distance = Math.sqrt(horizontalDistance*horizontalDistance + verticalDistance*verticalDistance); ");
            script.append("      results.push({from: id1, to: id2, distance: distance}); ");
            script.append("    } ");
            script.append("  } ");
            script.append("} ");
            script.append("return results; ");
            
            // Execute script to find spatial relationships
            List<WebElement> elementsList = elementIds.stream()
                .map(id -> (WebElement) context.getVisibleElements().get(id))
                .collect(Collectors.toList());
            
            List<Map<String, Object>> results = (List<Map<String, Object>>) driver.executeScript(script.toString(), elementsList.toArray());
            
            // Add closest relationships to context
            Map<String, List<Map<String, Object>>> resultsByElement = new HashMap<>();
            
            // Group results by source element
            for (Map<String, Object> result : results) {
                String fromId = (String) result.get("from");
                resultsByElement.computeIfAbsent(fromId, k -> new ArrayList<>()).add(result);
            }
            
            // For each element, add its closest neighbors as relationships
            for (String elementId : resultsByElement.keySet()) {
                List<Map<String, Object>> distances = resultsByElement.get(elementId);
                
                // Sort by distance
                distances.sort(Comparator.comparing(m -> ((Number) m.get("distance")).doubleValue()));
                
                // Add closest 3 as "isNextTo" relationships
                int neighborsToAdd = Math.min(3, distances.size());
                for (int i = 0; i < neighborsToAdd; i++) {
                    Map<String, Object> relation = distances.get(i);
                    String toId = (String) relation.get("to");
                    double distance = ((Number) relation.get("distance")).doubleValue();
                    
                    // Only add relationships for elements that are reasonably close
                    if (distance < 50) {
                        context.addRelationship(elementId, toId, "isNextTo");
                    } else if (distance < 200) {
                        context.addRelationship(elementId, toId, "isNear");
                    }
                }
            }
            
        } catch (Exception e) {
            logger.warn("Error analyzing spatial relationships", e);
        }
    }
    
    /**
     * Calculate importance scores for elements
     * 
     * @param context The PageContext to update
     */
    private void calculateElementImportanceScores(PageContext context) {
        try {
            Map<String, PageContext.ElementInfo> visibleElements = context.getVisibleElements();
            
            for (Map.Entry<String, PageContext.ElementInfo> entry : visibleElements.entrySet()) {
                String elementId = entry.getKey();
                PageContext.ElementInfo info = entry.getValue();
                
                double score = 0.5; // Base score
                
                // Adjust score based on various factors
                
                // Element type importance
                String elementType = info.getElementType();
                switch (elementType) {
                    case "button":
                    case "a":
                    case "input":
                        score += 0.2; // Interactive elements are important
                        break;
                    case "h1":
                        score += 0.3; // Main headings are important
                        break;
                    case "h2":
                    case "h3":
                        score += 0.2; // Secondary headings
                        break;
                    case "label":
                    case "p":
                        score += 0.1; // Content elements
                        break;
                }
                
                // Adjust based on attributes
                Map<String, String> attributes = info.getAttributes();
                
                if (attributes.containsKey("id")) {
                    score += 0.1; // Elements with IDs are more likely to be important
                }
                
                if (attributes.containsKey("role")) {
                    score += 0.1; // Elements with ARIA roles are important
                }
                
                // Check for important class names
                String classNames = attributes.getOrDefault("class", "");
                if (classNames.contains("btn") || 
                    classNames.contains("button") || 
                    classNames.contains("nav") || 
                    classNames.contains("menu") ||
                    classNames.contains("primary")) {
                    score += 0.1;
                }
                
                // Normalize score to 0.0-1.0 range
                score = Math.min(1.0, Math.max(0.0, score));
                
                // Set the importance score
                context.setElementImportanceScore(elementId, score);
            }
            
        } catch (Exception e) {
            logger.warn("Error calculating element importance scores", e);
        }
    }
    
    /**
     * Find the most likely element matching a description
     * 
     * @param description Text description of the element to find
     * @return The WebElement if found, or null if not found
     */
    public WebElement findElementByDescription(String description) {
        PageContext context = getOrCreatePageContext();
        
        String elementId = context.findMostLikelyElement(description, minElementSimilarityThreshold);
        if (elementId != null) {
            PageContext.ElementInfo info = context.getVisibleElements().get(elementId);
            if (info != null) {
                try {
                    // Find element using available attributes
                    Map<String, String> attributes = info.getAttributes();
                    
                    // Try to find by ID first (most reliable)
                    if (attributes.containsKey("id")) {
                        try {
                            return driver.findElement(By.id(attributes.get("id")));
                        } catch (Exception e) {
                            // Fall through to other methods
                        }
                    }
                    
                    // Try xpath with multiple attributes for better precision
                    StringBuilder xpath = new StringBuilder("//");
                    xpath.append(info.getElementType());
                    
                    boolean hasAttr = false;
                    
                    // Add attribute conditions
                    for (Map.Entry<String, String> attr : attributes.entrySet()) {
                        String name = attr.getKey();
                        String value = attr.getValue();
                        
                        // Skip complex attributes that might cause XPath issues
                        if (name.equals("class") || value.contains("'") || value.contains("\"")) {
                            continue;
                        }
                        
                        if (!hasAttr) {
                            xpath.append("[");
                            hasAttr = true;
                        } else {
                            xpath.append(" and ");
                        }
                        
                        xpath.append("@").append(name).append("='").append(value).append("'");
                    }
                    
                    if (hasAttr) {
                        xpath.append("]");
                    }
                    
                    try {
                        return driver.findElement(By.xpath(xpath.toString()));
                    } catch (Exception e) {
                        // Try one more fallback
                        logger.debug("Failed to find element by attributes, trying text content");
                        
                        // Try to find by text content
                        String text = attributes.getOrDefault("text", "");
                        if (text != null && !text.isEmpty()) {
                            try {
                                return driver.findElement(By.xpath("//*[contains(text(),'" + text + "')]"));
                            } catch (Exception ex) {
                                // Unable to find element
                            }
                        }
                    }
                } catch (Exception e) {
                    logger.warn("Error reconstructing element from context", e);
                }
            }
        }
        
        return null;
    }
    
    /**
     * Generate a By locator for an element
     * 
     * @param element The WebElement
     * @return A By locator that can be used to find this element again
     */
    public By generateLocatorFromElement(WebElement element) {
        try {
            // Try ID first (most reliable)
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                return By.id(id);
            }
            
            // Try name
            String name = element.getAttribute("name");
            if (name != null && !name.isEmpty()) {
                return By.name(name);
            }
            
            // Try CSS selector with multiple attributes
            Map<String, String> attributes = extractKeyAttributes(element);
            
            if (!attributes.isEmpty()) {
                StringBuilder cssSelector = new StringBuilder(element.getTagName());
                
                // Add attributes to selector
                for (Map.Entry<String, String> entry : attributes.entrySet()) {
                    String attrName = entry.getKey();
                    String attrValue = entry.getValue();
                    
                    // For class, split and use individual classes
                    if (attrName.equals("class")) {
                        String[] classes = attrValue.split("\\s+");
                        for (String className : classes) {
                            if (!className.isEmpty()) {
                                cssSelector.append(".").append(className);
                            }
                        }
                    } else {
                        // For other attributes, add as [attr='value']
                        cssSelector.append("[").append(attrName).append("='").append(attrValue).append("']");
                    }
                }
                
                return By.cssSelector(cssSelector.toString());
            }
            
            // As a last resort, use XPath with text content
            String text = element.getText();
            if (text != null && !text.isEmpty()) {
                // Escape single quotes in text
                text = text.replace("'", "\\'");
                return By.xpath("//" + element.getTagName() + "[contains(text(),'" + text + "')]");
            }
            
            // If all else fails, return null
            return null;
        } catch (Exception e) {
            logger.warn("Error generating locator from element", e);
            return null;
        }
    }
    
    /**
     * Extract key attributes from an element
     * 
     * @param element The WebElement
     * @return Map of attribute names to values
     */
    private Map<String, String> extractKeyAttributes(WebElement element) {
        Map<String, String> attributes = new HashMap<>();
        
        // List of attributes to consider
        String[] attributesToCheck = {
            "id", "class", "name", "type", "value", "placeholder", 
            "aria-label", "data-test", "data-testid", "role"
        };
        
        for (String attr : attributesToCheck) {
            String value = element.getAttribute(attr);
            if (value != null && !value.isEmpty()) {
                attributes.put(attr, value);
            }
        }
        
        return attributes;
    }
    
    /**
     * Clear the current page context cache
     */
    public void clearContextCache() {
        currentPageContext = null;
        currentUrl = null;
        pageContextTimestamp = 0;
        logger.debug("Page context cache cleared");
    }
    
    /**
     * Get a list of elements similar to a description
     * 
     * @param description Text description to match
     * @param minSimilarity Minimum similarity threshold (0.0 to 1.0)
     * @param maxResults Maximum number of results to return
     * @return Map of element IDs to similarity scores
     */
    public Map<String, Double> findSimilarElements(String description, double minSimilarity, int maxResults) {
        PageContext context = getOrCreatePageContext();
        Map<String, Double> results = new ConcurrentHashMap<>();
        
        Map<String, PageContext.ElementInfo> visibleElements = context.getVisibleElements();
        
        // Calculate similarity for each element
        for (Map.Entry<String, PageContext.ElementInfo> entry : visibleElements.entrySet()) {
            String elementId = entry.getKey();
            PageContext.ElementInfo info = entry.getValue();
            
            // Calculate similarity between descriptions
            double similarity = calculateTextSimilarity(description, info.getDescription());
            
            // Only include elements with similarity above threshold
            if (similarity >= minSimilarity) {
                results.put(elementId, similarity);
            }
        }
        
        // Sort by similarity (descending) and limit results
        return results.entrySet().stream()
                .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                .limit(maxResults)
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    Map.Entry::getValue,
                    (e1, e2) -> e1,
                    LinkedHashMap::new
                ));
    }
    
    /**
     * Calculate similarity between two text strings
     * Simple implementation - in production, this would use more sophisticated NLP techniques
     * 
     * @param text1 First text
     * @param text2 Second text
     * @return Similarity score between 0.0 and 1.0
     */
    private double calculateTextSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0.0;
        }
        
        // Convert to lowercase and tokenize
        Set<String> tokens1 = tokenize(text1.toLowerCase());
        Set<String> tokens2 = tokenize(text2.toLowerCase());
        
        // Calculate Jaccard similarity
        Set<String> union = new HashSet<>(tokens1);
        union.addAll(tokens2);
        
        Set<String> intersection = new HashSet<>(tokens1);
        intersection.retainAll(tokens2);
        
        if (union.isEmpty()) {
            return 0.0;
        }
        
        return (double) intersection.size() / union.size();
    }
    
    /**
     * Simple tokenization of text into words
     */
    private Set<String> tokenize(String text) {
        return Arrays.stream(text.split("\\W+"))
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toSet());
    }
    
    /**
     * Find elements near another element
     * 
     * @param element The source element
     * @param maxDistance Maximum distance in pixels
     * @return List of nearby WebElements
     */
    public List<WebElement> findNearbyElements(WebElement element, int maxDistance) {
        List<WebElement> results = new ArrayList<>();
        
        try {
            // Create a script to find elements within the specified distance
            String script = 
                "var sourceElement = arguments[0];" +
                "var maxDistance = arguments[1];" +
                "var elements = document.querySelectorAll('*');" +
                "var results = [];" +
                
                "var sourceRect = sourceElement.getBoundingClientRect();" +
                "var sourceCenter = {" +
                "  x: sourceRect.left + sourceRect.width/2," +
                "  y: sourceRect.top + sourceRect.height/2" +
                "};" +
                
                "for (var i = 0; i < elements.length; i++) {" +
                "  var el = elements[i];" +
                "  if (el === sourceElement) continue;" +
                "  var rect = el.getBoundingClientRect();" +
                "  if (rect.width === 0 || rect.height === 0) continue;" +
                
                "  var center = {" +
                "    x: rect.left + rect.width/2," +
                "    y: rect.top + rect.height/2" +
                "  };" +
                
                "  var distance = Math.sqrt(" +
                "    Math.pow(center.x - sourceCenter.x, 2) +" +
                "    Math.pow(center.y - sourceCenter.y, 2)" +
                "  );" +
                
                "  if (distance <= maxDistance) {" +
                "    results.push(el);" +
                "  }" +
                "}" +
                
                "return results;";
            
            // Execute the script and get nearby elements
            List<WebElement> nearbyElements = (List<WebElement>) driver.executeScript(script, element, maxDistance);
            
            // Add the results
            results.addAll(nearbyElements);
            
        } catch (Exception e) {
            logger.warn("Error finding nearby elements", e);
        }
        
        return results;
    }
}


package com.cloudsmart.framework.ai;

import com.cloudsmart.framework.elements.CSSmartDriver;
import com.cloudsmart.framework.logger.CSLogger;
import com.cloudsmart.framework.utils.Configuration;
import org.openqa.selenium.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Advanced element finder that uses AI-like techniques to locate elements
 * based on natural language descriptions, even when traditional locators fail.
 */
public class CSSmartAIElementFinder {
    private static final CSLogger logger = CSLogger.getInstance();
    private final CSSmartDriver driver;
    
    // Context analyzer for page understanding
    private final CSSmartAIContextAnalyzer contextAnalyzer;
    
    // Cache of successful element findings
    private final Map<String, List<By>> successfulLocators;
    
    // Configuration
    private final double minSimilarityThreshold;
    private final int maxElementsToAnalyze;
    private final boolean useVisualSearch;
    
    /**
     * Constructor for CSSmartAIElementFinder
     * 
     * @param driver The CSSmartDriver instance
     */
    public CSSmartAIElementFinder(CSSmartDriver driver) {
        this.driver = driver;
        this.contextAnalyzer = new CSSmartAIContextAnalyzer(driver);
        this.successfulLocators = new ConcurrentHashMap<>();
        
        // Load configuration
        this.minSimilarityThreshold = Configuration.getDouble("ai.finder.similarityThreshold", 0.6);
        this.maxElementsToAnalyze = Configuration.getInt("ai.finder.maxElements", 100);
        this.useVisualSearch = Configuration.getBoolean("ai.finder.useVisualSearch", true);
        
        logger.debug("Initialized CSSmartAIElementFinder with similarityThreshold=" + minSimilarityThreshold +
                   ", maxElements=" + maxElementsToAnalyze + ", useVisualSearch=" + useVisualSearch);
    }
    
    /**
     * Find an element using a natural language description
     * 
     * @param description Natural language description of the element
     * @return The WebElement if found, or null if not found
     */
    public WebElement findElementByDescription(String description) {
        return findElementByDescription(description, null);
    }
    
    /**
     * Find an element using a natural language description and page context
     * 
     * @param description Natural language description of the element
     * @param pageContext Optional context information about the page (can be null)
     * @return The WebElement if found, or null if not found
     */
    public WebElement findElementByDescription(String description, String pageContext) {
        logger.info("Attempting to find element by description: " + description);
        
        // Try cached locators first if we've successfully found this element before
        if (successfulLocators.containsKey(description)) {
            List<By> locators = successfulLocators.get(description);
            for (By locator : locators) {
                try {
                    WebElement element = driver.findElement(locator);
                    logger.info("Found element using cached locator: " + locator);
                    return element;
                } catch (Exception e) {
                    // Continue to next locator
                }
            }
        }
        
        // Parse description for element type hints
        ElementTypeHint typeHint = parseElementTypeFromDescription(description);
        
        // Try different strategies in order of reliability
        
        // 1. Try exact text match
        WebElement element = findElementByExactText(description, typeHint);
        if (element != null) {
            return element;
        }
        
        // 2. Try partial text match
        element = findElementByPartialText(description, typeHint);
        if (element != null) {
            return element;
        }
        
        // 3. Try by attribute values
        element = findElementByAttributes(description, typeHint);
        if (element != null) {
            return element;
        }
        
        // 4. Try using page context analyzer
        element = contextAnalyzer.findElementByDescription(description);
        if (element != null) {
            return element;
        }
        
        // 5. Try visual search (element position, etc.) if enabled
        if (useVisualSearch) {
            element = findElementByVisualHints(description, pageContext);
            if (element != null) {
                return element;
            }
        }
        
        // 6. Last resort: fuzzy search on innerText of all elements
        element = findElementByFuzzyTextMatch(description, typeHint);
        if (element != null) {
            return element;
        }
        
        logger.warn("Could not find element matching description: " + description);
        return null;
    }
    
    /**
     * Generate a locator from an element
     * 
     * @param element The WebElement
     * @return A By locator that can be used to find this element again
     */
    public By generateLocatorFromElement(WebElement element) {
        return contextAnalyzer.generateLocatorFromElement(element);
    }
    
    /**
     * Parse the description to identify what type of element we're looking for
     * 
     * @param description Natural language description
     * @return ElementTypeHint with information about the element type
     */
    private ElementTypeHint parseElementTypeFromDescription(String description) {
        ElementTypeHint hint = new ElementTypeHint();
        
        // Check for common element type mentions in the description
        description = description.toLowerCase();
        
        // Button detection
        if (description.contains("button") || description.contains("btn") || 
            description.contains("click") || description.contains("submit") ||
            description.contains("ok") || description.contains("cancel")) {
            hint.possibleTags.add("button");
            hint.possibleTags.add("input");
            hint.possibleAttributes.put("type", Arrays.asList("button", "submit", "reset"));
            hint.elementType = "button";
        }
        
        // Input field detection
        else if (description.contains("input") || description.contains("field") || 
                 description.contains("textbox") || description.contains("text box") ||
                 description.contains("enter") || description.contains("type in")) {
            hint.possibleTags.add("input");
            hint.possibleTags.add("textarea");
            hint.possibleAttributes.put("type", Arrays.asList("text", "email", "password", "number", "tel"));
            hint.elementType = "input";
        }
        
        // Link detection
        else if (description.contains("link") || description.contains("hyperlink") || 
                 description.contains("url") || description.contains("href")) {
            hint.possibleTags.add("a");
            hint.elementType = "link";
        }
        
        // Dropdown detection
        else if (description.contains("dropdown") || description.contains("drop down") || 
                 description.contains("select") || description.contains("option") || 
                 description.contains("menu") || description.contains("combobox")) {
            hint.possibleTags.add("select");
            hint.possibleTags.add("ul");
            hint.possibleTags.add("ol");
            hint.elementType = "dropdown";
        }
        
        // Checkbox detection
        else if (description.contains("checkbox") || description.contains("check box") || 
                 description.contains("tick")) {
            hint.possibleTags.add("input");
            hint.possibleAttributes.put("type", Collections.singletonList("checkbox"));
            hint.elementType = "checkbox";
        }
        
        // Radio button detection
        else if (description.contains("radio") || description.contains("option button")) {
            hint.possibleTags.add("input");
            hint.possibleAttributes.put("type", Collections.singletonList("radio"));
            hint.elementType = "radio";
        }
        
        // Image detection
        else if (description.contains("image") || description.contains("img") || 
                 description.contains("picture") || description.contains("photo")) {
            hint.possibleTags.add("img");
            hint.elementType = "image";
        }
        
        // Header detection
        else if (description.contains("header") || description.contains("heading") || 
                 description.contains("title")) {
            hint.possibleTags.add("h1");
            hint.possibleTags.add("h2");
            hint.possibleTags.add("h3");
            hint.possibleTags.add("h4");
            hint.possibleTags.add("h5");
            hint.possibleTags.add("h6");
            hint.elementType = "heading";
        }
        
        // Table detection
        else if (description.contains("table") || description.contains("grid") || 
                 description.contains("column") || description.contains("row")) {
            hint.possibleTags.add("table");
            hint.possibleTags.add("tr");
            hint.possibleTags.add("td");
            hint.possibleTags.add("th");
            hint.elementType = "table";
        }
        
        // If no specific type detected, add common interactive elements
        if (hint.possibleTags.isEmpty()) {
            hint.possibleTags.add("button");
            hint.possibleTags.add("a");
            hint.possibleTags.add("input");
            hint.possibleTags.add("select");
            hint.possibleTags.add("span");
            hint.possibleTags.add("div");
            hint.elementType = "unknown";
        }
        
        return hint;
    }
    
    /**
     * Find an element with exact text matching the description
     * 
     * @param description Element description
     * @param typeHint Element type hint
     * @return WebElement if found, null otherwise
     */
    private WebElement findElementByExactText(String description, ElementTypeHint typeHint) {
        try {
            // Extract key text from description (remove element type references)
            String searchText = extractSearchTextFromDescription(description);
            
            // If we have a clear search text, try to find elements with that exact text
            if (!searchText.isEmpty()) {
                // Create XPath with exact text match for the given element types
                for (String tag : typeHint.possibleTags) {
                    try {
                        String xpath = "//" + tag + "[normalize-space(text())='" + searchText + "']";
                        WebElement element = driver.findElement(By.xpath(xpath));
                        cacheSuccessfulLocator(description, By.xpath(xpath));
                        logger.debug("Found element by exact text: " + xpath);
                        return element;
                    } catch (Exception e) {
                        // Try next tag
                    }
                }
                
                // Try with any element type as a fallback
                try {
                    String xpath = "//*[normalize-space(text())='" + searchText + "']";
                    WebElement element = driver.findElement(By.xpath(xpath));
                    cacheSuccessfulLocator(description, By.xpath(xpath));
                    logger.debug("Found element by exact text with any tag: " + xpath);
                    return element;
                } catch (Exception e) {
                    // Continue to next strategy
                }
            }
        } catch (Exception e) {
            logger.debug("Error finding element by exact text: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Find an element with partial text matching the description
     * 
     * @param description Element description
     * @param typeHint Element type hint
     * @return WebElement if found, null otherwise
     */
    private WebElement findElementByPartialText(String description, ElementTypeHint typeHint) {
        try {
            // Extract key text from description
            String searchText = extractSearchTextFromDescription(description);
            
            if (!searchText.isEmpty()) {
                // Create XPath with contains text match for the given element types
                for (String tag : typeHint.possibleTags) {
                    try {
                        String xpath = "//" + tag + "[contains(text(),'" + searchText + "')]";
                        WebElement element = driver.findElement(By.xpath(xpath));
                        cacheSuccessfulLocator(description, By.xpath(xpath));
                        logger.debug("Found element by partial text: " + xpath);
                        return element;
                    } catch (Exception e) {
                        // Try next tag
                    }
                }
                
                // Try with any element type as a fallback
                try {
                    String xpath = "//*[contains(text(),'" + searchText + "')]";
                    WebElement element = driver.findElement(By.xpath(xpath));
                    cacheSuccessfulLocator(description, By.xpath(xpath));
                    logger.debug("Found element by partial text with any tag: " + xpath);
                    return element;
                } catch (Exception e) {
                    // Continue to next strategy
                }
            }
        } catch (Exception e) {
            logger.debug("Error finding element by partial text: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Find an element by checking attribute values
     * 
     * @param description Element description
     * @param typeHint Element type hint
     * @return WebElement if found, null otherwise
     */
    private WebElement findElementByAttributes(String description, ElementTypeHint typeHint) {
        try {
            // Look for key attributes in the description
            
            // Check for ID in description
            Pattern idPattern = Pattern.compile("id[\\s']*[=:]?[\\s']*['\"]?([\\w-]+)['\"]?", Pattern.CASE_INSENSITIVE);
            Matcher idMatcher = idPattern.matcher(description);
            if (idMatcher.find()) {
                String id = idMatcher.group(1);
                try {
                    WebElement element = driver.findElement(By.id(id));
                    cacheSuccessfulLocator(description, By.id(id));
                    logger.debug("Found element by ID: " + id);
                    return element;
                } catch (Exception e) {
                    // Continue to next strategy
                }
            }
            
            // Check for name in description
            Pattern namePattern = Pattern.compile("name[\\s']*[=:]?[\\s']*['\"]?([\\w-]+)['\"]?", Pattern.CASE_INSENSITIVE);
            Matcher nameMatcher = namePattern.matcher(description);
            if (nameMatcher.find()) {
                String name = nameMatcher.group(1);
                try {
                    WebElement element = driver.findElement(By.name(name));
                    cacheSuccessfulLocator(description, By.name(name));
                    logger.debug("Found element by name: " + name);
                    return element;
                } catch (Exception e) {
                    // Continue to next strategy
                }
            }
            
            // Check for class in description
            Pattern classPattern = Pattern.compile("class[\\s']*[=:]?[\\s']*['\"]?([\\w\\s-]+)['\"]?", Pattern.CASE_INSENSITIVE);
            Matcher classMatcher = classPattern.matcher(description);
            if (classMatcher.find()) {
                String className = classMatcher.group(1).trim();
                try {
                    WebElement element = driver.findElement(By.className(className));
                    cacheSuccessfulLocator(description, By.className(className));
                    logger.debug("Found element by class: " + className);
                    return element;
                } catch (Exception e) {
                    // Continue to next strategy
                }
            }
            
            // Check for placeholder in description
            Pattern placeholderPattern = Pattern.compile("placeholder[\\s']*[=:]?[\\s']*['\"]?([\\w\\s-]+)['\"]?", Pattern.CASE_INSENSITIVE);
            Matcher placeholderMatcher = placeholderPattern.matcher(description);
            if (placeholderMatcher.find()) {
                String placeholder = placeholderMatcher.group(1).trim();
                String xpath = "//input[@placeholder='" + placeholder + "']";
                try {
                    WebElement element = driver.findElement(By.xpath(xpath));
                    cacheSuccessfulLocator(description, By.xpath(xpath));
                    logger.debug("Found element by placeholder: " + placeholder);
                    return element;
                } catch (Exception e) {
                    // Continue to next strategy
                }
            }
            
            // Try CSS attribute selectors that combine tag and attribute for better specificity
            String searchText = extractSearchTextFromDescription(description);
            if (!searchText.isEmpty()) {
                for (String tag : typeHint.possibleTags) {
                    // Try common attributes
                    String[] attributesToTry = {"id", "name", "class", "title", "aria-label", "placeholder"};
                    
                    for (String attr : attributesToTry) {
                        try {
                            String cssSelector = tag + "[" + attr + "*='" + searchText + "']";
                            WebElement element = driver.findElement(By.cssSelector(cssSelector));
                            cacheSuccessfulLocator(description, By.cssSelector(cssSelector));
                            logger.debug("Found element by attribute " + attr + " containing text: " + searchText);
                            return element;
                        } catch (Exception e) {
                            // Try next attribute
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Error finding element by attributes: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Find an element using visual hints (position-based search)
     * 
     * @param description Element description
     * @param pageContext Optional context information
     * @return WebElement if found, null otherwise
     */
    private WebElement findElementByVisualHints(String description, String pageContext) {
        try {
            // Check for positional hints in the description
            boolean hasPositionalHint = false;
            
            // Check for "top", "bottom", "left", "right" hints
            boolean isTop = description.matches("(?i).*(at|on|in)\\s+the?\\s+top.*");
            boolean isBottom = description.matches("(?i).*(at|on|in)\\s+the?\\s+bottom.*");
            boolean isLeft = description.matches("(?i).*(at|on|in)\\s+the?\\s+left.*");
            boolean isRight = description.matches("(?i).*(at|on|in)\\s+the?\\s+right.*");
            
            if (isTop || isBottom || isLeft || isRight) {
                hasPositionalHint = true;
            }
            
            // Check for "next to", "near", "beside", "above", "below" hints
            Pattern nearPattern = Pattern.compile("(?i)(next to|near|beside|above|below|under|over)\\s+(?:the\\s+)?(.+?)(?:\\s+|$)");
            Matcher nearMatcher = nearPattern.matcher(description);
            
            if (nearMatcher.find()) {
                hasPositionalHint = true;
                String relation = nearMatcher.group(1).toLowerCase();
                String targetDescription = nearMatcher.group(2);
                
                // Find the target element first
                WebElement targetElement = findElementByDescription(targetDescription);
                if (targetElement != null) {
                    // Now find elements near this target
                    List<WebElement> nearbyElements = contextAnalyzer.findNearbyElements(targetElement, 150);
                    
                    // Filter by element type if we have a hint
                    ElementTypeHint typeHint = parseElementTypeFromDescription(description);
                    if (!typeHint.possibleTags.isEmpty()) {
                        nearbyElements = nearbyElements.stream()
                            .filter(e -> typeHint.possibleTags.contains(e.getTagName()))
                            .collect(Collectors.toList());
                    }
                    
                    if (!nearbyElements.isEmpty()) {
                        // Return the first match - in a more sophisticated implementation,
                        // we would analyze position relative to the target based on the relation
                        WebElement element = nearbyElements.get(0);
                        By locator = generateLocatorFromElement(element);
                        if (locator != null) {
                            cacheSuccessfulLocator(description, locator);
                        }
                        logger.debug("Found element by proximity to: " + targetDescription);
                        return element;
                    }
                }
            }
            
            // If we have positional hints but couldn't find a reference element,
            // try to search based on absolute position on page
            if (hasPositionalHint) {
                String script = "var elements = document.querySelectorAll('*');" +
                               "var viewportHeight = window.innerHeight;" +
                               "var viewportWidth = window.innerWidth;" +
                               "var matches = [];" +
                               
                               "for (var i = 0; i < elements.length; i++) {" +
                               "  var element = elements[i];" +
                               "  if (!element.getBoundingClientRect) continue;" +
                               "  var rect = element.getBoundingClientRect();" +
                               "  if (rect.width === 0 || rect.height === 0) continue;" +
                               
                               "  var score = 0;" +
                               "  if (" + isTop + " && rect.top < viewportHeight * 0.3) score += 10;" +
                               "  if (" + isBottom + " && rect.bottom > viewportHeight * 0.7) score += 10;" +
                               "  if (" + isLeft + " && rect.left < viewportWidth * 0.3) score += 10;" +
                               "  if (" + isRight + " && rect.right > viewportWidth * 0.7) score += 10;" +
                               
                               "  if (score > 0) {" +
                               "    matches.push({element: element, score: score});" +
                               "  }" +
                               "}" +
                               
                               "matches.sort(function(a, b) { return b.score - a.score; });" +
                               "return matches.length > 0 ? matches[0].element : null;";
                
                WebElement element = (WebElement) driver.executeScript(script);
                if (element != null) {
                    By locator = generateLocatorFromElement(element);
                    if (locator != null) {
                        cacheSuccessfulLocator(description, locator);
                    }
                    logger.debug("Found element by absolute position");
                    return element;
                }
            }
        } catch (Exception e) {
            logger.debug("Error finding element by visual hints: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Find an element using fuzzy text matching (last resort)
     * 
     * @param description Element description
     * @param typeHint Element type hint
     * @return WebElement if found, null otherwise
     */
    private WebElement findElementByFuzzyTextMatch(String description, ElementTypeHint typeHint) {
        try {
            String searchText = extractSearchTextFromDescription(description);
            
            if (!searchText.isEmpty()) {
                // Create a script to find elements with text most similar to the search text
                String script = 
                    "var searchText = arguments[0].toLowerCase();" +
                    "var elements = document.querySelectorAll('*');" +
                    "var bestMatch = null;" +
                    "var bestScore = " + minSimilarityThreshold + ";" +
                    
                    // Simple function to calculate word-level similarity
                    "function similarity(text1, text2) {" +
                    "  text1 = text1.toLowerCase().split(/\\W+/).filter(w => w.length > 0);" +
                    "  text2 = text2.toLowerCase().split(/\\W+/).filter(w => w.length > 0);" +
                    "  var intersection = text1.filter(w => text2.includes(w));" +
                    "  var union = new Set([...text1, ...text2]);" +
                    "  return intersection.length / union.size;" +
                    "}" +
                    
                    // Check all elements
                    "for (var i = 0; i < Math.min(elements.length, " + maxElementsToAnalyze + "); i++) {" +
                    "  var element = elements[i];" +
                    "  if (!element.innerText) continue;" +
                    "  var text = element.innerText;" +
                    "  if (text.length === 0) continue;" +
                    
                    "  var score = similarity(searchText, text);" +
                    "  if (score > bestScore) {" +
                    "    bestScore = score;" +
                    "    bestMatch = element;" +
                    "  }" +
                    "}" +
                    
                    "return bestMatch;";
                
                WebElement element = (WebElement) driver.executeScript(script, searchText);
                if (element != null) {
                    By locator = generateLocatorFromElement(element);
                    if (locator != null) {
                        cacheSuccessfulLocator(description, locator);
                    }
                    logger.debug("Found element by fuzzy text match");
                    return element;
                }
            }
        } catch (Exception e) {
            logger.debug("Error finding element by fuzzy text match: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Extract the main search text from a description by removing element type references
     * 
     * @param description The element description
     * @return Cleaned search text
     */
    private String extractSearchTextFromDescription(String description) {
        // Remove common element type references
        String cleanText = description.replaceAll("(?i)(button|link|input|field|checkbox|dropdown|select|radio|element|image)\\s", "");
        
        // Remove common action words
        cleanText = cleanText.replaceAll("(?i)(click|tap|press|select|choose|enter|type|in|the|with|find)\\s", "");
        
        // Remove "labeled" and similar phrases
        cleanText = cleanText.replaceAll("(?i)(labeled|named|called|marked|identified|as)\\s", "");
        
        // Remove quotes and extra spaces
        cleanText = cleanText.replaceAll("['\"]", "").trim();
        
        return cleanText;
    }
    
    /**
     * Cache a successful locator for future use
     * 
     * @param description The element description
     * @param locator The successful By locator
     */
    private void cacheSuccessfulLocator(String description, By locator) {
        if (locator != null) {
            List<By> locators = successfulLocators.computeIfAbsent(description, k -> new ArrayList<>());
            if (!locators.contains(locator)) {
                locators.add(locator);
                logger.debug("Cached successful locator for '" + description + "': " + locator);
            }
        }
    }
    
    /**
     * Clear the locator cache
     */
    public void clearCache() {
        successfulLocators.clear();
        contextAnalyzer.clearContextCache();
        logger.debug("Element finder cache cleared");
    }
    
    /**
     * Helper class to hold information about element type hints
     */
    private static class ElementTypeHint {
        public Set<String> possibleTags;
        public Map<String, List<String>> possibleAttributes;
        public String elementType;
        
        public ElementTypeHint() {
            this.possibleTags = new HashSet<>();
            this.possibleAttributes = new HashMap<>();
            this.elementType = "unknown";
        }
    }
}


package com.cloudsmart.framework.ai;

import com.cloudsmart.framework.elements.CSSmartDriver;
import com.cloudsmart.framework.elements.CSSmartWebElement;
import com.cloudsmart.framework.logger.CSLogger;
import com.cloudsmart.framework.utils.Configuration;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Provides AI-like text analysis capabilities, including text similarity,
 * sentiment analysis, and accessibility analysis for test automation.
 */
public class CSSmartAIAnalyzer {
    private static final CSLogger logger = CSLogger.getInstance();
    private final CSSmartDriver driver;
    
    // Sentiment analysis data
    private final Map<String, Double> sentimentDictionary;
    
    // Accessibility rules
    private final List<AccessibilityRule> accessibilityRules;
    
    // Configuration
    private final double similarityThreshold;
    
    /**
     * Constructor for CSSmartAIAnalyzer
     * 
     * @param driver The CSSmartDriver instance
     */
    public CSSmartAIAnalyzer(CSSmartDriver driver) {
        this.driver = driver;
        
        // Load configuration
        this.similarityThreshold = Configuration.getDouble("ai.analyzer.similarityThreshold", 0.7);
        
        // Initialize sentiment dictionary
        this.sentimentDictionary = initializeSentimentDictionary();
        
        // Initialize accessibility rules
        this.accessibilityRules = initializeAccessibilityRules();
        
        logger.debug("Initialized CSSmartAIAnalyzer with similarityThreshold=" + similarityThreshold);
    }
    
    /**
     * Calculate the similarity between two text strings
     * 
     * @param text1 First text
     * @param text2 Second text
     * @return Similarity score between 0.0 and 1.0
     */
    public double calculateTextSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0.0;
        }
        
        // Convert to lowercase and tokenize
        List<String> tokens1 = tokenize(text1.toLowerCase());
        List<String> tokens2 = tokenize(text2.toLowerCase());
        
        if (tokens1.isEmpty() || tokens2.isEmpty()) {
            return 0.0;
        }
        
        // Calculate Jaccard similarity
        Set<String> union = new HashSet<>(tokens1);
        union.addAll(tokens2);
        
        Set<String> intersection = new HashSet<>(tokens1);
        intersection.retainAll(new HashSet<>(tokens2));
        
        double jaccardSimilarity = (double) intersection.size() / union.size();
        
        // Calculate word sequence similarity (account for word order)
        double sequenceSimilarity = calculateSequenceSimilarity(tokens1, tokens2);
        
        // Weighted combination of both metrics
        return (jaccardSimilarity * 0.6) + (sequenceSimilarity * 0.4);
    }
    
    /**
     * Calculate sequence similarity (accounts for word order)
     * 
     * @param tokens1 First list of tokens
     * @param tokens2 Second list of tokens
     * @return Sequence similarity score
     */
    private double calculateSequenceSimilarity(List<String> tokens1, List<String> tokens2) {
        int matches = 0;
        int totalPairs = Math.min(tokens1.size() - 1, tokens2.size() - 1);
        
        if (totalPairs <= 0) {
            return tokens1.equals(tokens2) ? 1.0 : 0.0;
        }
        
        // Count matching consecutive word pairs
        for (int i = 0; i < totalPairs; i++) {
            String pair1 = tokens1.get(i) + " " + tokens1.get(i + 1);
            for (int j = 0; j < totalPairs; j++) {
                String pair2 = tokens2.get(j) + " " + tokens2.get(j + 1);
                if (pair1.equals(pair2)) {
                    matches++;
                    break;
                }
            }
        }
        
        return (double) matches / totalPairs;
    }
    
    /**
     * Tokenize text into words, filtering out stopwords
     * 
     * @param text Text to tokenize
     * @return List of tokens
     */
    private List<String> tokenize(String text) {
        // Split by non-word characters
        String[] rawTokens = text.split("\\W+");
        
        // Filter out common stopwords and empty tokens
        Set<String> stopwords = new HashSet<>(Arrays.asList(
            "a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", 
            "with", "in", "out", "of", "is", "are", "was", "were", "be", "been", "being", 
            "have", "has", "had", "do", "does", "did", "will", "would", "shall", "should",
            "can", "could", "may", "might", "must", "that", "which", "who", "whom", "whose",
            "this", "these", "those", "i", "you", "he", "she", "it", "we", "they", "my", 
            "your", "his", "her", "its", "our", "their"
        ));
        
        return Arrays.stream(rawTokens)
                .filter(token -> !token.isEmpty() && !stopwords.contains(token))
                .collect(Collectors.toList());
    }
    
    /**
     * Check if two texts are similar based on the configured threshold
     * 
     * @param expectedText Expected text
     * @param actualText Actual text
     * @return true if texts are similar
     */
    public boolean areTextsSimilar(String expectedText, String actualText) {
        double similarity = calculateTextSimilarity(expectedText, actualText);
        logger.debug("Text similarity: " + similarity + " (threshold: " + similarityThreshold + ")");
        return similarity >= similarityThreshold;
    }
    
    /**
     * Perform sentiment analysis on text
     * 
     * @param text Text to analyze
     * @return SentimentResult with score and classification
     */
    public SentimentResult analyzeSentiment(String text) {
        if (text == null || text.trim().isEmpty()) {
            return new SentimentResult(0.0, "neutral");
        }
        
        // Tokenize and convert to lowercase
        List<String> tokens = tokenize(text.toLowerCase());
        
        // Calculate sentiment score
        double score = 0.0;
        int wordCount = 0;
        
        for (String token : tokens) {
            if (sentimentDictionary.containsKey(token)) {
                score += sentimentDictionary.get(token);
                wordCount++;
            }
        }
        
        // Normalize score
        if (wordCount > 0) {
            score = score / wordCount;
        }
        
        // Classify sentiment
        String classification;
        if (score < -0.3) {
            classification = "negative";
        } else if (score > 0.3) {
            classification = "positive";
        } else {
            classification = "neutral";
        }
        
        logger.debug("Sentiment analysis result: " + score + " (" + classification + ")");
        return new SentimentResult(score, classification);
    }
    
    /**
     * Analyze accessibility of a web element
     * 
     * @param element CSSmartWebElement to analyze
     * @return AccessibilityResult with score and issues
     */
    public AccessibilityResult analyzeAccessibility(CSSmartWebElement element) {
        List<AccessibilityIssue> issues = new ArrayList<>();
        
        try {
            WebElement webElement = element.findElement(element.getOriginalLocator());
            
            // Apply accessibility rules
            for (AccessibilityRule rule : accessibilityRules) {
                try {
                    if (!rule.evaluate(webElement, driver)) {
                        issues.add(new AccessibilityIssue(rule.getName(), rule.getDescription(), rule.getSeverity()));
                    }
                } catch (Exception e) {
                    logger.debug("Error evaluating accessibility rule: " + rule.getName(), e);
                }
            }
            
            // Calculate score based on issues
            int score = calculateAccessibilityScore(issues);
            
            logger.debug("Accessibility analysis for element '" + element.getElementName() + 
                       "': score=" + score + ", issues=" + issues.size());
                       
            return new AccessibilityResult(score, issues);
            
        } catch (Exception e) {
            logger.warn("Error analyzing accessibility for element '" + element.getElementName() + "'", e);
            issues.add(new AccessibilityIssue("element-not-found", "Element could not be analyzed", "critical"));
            return new AccessibilityResult(0, issues);
        }
    }
    
    /**
     * Calculate accessibility score based on issues
     * 
     * @param issues List of accessibility issues
     * @return Score between 0 and 100
     */
    private int calculateAccessibilityScore(List<AccessibilityIssue> issues) {
        if (issues.isEmpty()) {
            return 100;
        }
        
        // Calculate penalty for each issue based on severity
        int totalPenalty = 0;
        for (AccessibilityIssue issue : issues) {
            switch (issue.getSeverity()) {
                case "critical":
                    totalPenalty += 30;
                    break;
                case "serious":
                    totalPenalty += 20;
                    break;
                case "moderate":
                    totalPenalty += 10;
                    break;
                case "minor":
                    totalPenalty += 5;
                    break;
            }
        }
        
        // Cap the penalty at 100
        totalPenalty = Math.min(100, totalPenalty);
        
        return 100 - totalPenalty;
    }
    
    /**
     * Initialize the sentiment dictionary with common words and their sentiment values
     * 
     * @return Map of words to sentiment scores
     */
    private Map<String, Double> initializeSentimentDictionary() {
        Map<String, Double> dictionary = new HashMap<>();
        
        // Positive words
        dictionary.put("good", 0.7);
        dictionary.put("great", 0.8);
        dictionary.put("excellent", 0.9);
        dictionary.put("wonderful", 0.9);
        dictionary.put("amazing", 0.9);
        dictionary.put("fantastic", 0.9);
        dictionary.put("terrific", 0.8);
        dictionary.put("awesome", 0.9);
        dictionary.put("best", 0.9);
        dictionary.put("happy", 0.7);
        dictionary.put("glad", 0.6);
        dictionary.put("satisfied", 0.7);
        dictionary.put("pleased", 0.7);
        dictionary.put("delighted", 0.8);
        dictionary.put("love", 0.8);
        dictionary.put("like", 0.6);
        dictionary.put("enjoy", 0.7);
        dictionary.put("perfect", 0.9);
        dictionary.put("yes", 0.5);
        dictionary.put("success", 0.8);
        dictionary.put("successful", 0.8);
        dictionary.put("easy", 0.6);
        dictionary.put("helpful", 0.7);
        dictionary.put("positive", 0.7);
        dictionary.put("simple", 0.5);
        dictionary.put("correct", 0.6);
        dictionary.put("accurate", 0.6);
        dictionary.put("fast", 0.6);
        dictionary.put("quick", 0.6);
        dictionary.put("efficient", 0.7);
        dictionary.put("improve", 0.6);
        dictionary.put("improvement", 0.6);
        dictionary.put("better", 0.6);
        dictionary.put("recommend", 0.7);
        
        // Negative words
        dictionary.put("bad", -0.7);
        dictionary.put("terrible", -0.9);
        dictionary.put("awful", -0.8);
        dictionary.put("horrible", -0.9);
        dictionary.put("poor", -0.7);
        dictionary.put("worst", -0.9);
        dictionary.put("sad", -0.6);
        dictionary.put("unhappy", -0.7);
        dictionary.put("disappointed", -0.7);
        dictionary.put("disappointing", -0.7);
        dictionary.put("hate", -0.8);
        dictionary.put("dislike", -0.6);
        dictionary.put("difficult", -0.5);
        dictionary.put("hard", -0.5);
        dictionary.put("complicated", -0.6);
        dictionary.put("confusing", -0.6);
        dictionary.put("no", -0.5);
        dictionary.put("not", -0.5);
        dictionary.put("never", -0.6);
        dictionary.put("fail", -0.7);
        dictionary.put("failed", -0.7);
        dictionary.put("failure", -0.7);
        dictionary.put("error", -0.7);
        dictionary.put("problem", -0.6);
        dictionary.put("issue", -0.5);
        dictionary.put("bug", -0.7);
        dictionary.put("defect", -0.7);
        dictionary.put("slow", -0.6);
        dictionary.put("broken", -0.7);
        dictionary.put("crash", -0.8);
        dictionary.put("wrong", -0.6);
        dictionary.put("negative", -0.6);
        dictionary.put("worse", -0.7);
        dictionary.put("complaint", -0.7);
        
        logger.debug("Initialized sentiment dictionary with " + dictionary.size() + " words");
        return dictionary;
    }
    
    /**
     * Initialize accessibility rules
     * 
     * @return List of accessibility rules
     */
    private List<AccessibilityRule> initializeAccessibilityRules() {
        List<AccessibilityRule> rules = new ArrayList<>();
        
        // Image alt text rule
        rules.add(new AccessibilityRule(
            "image-alt-text",
            "Images must have alt text",
            "serious",
            (element, driver) -> {
                if ("img".equalsIgnoreCase(element.getTagName())) {
                    String alt = element.getAttribute("alt");
                    return alt != null && !alt.isEmpty();
                }
                return true;
            }
        ));
        
        // Button text rule
        rules.add(new AccessibilityRule(
            "button-accessible-name",
            "Buttons must have accessible names",
            "serious",
            (element, driver) -> {
                if ("button".equalsIgnoreCase(element.getTagName()) || 
                    ("input".equalsIgnoreCase(element.getTagName()) && 
                     "button".equalsIgnoreCase(element.getAttribute("type")))) {
                    
                    String text = element.getText();
                    String ariaLabel = element.getAttribute("aria-label");
                    String title = element.getAttribute("title");
                    
                    return (text != null && !text.trim().isEmpty()) || 
                           (ariaLabel != null && !ariaLabel.trim().isEmpty()) ||
                           (title != null && !title.trim().isEmpty());
                }
                return true;
            }
        ));
        
        // Input label rule
        rules.add(new AccessibilityRule(
            "input-label",
            "Input fields must have associated labels",
            "serious",
            (element, driver) -> {
                if ("input".equalsIgnoreCase(element.getTagName()) ||
                    "textarea".equalsIgnoreCase(element.getTagName()) ||
                    "select".equalsIgnoreCase(element.getTagName())) {
                    
                    String id = element.getAttribute("id");
                    if (id != null && !id.isEmpty()) {
                        try {
                            // Check if there's a label with 'for' attribute
                            return !driver.findElements(org.openqa.selenium.By.cssSelector("label[for='" + id + "']")).isEmpty();
                        } catch (Exception e) {
                            return false;
                        }
                    } else {
                        // Check if input is inside a label
                        String script = "return arguments[0].closest('label') !== null;";
                        try {
                            return (Boolean) ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(script, element);
                        } catch (Exception e) {
                            return false;
                        }
                    }
                }
                return true;
            }
        ));
        
        // Color contrast rule (simplified)
        rules.add(new AccessibilityRule(
            "color-contrast",
            "Text must have sufficient contrast with its background",
            "serious",
            (element, driver) -> {
                // This is a simplified check - a real implementation would calculate
                // contrast ratios between foreground and background colors
                if (element.getText() != null && !element.getText().trim().isEmpty()) {
                    try {
                        String script = 
                            "var el = arguments[0];" +
                            "var fg = window.getComputedStyle(el).color;" +
                            "var bg = window.getComputedStyle(el).backgroundColor;" +
                            "function getRGB(color) {" +
                            "  if (color.startsWith('rgb')) {" +
                            "    return color.match(/\\d+/g).map(Number);" +
                            "  }" +
                            "  return [0, 0, 0];" +
                            "}" +
                            "var fgRGB = getRGB(fg);" +
                            "var bgRGB = getRGB(bg);" +
                            "var l1 = 0.2126 * (fgRGB[0]/255) + 0.7152 * (fgRGB[1]/255) + 0.0722 * (fgRGB[2]/255);" +
                            "var l2 = 0.2126 * (bgRGB[0]/255) + 0.7152 * (bgRGB[1]/255) + 0.0722 * (bgRGB[2]/255);" +
                            "var contrast = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);" +
                            "return contrast >= 4.5;";
                        
                        Object result = ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(script, element);
                        return (result instanceof Boolean) ? (Boolean) result : true;
                    } catch (Exception e) {
                        return true;  // Default to passing if check fails
                    }
                }
                return true;
            }
        ));
        
        // ARIA role rule
        rules.add(new AccessibilityRule(
            "valid-aria-role",
            "ARIA roles must be valid",
            "moderate",
            (element, driver) -> {
                String role = element.getAttribute("role");
                if (role != null && !role.isEmpty()) {
                    // List of valid ARIA roles
                    Set<String> validRoles = new HashSet<>(Arrays.asList(
                        "alert", "alertdialog", "application", "article", "banner", "button", 
                        "cell", "checkbox", "columnheader", "combobox", "complementary", 
                        "contentinfo", "definition", "dialog", "directory", "document", 
                        "feed", "figure", "form", "grid", "gridcell", "group", "heading", 
                        "img", "link", "list", "listbox", "listitem", "log", "main", 
                        "marquee", "math", "menu", "menubar", "menuitem", "menuitemcheckbox", 
                        "menuitemradio", "navigation", "none", "note", "option", "presentation", 
                        "progressbar", "radio", "radiogroup", "region", "row", "rowgroup", 
                        "rowheader", "scrollbar", "search", "searchbox", "separator", 
                        "slider", "spinbutton", "status", "switch", "tab", "table", 
                        "tablist", "tabpanel", "term", "textbox", "timer", "toolbar", 
                        "tooltip", "tree", "treegrid", "treeitem"
                    ));
                    
                    return validRoles.contains(role.toLowerCase());
                }
                return true;
            }
        ));
        
        // Heading order rule
        rules.add(new AccessibilityRule(
            "heading-order",
            "Headings should be in sequential order",
            "moderate",
            (element, driver) -> {
                String tagName = element.getTagName().toLowerCase();
                if (tagName.matches("h[1-6]")) {
                    int level = Integer.parseInt(tagName.substring(1));
                    
                    // Check if there's a gap in heading levels
                    if (level > 1) {
                        String script = 
                            "var headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');" +
                            "var levels = [];" +
                            "for (var i = 0; i < headings.length; i++) {" +
                            "  if (headings[i] === arguments[0]) break;" +
                            "  levels.push(parseInt(headings[i].tagName.substring(1)));" +
                            "}" +
                            "var maxLevel = Math.max.apply(null, levels.length > 0 ? levels : [0]);" +
                            "return maxLevel === 0 || Math.abs(maxLevel - " + level + ") <= 1;";
                        
                        try {
                            Object result = ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(script, element);
                            return (result instanceof Boolean) ? (Boolean) result : true;
                        } catch (Exception e) {
                            return true;  // Default to passing if check fails
                        }
                    }
                }
                return true;
            }
        ));
        
        // Link purpose rule
        rules.add(new AccessibilityRule(
            "link-purpose",
            "Links should have descriptive text",
            "moderate",
            (element, driver) -> {
                if ("a".equalsIgnoreCase(element.getTagName())) {
                    String text = element.getText();
                    
                    // Check for vague link text
                    if (text != null && !text.isEmpty()) {
                        Pattern vaguePattern = Pattern.compile("^(click here|here|more|read more|link)$", Pattern.CASE_INSENSITIVE);
                        return !vaguePattern.matcher(text.trim()).matches();
                    } else {
                        // If no text, check for aria-label or title
                        String ariaLabel = element.getAttribute("aria-label");
                        String title = element.getAttribute("title");
                        
                        return (ariaLabel != null && !ariaLabel.isEmpty()) || 
                               (title != null && !title.isEmpty());
                    }
                }
                return true;
            }
        ));
        
        // Keyboard focus indicator rule
        rules.add(new AccessibilityRule(
            "focus-visible",
            "Interactive elements should have visible focus indicators",
            "moderate",
            (element, driver) -> {
                String tagName = element.getTagName().toLowerCase();
                String type = element.getAttribute("type");
                
                if (tagName.equals("a") || tagName.equals("button") || 
                    (tagName.equals("input") && !type.equals("hidden")) || 
                    tagName.equals("select") || tagName.equals("textarea") || 
                    element.getAttribute("tabindex") != null) {
                    
                    // Focus the element
                    try {
                        String scriptFocus = "arguments[0].focus(); return true;";
                        ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(scriptFocus, element);
                        
                        // Check if outline or box-shadow style changes on focus
                        String scriptCheckFocus = 
                            "var style = window.getComputedStyle(arguments[0]);" +
                            "return style.outline !== '0px none rgb(0, 0, 0)' || " +
                            "style.boxShadow !== 'none';";
                        
                        Object result = ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(scriptCheckFocus, element);
                        return (result instanceof Boolean) ? (Boolean) result : true;
                    } catch (Exception e) {
                        return true;  // Default to passing if check fails
                    }
                }
                return true;
            }
        ));
        
        logger.debug("Initialized " + rules.size() + " accessibility rules");
        return rules;
    }
    
    /**
     * Class representing a sentiment analysis result
     */
    public static class SentimentResult {
        private final double score;
        private final String classification;
        
        public SentimentResult(double score, String classification) {
            this.score = score;
            this.classification = classification;
        }
        
        public double getScore() {
            return score;
        }
        
        public String getClassification() {
            return classification;
        }
        
        @Override
        public String toString() {
            return "SentimentResult{" +
                   "score=" + score +
                   ", classification='" + classification + '\'' +
                   '}';
        }
    }
    
    /**
     * Class representing an accessibility result
     */
    public static class AccessibilityResult {
        private final int score;
        private final List<AccessibilityIssue> issues;
        
        public AccessibilityResult(int score, List<AccessibilityIssue> issues) {
            this.score = score;
            this.issues = issues;
        }
        
        public int getScore() {
            return score;
        }
        
        public List<AccessibilityIssue> getIssues() {
            return issues;
        }
        
        public boolean isPassing() {
            return score >= 70;
        }
        
        public boolean hasCriticalIssues() {
            return issues.stream().anyMatch(issue -> issue.getSeverity().equals("critical"));
        }
        
        @Override
        public String toString() {
            return "AccessibilityResult{" +
                   "score=" + score +
                   ", issues=" + issues.size() +
                   ", passing=" + isPassing() +
                   '}';
        }
    }
    
    /**
     * Class representing an accessibility issue
     */
    public static class AccessibilityIssue {
        private final String code;
        private final String description;
        private final String severity;
        
        public AccessibilityIssue(String code, String description, String severity) {
            this.code = code;
            this.description = description;
            this.severity = severity;
        }
        
        public String getCode() {
            return code;
        }
        
        public String getDescription() {
            return description;
        }
        
        public String getSeverity() {
            return severity;
        }
        
        @Override
        public String toString() {
            return "AccessibilityIssue{" +
                   "code='" + code + '\'' +
                   ", description='" + description + '\'' +
                   ", severity='" + severity + '\'' +
                   '}';
        }
    }
    
    /**
     * Class representing an accessibility rule
     */
    private static class AccessibilityRule {
        private final String name;
        private final String description;
        private final String severity;
        private final AccessibilityRuleEvaluator evaluator;
        
        public AccessibilityRule(String name, String description, String severity, AccessibilityRuleEvaluator evaluator) {
            this.name = name;
            this.description = description;
            this.severity = severity;
            this.evaluator = evaluator;
        }
        
        public String getName() {
            return name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public String getSeverity() {
            return severity;
        }
        
        public boolean evaluate(WebElement element, CSSmartDriver driver) {
            return evaluator.evaluate(element, driver);
        }
    }
    
    /**
     * Interface for accessibility rule evaluation
     */
    @FunctionalInterface
    private interface AccessibilityRuleEvaluator {
        boolean evaluate(WebElement element, CSSmartDriver driver);
    }
}
