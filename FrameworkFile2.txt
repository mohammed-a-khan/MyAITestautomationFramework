package com.cssmart.core.exception;

/**
 * Base exception class for all CSSmart framework exceptions.
 * Provides standardized exception handling and messaging.
 */
public class CSSmartException extends RuntimeException {
    
    /**
     * Constructs a new CSSmartException with the specified detail message.
     * 
     * @param message The detail message
     */
    public CSSmartException(String message) {
        super(message);
    }
    
    /**
     * Constructs a new CSSmartException with the specified detail message and cause.
     * 
     * @param message The detail message
     * @param cause The cause
     */
    public CSSmartException(String message, Throwable cause) {
        super(message, cause);
    }
    
    /**
     * Constructs a new CSSmartException with the specified cause.
     * 
     * @param cause The cause
     */
    public CSSmartException(Throwable cause) {
        super(cause);
    }
}



package com.cssmart.core.exception;

import org.openqa.selenium.By;

/**
 * Exception thrown when an element is not found on the page.
 */
public class CSSmartElementNotFoundException extends CSSmartException {
    
    private final By locator;
    
    /**
     * Constructs a new CSSmartElementNotFoundException with the specified locator.
     * 
     * @param locator The locator that was used to find the element
     */
    public CSSmartElementNotFoundException(By locator) {
        super("Element not found with locator: " + locator);
        this.locator = locator;
    }
    
    /**
     * Constructs a new CSSmartElementNotFoundException with the specified locator and cause.
     * 
     * @param locator The locator that was used to find the element
     * @param cause The cause
     */
    public CSSmartElementNotFoundException(By locator, Throwable cause) {
        super("Element not found with locator: " + locator, cause);
        this.locator = locator;
    }
    
    /**
     * Constructs a new CSSmartElementNotFoundException with a custom message.
     * 
     * @param message The custom message
     * @param locator The locator that was used to find the element
     */
    public CSSmartElementNotFoundException(String message, By locator) {
        super(message);
        this.locator = locator;
    }
    
    /**
     * Gets the locator that was used to find the element.
     * 
     * @return The locator
     */
    public By getLocator() {
        return locator;
    }
}


package com.cssmart.core.exception;

import java.time.Duration;

/**
 * Exception thrown when a timeout occurs during a wait operation.
 */
public class CSSmartTimeoutException extends CSSmartException {
    
    private final Duration timeout;
    
    /**
     * Constructs a new CSSmartTimeoutException with the specified timeout.
     * 
     * @param timeout The timeout duration
     */
    public CSSmartTimeoutException(Duration timeout) {
        super("Timeout occurred after waiting for " + timeout.toSeconds() + " seconds");
        this.timeout = timeout;
    }
    
    /**
     * Constructs a new CSSmartTimeoutException with the specified timeout and cause.
     * 
     * @param timeout The timeout duration
     * @param cause The cause
     */
    public CSSmartTimeoutException(Duration timeout, Throwable cause) {
        super("Timeout occurred after waiting for " + timeout.toSeconds() + " seconds", cause);
        this.timeout = timeout;
    }
    
    /**
     * Constructs a new CSSmartTimeoutException with a custom message and timeout.
     * 
     * @param message The custom message
     * @param timeout The timeout duration
     */
    public CSSmartTimeoutException(String message, Duration timeout) {
        super(message);
        this.timeout = timeout;
    }
    
    /**
     * Constructs a new CSSmartTimeoutException with a custom message, timeout, and cause.
     * 
     * @param message The custom message
     * @param timeout The timeout duration
     * @param cause The cause
     */
    public CSSmartTimeoutException(String message, Duration timeout, Throwable cause) {
        super(message, cause);
        this.timeout = timeout;
    }
    
    /**
     * Gets the timeout duration.
     * 
     * @return The timeout duration
     */
    public Duration getTimeout() {
        return timeout;
    }
}


package com.cssmart.core.exception;

/**
 * Exception thrown when there is an issue with the framework configuration.
 */
public class CSSmartConfigurationException extends CSSmartException {
    
    /**
     * Constructs a new CSSmartConfigurationException with the specified detail message.
     * 
     * @param message The detail message
     */
    public CSSmartConfigurationException(String message) {
        super(message);
    }
    
    /**
     * Constructs a new CSSmartConfigurationException with the specified detail message and cause.
     * 
     * @param message The detail message
     * @param cause The cause
     */
    public CSSmartConfigurationException(String message, Throwable cause) {
        super(message, cause);
    }
    
    /**
     * Constructs a new CSSmartConfigurationException with the specified configuration key.
     * 
     * @param key The configuration key that caused the issue
     */
    public CSSmartConfigurationException(String key, String reason) {
        super("Configuration error for key '" + key + "': " + reason);
    }
}


package com.cssmart.core.reporting;

import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.util.CSSmartScreenshot;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Core reporting class for test execution results.
 * Provides HTML report generation with test steps, screenshots, and statistics.
 */
public class CSSmartReport {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartReport.class);
    private static final String DEFAULT_REPORT_DIR = "target/cssmart-reports";
    
    private final String reportDir;
    private final String reportName;
    private final String reportTitle;
    private final LocalDateTime startTime;
    private LocalDateTime endTime;
    
    private final List<CSSmartTestResult> testResults = new ArrayList<>();
    private final Map<String, String> environmentInfo = new HashMap<>();
    
    /**
     * Constructs a new CSSmartReport with a default report name.
     */
    public CSSmartReport() {
        this("CSSmart Test Report", "CSSmart Automation Test Results");
    }
    
    /**
     * Constructs a new CSSmartReport with the specified report name and title.
     * 
     * @param reportName The filename for the report
     * @param reportTitle The title displayed in the report
     */
    public CSSmartReport(String reportName, String reportTitle) {
        this(DEFAULT_REPORT_DIR, reportName, reportTitle);
    }
    
    /**
     * Constructs a new CSSmartReport with the specified directory, report name, and title.
     * 
     * @param reportDir The directory to save the report
     * @param reportName The filename for the report
     * @param reportTitle The title displayed in the report
     */
    public CSSmartReport(String reportDir, String reportName, String reportTitle) {
        this.reportDir = reportDir;
        this.reportName = reportName;
        this.reportTitle = reportTitle;
        this.startTime = LocalDateTime.now();
        
        initReportDirectory();
        captureEnvironmentInfo();
    }
    
    /**
     * Initializes the report directory.
     */
    private void initReportDirectory() {
        try {
            Path path = Paths.get(reportDir);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
                LOGGER.info("Created report directory: {}", reportDir);
            }
        } catch (IOException e) {
            LOGGER.error("Failed to create report directory: {}", reportDir, e);
        }
    }
    
    /**
     * Captures environment information for the report.
     */
    private void captureEnvironmentInfo() {
        environmentInfo.put("Java Version", System.getProperty("java.version"));
        environmentInfo.put("OS", System.getProperty("os.name"));
        environmentInfo.put("User", System.getProperty("user.name"));
        environmentInfo.put("Timestamp", startTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
    }
    
    /**
     * Adds environment information to the report.
     * 
     * @param key The information key
     * @param value The information value
     * @return This report instance for method chaining
     */
    public CSSmartReport addEnvironmentInfo(String key, String value) {
        environmentInfo.put(key, value);
        return this;
    }
    
    /**
     * Adds a test result to the report.
     * 
     * @param testResult The test result to add
     * @return This report instance for method chaining
     */
    public CSSmartReport addTestResult(CSSmartTestResult testResult) {
        testResults.add(testResult);
        return this;
    }
    
    /**
     * Creates a new test result and adds it to the report.
     * 
     * @param testName The test name
     * @param testClass The test class name
     * @param status The test status
     * @return The created test result
     */
    public CSSmartTestResult createTestResult(String testName, String testClass, CSSmartTestStatus status) {
        CSSmartTestResult result = new CSSmartTestResult(testName, testClass, status);
        addTestResult(result);
        return result;
    }
    
    /**
     * Generates the HTML report.
     * 
     * @return The path to the generated report
     */
    public String generateReport() {
        endTime = LocalDateTime.now();
        LOGGER.info("Generating HTML report: {}", reportName);
        
        String reportContent = buildReportHtml();
        String reportFilePath = saveReport(reportContent);
        
        LOGGER.info("Report generated: {}", reportFilePath);
        return reportFilePath;
    }
    
    /**
     * Builds the HTML content for the report.
     * 
     * @return The HTML report content
     */
    private String buildReportHtml() {
        StringBuilder html = new StringBuilder();
        
        // HTML header
        html.append("<!DOCTYPE html>\n")
            .append("<html lang=\"en\">\n")
            .append("<head>\n")
            .append("    <meta charset=\"UTF-8\">\n")
            .append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
            .append("    <title>").append(reportTitle).append("</title>\n")
            .append("    <style>\n")
            .append("        body { font-family: Arial, sans-serif; margin: 0; padding: 0; color: #333; }\n")
            .append("        .container { width: 95%; margin: 0 auto; padding: 20px; }\n")
            .append("        .header { background-color: #4CAF50; color: white; padding: 10px; text-align: center; }\n")
            .append("        .summary { background-color: #f5f5f5; padding: 15px; margin: 15px 0; border-radius: 5px; }\n")
            .append("        .summary-table { width: 100%; border-collapse: collapse; }\n")
            .append("        .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n")
            .append("        .summary-table th { background-color: #f2f2f2; }\n")
            .append("        .env-info { margin-top: 20px; }\n")
            .append("        .test-results { margin-top: 20px; }\n")
            .append("        .test { margin-bottom: 15px; padding: 15px; border-radius: 5px; }\n")
            .append("        .test-pass { background-color: #dff0d8; border: 1px solid #d6e9c6; }\n")
            .append("        .test-fail { background-color: #f2dede; border: 1px solid #ebccd1; }\n")
            .append("        .test-skip { background-color: #fcf8e3; border: 1px solid #faebcc; }\n")
            .append("        .test-header { font-weight: bold; margin-bottom: 10px; }\n")
            .append("        .test-steps { margin-top: 10px; }\n")
            .append("        .step { margin: 5px 0; padding: 5px; background-color: #f9f9f9; border-radius: 3px; }\n")
            .append("        .step-pass { border-left: 3px solid #4CAF50; }\n")
            .append("        .step-fail { border-left: 3px solid #d9534f; }\n")
            .append("        .step-skip { border-left: 3px solid #f0ad4e; }\n")
            .append("        .step-info { border-left: 3px solid #5bc0de; }\n")
            .append("        .step-warning { border-left: 3px solid #f0ad4e; }\n")
            .append("        .step-time { color: #777; font-size: 0.9em; }\n")
            .append("        .screenshot { max-width: 100%; height: auto; margin-top: 10px; border: 1px solid #ddd; }\n")
            .append("        .toggle-btn { background: none; border: none; color: #337ab7; cursor: pointer; }\n")
            .append("    </style>\n")
            .append("</head>\n");
        
        // Body start
        html.append("<body>\n")
            .append("    <div class=\"container\">\n")
            .append("        <div class=\"header\">\n")
            .append("            <h1>").append(reportTitle).append("</h1>\n")
            .append("        </div>\n");
        
        // Summary section
        appendSummarySection(html);
        
        // Environment info section
        appendEnvironmentSection(html);
        
        // Test results section
        appendTestResultsSection(html);
        
        // JavaScript for toggling sections
        appendJavaScript(html);
        
        // Body end
        html.append("    </div>\n")
            .append("</body>\n")
            .append("</html>");
        
        return html.toString();
    }
    
    /**
     * Appends the summary section to the report.
     * 
     * @param html The HTML StringBuilder
     */
    private void appendSummarySection(StringBuilder html) {
        int passCount = 0;
        int failCount = 0;
        int skipCount = 0;
        
        for (CSSmartTestResult result : testResults) {
            switch (result.getStatus()) {
                case PASS:
                    passCount++;
                    break;
                case FAIL:
                    failCount++;
                    break;
                case SKIP:
                    skipCount++;
                    break;
            }
        }
        
        int totalCount = testResults.size();
        double passPercentage = totalCount > 0 ? (passCount * 100.0 / totalCount) : 0;
        
        html.append("        <div class=\"summary\">\n")
            .append("            <h2>Test Summary</h2>\n")
            .append("            <table class=\"summary-table\">\n")
            .append("                <tr>\n")
            .append("                    <th>Total Tests</th>\n")
            .append("                    <th>Passed</th>\n")
            .append("                    <th>Failed</th>\n")
            .append("                    <th>Skipped</th>\n")
            .append("                    <th>Pass Rate</th>\n")
            .append("                    <th>Duration</th>\n")
            .append("                </tr>\n")
            .append("                <tr>\n")
            .append("                    <td>").append(totalCount).append("</td>\n")
            .append("                    <td>").append(passCount).append("</td>\n")
            .append("                    <td>").append(failCount).append("</td>\n")
            .append("                    <td>").append(skipCount).append("</td>\n")
            .append("                    <td>").append(String.format("%.2f%%", passPercentage)).append("</td>\n")
            .append("                    <td>").append(calculateDuration()).append("</td>\n")
            .append("                </tr>\n")
            .append("            </table>\n")
            .append("        </div>\n");
    }
    
    /**
     * Appends the environment information section to the report.
     * 
     * @param html The HTML StringBuilder
     */
    private void appendEnvironmentSection(StringBuilder html) {
        html.append("        <div class=\"env-info\">\n")
            .append("            <h2>Environment Information</h2>\n")
            .append("            <table class=\"summary-table\">\n");
        
        for (Map.Entry<String, String> entry : environmentInfo.entrySet()) {
            html.append("                <tr>\n")
                .append("                    <th>").append(entry.getKey()).append("</th>\n")
                .append("                    <td>").append(entry.getValue()).append("</td>\n")
                .append("                </tr>\n");
        }
        
        html.append("            </table>\n")
            .append("        </div>\n");
    }
    
    /**
     * Appends the test results section to the report.
     * 
     * @param html The HTML StringBuilder
     */
    private void appendTestResultsSection(StringBuilder html) {
        html.append("        <div class=\"test-results\">\n")
            .append("            <h2>Test Results</h2>\n");
        
        for (int i = 0; i < testResults.size(); i++) {
            CSSmartTestResult result = testResults.get(i);
            String testId = "test-" + i;
            String testClass = "";
            
            switch (result.getStatus()) {
                case PASS:
                    testClass = "test-pass";
                    break;
                case FAIL:
                    testClass = "test-fail";
                    break;
                case SKIP:
                    testClass = "test-skip";
                    break;
            }
            
            html.append("            <div id=\"").append(testId).append("\" class=\"test ").append(testClass).append("\">\n")
                .append("                <div class=\"test-header\">\n")
                .append("                    <span>").append(result.getTestName()).append("</span>\n")
                .append("                    <span> (").append(result.getStatus()).append(")</span>\n")
                .append("                    <button class=\"toggle-btn\" onclick=\"toggleSteps('").append(testId).append("-steps')\">[Toggle Steps]</button>\n")
                .append("                </div>\n")
                .append("                <div>Class: ").append(result.getTestClass()).append("</div>\n")
                .append("                <div>Duration: ").append(result.getDuration().toMillis()).append(" ms</div>\n");
            
            if (result.getErrorMessage() != null && !result.getErrorMessage().isEmpty()) {
                html.append("                <div style=\"color:red;\">Error: ").append(result.getErrorMessage()).append("</div>\n");
            }
            
            // Test steps
            html.append("                <div id=\"").append(testId).append("-steps\" class=\"test-steps\">\n");
            
            for (CSSmartTestStep step : result.getSteps()) {
                String stepClass = "";
                
                switch (step.getStatus()) {
                    case PASS:
                        stepClass = "step-pass";
                        break;
                    case FAIL:
                        stepClass = "step-fail";
                        break;
                    case SKIP:
                        stepClass = "step-skip";
                        break;
                    case INFO:
                        stepClass = "step-info";
                        break;
                    case WARNING:
                        stepClass = "step-warning";
                        break;
                }
                
                html.append("                    <div class=\"step ").append(stepClass).append("\">\n")
                    .append("                        <div>").append(step.getDescription()).append("</div>\n")
                    .append("                        <div class=\"step-time\">").append(step.getTimestamp().format(DateTimeFormatter.ISO_LOCAL_TIME)).append("</div>\n");
                
                if (step.getScreenshotPath() != null && !step.getScreenshotPath().isEmpty()) {
                    try {
                        // Use relative path for screenshot
                        Path reportPath = Paths.get(reportDir);
                        Path screenshotPath = Paths.get(step.getScreenshotPath());
                        Path relativePath = reportPath.relativize(screenshotPath);
                        
                        html.append("                        <a href=\"").append(relativePath).append("\" target=\"_blank\">\n")
                            .append("                            <img class=\"screenshot\" src=\"").append(relativePath).append("\" alt=\"Step Screenshot\" style=\"max-width:600px;\">\n")
                            .append("                        </a>\n");
                    } catch (Exception e) {
                        LOGGER.error("Error embedding screenshot: {}", step.getScreenshotPath(), e);
                        html.append("                        <div>Screenshot: ").append(step.getScreenshotPath()).append("</div>\n");
                    }
                }
                
                html.append("                    </div>\n");
            }
            
            html.append("                </div>\n")
                .append("            </div>\n");
        }
        
        html.append("        </div>\n");
    }
    
    /**
     * Appends JavaScript for toggling sections to the report.
     * 
     * @param html The HTML StringBuilder
     */
    private void appendJavaScript(StringBuilder html) {
        html.append("        <script>\n")
            .append("            function toggleSteps(id) {\n")
            .append("                var element = document.getElementById(id);\n")
            .append("                if(element.style.display === 'none') {\n")
            .append("                    element.style.display = 'block';\n")
            .append("                } else {\n")
            .append("                    element.style.display = 'none';\n")
            .append("                }\n")
            .append("            }\n")
            .append("        </script>\n");
    }
    
    /**
     * Calculates the test execution duration.
     * 
     * @return The formatted duration string
     */
    private String calculateDuration() {
        LocalDateTime end = endTime != null ? endTime : LocalDateTime.now();
        long seconds = java.time.Duration.between(startTime, end).getSeconds();
        
        long hours = seconds / 3600;
        seconds %= 3600;
        long minutes = seconds / 60;
        seconds %= 60;
        
        return String.format("%02d:%02d:%02d", hours, minutes, seconds);
    }
    
    /**
     * Saves the report to a file.
     * 
     * @param reportContent The HTML report content
     * @return The path to the saved report file
     */
    private String saveReport(String reportContent) {
        try {
            String timestamp = startTime.format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String fileName = reportName.endsWith(".html") ? reportName : reportName + "_" + timestamp + ".html";
            String filePath = reportDir + File.separator + fileName;
            
            try (FileWriter writer = new FileWriter(filePath)) {
                writer.write(reportContent);
            }
            
            return filePath;
        } catch (IOException e) {
            LOGGER.error("Failed to save report", e);
            return null;
        }
    }
}


package com.cssmart.core.reporting;

/**
 * Enum representing the status of a test or test step.
 */
public enum CSSmartTestStatus {
    /**
     * Test or step passed successfully.
     */
    PASS,
    
    /**
     * Test or step failed.
     */
    FAIL,
    
    /**
     * Test or step was skipped.
     */
    SKIP,
    
    /**
     * Informational message (for steps only).
     */
    INFO,
    
    /**
     * Warning message (for steps only).
     */
    WARNING
}


package com.cssmart.core.reporting;

import java.time.LocalDateTime;

/**
 * Represents a single test step in a test execution.
 */
public class CSSmartTestStep {
    private final String description;
    private final CSSmartTestStatus status;
    private final LocalDateTime timestamp;
    private String screenshotPath;
    private String details;
    
    /**
     * Constructs a new CSSmartTestStep with the specified description and status.
     * 
     * @param description The step description
     * @param status The step status
     */
    public CSSmartTestStep(String description, CSSmartTestStatus status) {
        this.description = description;
        this.status = status;
        this.timestamp = LocalDateTime.now();
    }
    
    /**
     * Gets the step description.
     * 
     * @return The step description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Gets the step status.
     * 
     * @return The step status
     */
    public CSSmartTestStatus getStatus() {
        return status;
    }
    
    /**
     * Gets the step timestamp.
     * 
     * @return The step timestamp
     */
    public LocalDateTime getTimestamp() {
        return timestamp;
    }
    
    /**
     * Gets the path to the step screenshot.
     * 
     * @return The screenshot path, or null if no screenshot was taken
     */
    public String getScreenshotPath() {
        return screenshotPath;
    }
    
    /**
     * Sets the path to the step screenshot.
     * 
     * @param screenshotPath The screenshot path
     * @return This step instance for method chaining
     */
    public CSSmartTestStep setScreenshotPath(String screenshotPath) {
        this.screenshotPath = screenshotPath;
        return this;
    }
    
    /**
     * Gets the additional details for the step.
     * 
     * @return The step details
     */
    public String getDetails() {
        return details;
    }
    
    /**
     * Sets the additional details for the step.
     * 
     * @param details The step details
     * @return This step instance for method chaining
     */
    public CSSmartTestStep setDetails(String details) {
        this.details = details;
        return this;
    }
    
    /**
     * Creates a new passed step.
     * 
     * @param description The step description
     * @return The created step
     */
    public static CSSmartTestStep pass(String description) {
        return new CSSmartTestStep(description, CSSmartTestStatus.PASS);
    }
    
    /**
     * Creates a new failed step.
     * 
     * @param description The step description
     * @return The created step
     */
    public static CSSmartTestStep fail(String description) {
        return new CSSmartTestStep(description, CSSmartTestStatus.FAIL);
    }
    
    /**
     * Creates a new skipped step.
     * 
     * @param description The step description
     * @return The created step
     */
    public static CSSmartTestStep skip(String description) {
        return new CSSmartTestStep(description, CSSmartTestStatus.SKIP);
    }
    
    /**
     * Creates a new info step.
     * 
     * @param description The step description
     * @return The created step
     */
    public static CSSmartTestStep info(String description) {
        return new CSSmartTestStep(description, CSSmartTestStatus.INFO);
    }
    
    /**
     * Creates a new warning step.
     * 
     * @param description The step description
     * @return The created step
     */
    public static CSSmartTestStep warning(String description) {
        return new CSSmartTestStep(description, CSSmartTestStatus.WARNING);
    }
}



package com.cssmart.core.reporting;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Represents the result of a test execution with steps and metadata.
 */
public class CSSmartTestResult {
    private final String testName;
    private final String testClass;
    private final LocalDateTime startTime;
    private LocalDateTime endTime;
    private CSSmartTestStatus status;
    private String errorMessage;
    private String stackTrace;
    private final List<CSSmartTestStep> steps = new ArrayList<>();
    
    /**
     * Constructs a new CSSmartTestResult with the specified test name and class.
     * 
     * @param testName The test name
     * @param testClass The test class name
     */
    public CSSmartTestResult(String testName, String testClass) {
        this(testName, testClass, CSSmartTestStatus.PASS);
    }
    
    /**
     * Constructs a new CSSmartTestResult with the specified test name, class, and status.
     * 
     * @param testName The test name
     * @param testClass The test class name
     * @param status The test status
     */
    public CSSmartTestResult(String testName, String testClass, CSSmartTestStatus status) {
        this.testName = testName;
        this.testClass = testClass;
        this.status = status;
        this.startTime = LocalDateTime.now();
    }
    
    /**
     * Gets the test name.
     * 
     * @return The test name
     */
    public String getTestName() {
        return testName;
    }
    
    /**
     * Gets the test class name.
     * 
     * @return The test class name
     */
    public String getTestClass() {
        return testClass;
    }
    
    /**
     * Gets the test start time.
     * 
     * @return The start time
     */
    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    /**
     * Gets the test end time.
     * 
     * @return The end time, or null if the test is not yet complete
     */
    public LocalDateTime getEndTime() {
        return endTime;
    }
    
    /**
     * Gets the test status.
     * 
     * @return The test status
     */
    public CSSmartTestStatus getStatus() {
        return status;
    }
    
    /**
     * Sets the test status.
     * 
     * @param status The test status
     * @return This result instance for method chaining
     */
    public CSSmartTestResult setStatus(CSSmartTestStatus status) {
        this.status = status;
        return this;
    }
    
    /**
     * Gets the error message.
     * 
     * @return The error message, or null if no error occurred
     */
    public String getErrorMessage() {
        return errorMessage;
    }
    
    /**
     * Sets the error message.
     * 
     * @param errorMessage The error message
     * @return This result instance for method chaining
     */
    public CSSmartTestResult setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
        return this;
    }
    
    /**
     * Gets the stack trace.
     * 
     * @return The stack trace, or null if no error occurred
     */
    public String getStackTrace() {
        return stackTrace;
    }
    
    /**
     * Sets the stack trace.
     * 
     * @param stackTrace The stack trace
     * @return This result instance for method chaining
     */
    public CSSmartTestResult setStackTrace(String stackTrace) {
        this.stackTrace = stackTrace;
        return this;
    }
    
    /**
     * Adds a test step to the result.
     * 
     * @param step The test step to add
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addStep(CSSmartTestStep step) {
        steps.add(step);
        
        // If any step fails, the test fails
        if (step.getStatus() == CSSmartTestStatus.FAIL && status != CSSmartTestStatus.FAIL) {
            status = CSSmartTestStatus.FAIL;
        }
        
        return this;
    }
    
    /**
     * Adds a passed test step to the result.
     * 
     * @param description The step description
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addPassStep(String description) {
        return addStep(CSSmartTestStep.pass(description));
    }
    
    /**
     * Adds a failed test step to the result.
     * 
     * @param description The step description
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addFailStep(String description) {
        status = CSSmartTestStatus.FAIL;
        return addStep(CSSmartTestStep.fail(description));
    }
    
    /**
     * Adds a failed test step to the result with error details.
     * 
     * @param description The step description
     * @param error The error that occurred
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addFailStep(String description, Throwable error) {
        status = CSSmartTestStatus.FAIL;
        setErrorMessage(error.getMessage());
        
        StringBuilder stackTraceStr = new StringBuilder();
        for (StackTraceElement element : error.getStackTrace()) {
            stackTraceStr.append(element.toString()).append("\n");
        }
        setStackTrace(stackTraceStr.toString());
        
        return addStep(CSSmartTestStep.fail(description));
    }
    
    /**
     * Adds a skipped test step to the result.
     * 
     * @param description The step description
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addSkipStep(String description) {
        if (status == CSSmartTestStatus.PASS) {
            status = CSSmartTestStatus.SKIP;
        }
        return addStep(CSSmartTestStep.skip(description));
    }
    
    /**
     * Adds an info test step to the result.
     * 
     * @param description The step description
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addInfoStep(String description) {
        return addStep(CSSmartTestStep.info(description));
    }
    
    /**
     * Adds a warning test step to the result.
     * 
     * @param description The step description
     * @return This result instance for method chaining
     */
    public CSSmartTestResult addWarningStep(String description) {
        return addStep(CSSmartTestStep.warning(description));
    }
    
    /**
     * Gets all test steps.
     * 
     * @return The list of test steps
     */
    public List<CSSmartTestStep> getSteps() {
        return steps;
    }
    
    /**
     * Marks the test as complete.
     * 
     * @return This result instance for method chaining
     */
    public CSSmartTestResult markComplete() {
        if (endTime == null) {
            endTime = LocalDateTime.now();
        }
        return this;
    }
    
    /**
     * Gets the test duration.
     * 
     * @return The test duration
     */
    public Duration getDuration() {
        LocalDateTime end = endTime != null ? endTime : LocalDateTime.now();
        return Duration.between(startTime, end);
    }
}

package com.cssmart.core.test;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.driver.BrowserManager;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.CSSmartScreenshot;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Base class for all test classes.
 * Provides common setup, teardown, and reporting functionality.
 */
public abstract class CSSmartTestBase {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartTestBase.class);
    private static final CSSmartReport REPORT = new CSSmartReport();
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    protected CSSmartConfig config;
    protected CSSmartDriver driver;
    protected CSSmartScreenshot screenshot;
    
    /**
     * Setup operations before the test suite runs.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp() {
        LOGGER.info("Setting up test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Browser", config.getString("browser.type", "chrome"))
              .addEnvironmentInfo("Environment", config.getString("env", "test"))
              .addEnvironmentInfo("Base URL", config.getString("base.url", ""));
        
        LOGGER.info("Test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down test suite");
        
        // Quit all browser instances
        BrowserManager.quitAllDrivers();
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("Test report generated: {}", reportPath);
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param method The test method
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(Method method) {
        String testName = method.getName();
        String testClass = method.getDeclaringClass().getSimpleName();
        
        LOGGER.info("Setting up test: {}.{}", testClass, testName);
        
        // Create driver if not already created
        if (driver == null) {
            driver = new BrowserManager(config).createDriver();
        }
        
        // Initialize screenshot utility
        screenshot = new CSSmartScreenshot(driver);
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(testName, testClass, CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        LOGGER.info("Test setup complete: {}.{}", testClass, testName);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String testClass = result.getTestClass().getName();
        
        LOGGER.info("Tearing down test: {}.{}", testClass, testName);
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        // Take screenshot on failure
                        if (driver != null) {
                            String screenshotPath = screenshot.takeScreenshot("failure_" + testName);
                            testResult.addFailStep("Test failed: " + result.getThrowable().getMessage())
                                      .getSteps().get(testResult.getSteps().size() - 1)
                                      .setScreenshotPath(screenshotPath);
                        }
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("Test complete: {}.{} with status {}", testClass, testName, 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Gets the current test result for the executing thread.
     * 
     * @return The test result
     */
    protected CSSmartTestResult getCurrentTestResult() {
        return TEST_RESULTS.get(Thread.currentThread().getId());
    }
    
    /**
     * Logs a test step.
     * 
     * @param description The step description
     * @param status The step status
     * @param takeScreenshot Whether to take a screenshot
     * @return The current test result
     */
    protected CSSmartTestResult logStep(String description, CSSmartTestStatus status, boolean takeScreenshot) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            switch (status) {
                case PASS:
                    testResult.addPassStep(description);
                    break;
                case FAIL:
                    testResult.addFailStep(description);
                    break;
                case SKIP:
                    testResult.addSkipStep(description);
                    break;
                case INFO:
                    testResult.addInfoStep(description);
                    break;
                case WARNING:
                    testResult.addWarningStep(description);
                    break;
            }
            
            if (takeScreenshot && driver != null) {
                String screenshotPath = screenshot.takeScreenshot("step_" + testResult.getSteps().size());
                testResult.getSteps().get(testResult.getSteps().size() - 1).setScreenshotPath(screenshotPath);
            }
        }
        
        return testResult;
    }
    
    /**
     * Logs a passed test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logPass(String description) {
        return logStep(description, CSSmartTestStatus.PASS, false);
    }
    
    /**
     * Logs a passed test step with screenshot.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logPassWithScreenshot(String description) {
        return logStep(description, CSSmartTestStatus.PASS, true);
    }
    
    /**
     * Logs a failed test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logFail(String description) {
        return logStep(description, CSSmartTestStatus.FAIL, true);
    }
    
    /**
     * Logs a failed test step with error details.
     * 
     * @param description The step description
     * @param error The error that occurred
     * @return The current test result
     */
    protected CSSmartTestResult logFail(String description, Throwable error) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            testResult.addFailStep(description, error);
            
            if (driver != null) {
                String screenshotPath = screenshot.takeScreenshot("error_" + testResult.getSteps().size());
                testResult.getSteps().get(testResult.getSteps().size() - 1).setScreenshotPath(screenshotPath);
            }
        }
        
        return testResult;
    }
    
    /**
     * Logs an info test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logInfo(String description) {
        return logStep(description, CSSmartTestStatus.INFO, false);
    }
    
    /**
     * Logs a warning test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logWarning(String description) {
        return logStep(description, CSSmartTestStatus.WARNING, false);
    }
}


package com.cssmart.core.api;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.*;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * Client for making REST API requests.
 * Supports various HTTP methods, headers, and request/response handling.
 */
public class CSSmartApiClient {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartApiClient.class);
    
    private final CSSmartConfig config;
    private final String baseUrl;
    private final int connectionTimeout;
    private final int socketTimeout;
    private final Map<String, String> defaultHeaders;
    
    /**
     * Constructs a new CSSmartApiClient with the specified configuration.
     * 
     * @param config The framework configuration
     */
    public CSSmartApiClient(CSSmartConfig config) {
        this.config = config;
        this.baseUrl = config.getString("api.baseUrl", "");
        this.connectionTimeout = config.getInt("api.timeout.connection", 30000);
        this.socketTimeout = config.getInt("api.timeout.socket", 30000);
        this.defaultHeaders = new HashMap<>();
        
        // Add default headers from configuration
        String headersStr = config.getString("api.headers.default", "");
        if (!headersStr.isEmpty()) {
            String[] headers = headersStr.split(";");
            for (String header : headers) {
                String[] parts = header.split(":");
                if (parts.length == 2) {
                    defaultHeaders.put(parts[0].trim(), parts[1].trim());
                }
            }
        }
        
        // Set content type to JSON by default if not specified
        if (!defaultHeaders.containsKey("Content-Type")) {
            defaultHeaders.put("Content-Type", "application/json");
        }
    }
    
    /**
     * Makes a GET request to the specified endpoint.
     * 
     * @param endpoint The API endpoint
     * @return The API response
     */
    public CSSmartApiResponse get(String endpoint) {
        return get(endpoint, null);
    }
    
    /**
     * Makes a GET request to the specified endpoint with custom headers.
     * 
     * @param endpoint The API endpoint
     * @param headers Custom headers for the request
     * @return The API response
     */
    public CSSmartApiResponse get(String endpoint, Map<String, String> headers) {
        LOGGER.info("Making GET request to: {}", endpoint);
        
        String url = buildUrl(endpoint);
        HttpGet request = new HttpGet(url);
        
        return executeRequest(request, headers);
    }
    
    /**
     * Makes a POST request to the specified endpoint with the given payload.
     * 
     * @param endpoint The API endpoint
     * @param payload The request payload
     * @return The API response
     */
    public CSSmartApiResponse post(String endpoint, String payload) {
        return post(endpoint, payload, null);
    }
    
    /**
     * Makes a POST request to the specified endpoint with the given payload and custom headers.
     * 
     * @param endpoint The API endpoint
     * @param payload The request payload
     * @param headers Custom headers for the request
     * @return The API response
     */
    public CSSmartApiResponse post(String endpoint, String payload, Map<String, String> headers) {
        LOGGER.info("Making POST request to: {}", endpoint);
        
        String url = buildUrl(endpoint);
        HttpPost request = new HttpPost(url);
        
        if (payload != null && !payload.isEmpty()) {
            request.setEntity(new StringEntity(payload, ContentType.APPLICATION_JSON));
        }
        
        return executeRequest(request, headers);
    }
    
    /**
     * Makes a PUT request to the specified endpoint with the given payload.
     * 
     * @param endpoint The API endpoint
     * @param payload The request payload
     * @return The API response
     */
    public CSSmartApiResponse put(String endpoint, String payload) {
        return put(endpoint, payload, null);
    }
    
    /**
     * Makes a PUT request to the specified endpoint with the given payload and custom headers.
     * 
     * @param endpoint The API endpoint
     * @param payload The request payload
     * @param headers Custom headers for the request
     * @return The API response
     */
    public CSSmartApiResponse put(String endpoint, String payload, Map<String, String> headers) {
        LOGGER.info("Making PUT request to: {}", endpoint);
        
        String url = buildUrl(endpoint);
        HttpPut request = new HttpPut(url);
        
        if (payload != null && !payload.isEmpty()) {
            request.setEntity(new StringEntity(payload, ContentType.APPLICATION_JSON));
        }
        
        return executeRequest(request, headers);
    }
    
    /**
     * Makes a DELETE request to the specified endpoint.
     * 
     * @param endpoint The API endpoint
     * @return The API response
     */
    public CSSmartApiResponse delete(String endpoint) {
        return delete(endpoint, null);
    }
    
    /**
     * Makes a DELETE request to the specified endpoint with custom headers.
     * 
     * @param endpoint The API endpoint
     * @param headers Custom headers for the request
     * @return The API response
     */
    public CSSmartApiResponse delete(String endpoint, Map<String, String> headers) {
        LOGGER.info("Making DELETE request to: {}", endpoint);
        
        String url = buildUrl(endpoint);
        HttpDelete request = new HttpDelete(url);
        
        return executeRequest(request, headers);
    }
    
    /**
     * Makes a PATCH request to the specified endpoint with the given payload.
     * 
     * @param endpoint The API endpoint
     * @param payload The request payload
     * @return The API response
     */
    public CSSmartApiResponse patch(String endpoint, String payload) {
        return patch(endpoint, payload, null);
    }
    
    /**
     * Makes a PATCH request to the specified endpoint with the given payload and custom headers.
     * 
     * @param endpoint The API endpoint
     * @param payload The request payload
     * @param headers Custom headers for the request
     * @return The API response
     */
    public CSSmartApiResponse patch(String endpoint, String payload, Map<String, String> headers) {
        LOGGER.info("Making PATCH request to: {}", endpoint);
        
        String url = buildUrl(endpoint);
        HttpPatch request = new HttpPatch(url);
        
        if (payload != null && !payload.isEmpty()) {
            request.setEntity(new StringEntity(payload, ContentType.APPLICATION_JSON));
        }
        
        return executeRequest(request, headers);
    }
    
    /**
     * Makes a multipart POST request to the specified endpoint for file upload.
     * 
     * @param endpoint The API endpoint
     * @param file The file to upload
     * @param fileParameterName The parameter name for the file
     * @param additionalParams Additional form parameters
     * @return The API response
     */
    public CSSmartApiResponse uploadFile(String endpoint, File file, String fileParameterName, 
                                        Map<String, String> additionalParams) {
        return uploadFile(endpoint, file, fileParameterName, additionalParams, null);
    }
    
    /**
     * Makes a multipart POST request to the specified endpoint for file upload with custom headers.
     * 
     * @param endpoint The API endpoint
     * @param file The file to upload
     * @param fileParameterName The parameter name for the file
     * @param additionalParams Additional form parameters
     * @param headers Custom headers for the request
     * @return The API response
     */
    public CSSmartApiResponse uploadFile(String endpoint, File file, String fileParameterName,
                                        Map<String, String> additionalParams, Map<String, String> headers) {
        LOGGER.info("Uploading file to: {}", endpoint);
        
        String url = buildUrl(endpoint);
        HttpPost request = new HttpPost(url);
        
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addBinaryBody(fileParameterName, file, ContentType.APPLICATION_OCTET_STREAM, file.getName());
        
        if (additionalParams != null) {
            for (Map.Entry<String, String> entry : additionalParams.entrySet()) {
                builder.addTextBody(entry.getKey(), entry.getValue(), ContentType.TEXT_PLAIN);
            }
        }
        
        request.setEntity(builder.build());
        
        return executeRequest(request, headers);
    }
    
    /**
     * Executes an HTTP request with the specified headers.
     * 
     * @param request The HTTP request
     * @param headers Custom headers for the request
     * @return The API response
     */
    private CSSmartApiResponse executeRequest(HttpUriRequest request, Map<String, String> headers) {
        // Set up request configuration
        RequestConfig requestConfig = RequestConfig.custom()
            .setConnectTimeout(connectionTimeout)
            .setSocketTimeout(socketTimeout)
            .build();
        
        // Apply default headers
        for (Map.Entry<String, String> entry : defaultHeaders.entrySet()) {
            request.setHeader(entry.getKey(), entry.getValue());
        }
        
        // Apply custom headers
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                request.setHeader(entry.getKey(), entry.getValue());
            }
        }
        
        LOGGER.debug("Request URL: {}", request.getURI());
        LOGGER.debug("Request method: {}", request.getMethod());
        LOGGER.debug("Request headers: {}", (Object[]) request.getAllHeaders());
        
        try (CloseableHttpClient httpClient = HttpClients.custom()
                .setDefaultRequestConfig(requestConfig)
                .build()) {
            
            long startTime = System.currentTimeMillis();
            HttpResponse response = httpClient.execute(request);
            long endTime = System.currentTimeMillis();
            
            CSSmartApiResponse apiResponse = processResponse(response, endTime - startTime);
            
            LOGGER.info("Received response with status code: {}", apiResponse.getStatusCode());
            LOGGER.debug("Response time: {} ms", apiResponse.getResponseTime());
            
            return apiResponse;
            
        } catch (IOException e) {
            LOGGER.error("Error executing request", e);
            throw new CSSmartException("Error executing API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Processes the HTTP response into a CSSmartApiResponse.
     * 
     * @param response The HTTP response
     * @param responseTime The response time in milliseconds
     * @return The API response
     * @throws IOException if response processing fails
     */
    private CSSmartApiResponse processResponse(HttpResponse response, long responseTime) throws IOException {
        int statusCode = response.getStatusLine().getStatusCode();
        
        // Process headers
        Map<String, String> headerMap = new HashMap<>();
        for (Header header : response.getAllHeaders()) {
            headerMap.put(header.getName(), header.getValue());
        }
        
        // Process body
        String body = null;
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            body = EntityUtils.toString(entity, StandardCharsets.UTF_8);
        }
        
        return new CSSmartApiResponse(statusCode, headerMap, body, responseTime);
    }
    
    /**
     * Builds the full URL for the specified endpoint.
     * 
     * @param endpoint The API endpoint
     * @return The full URL
     */
    private String buildUrl(String endpoint) {
        if (endpoint.startsWith("http://") || endpoint.startsWith("https://")) {
            return endpoint;
        }
        
        String url = baseUrl;
        if (!url.endsWith("/") && !endpoint.startsWith("/")) {
            url += "/";
        } else if (url.endsWith("/") && endpoint.startsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }
        
        return url + endpoint;
    }
    
    /**
     * Gets the framework configuration.
     * 
     * @return The CSSmartConfig instance
     */
    public CSSmartConfig getConfig() {
        return config;
    }
    
    /**
     * Gets the base URL.
     * 
     * @return The base URL
     */
    public String getBaseUrl() {
        return baseUrl;
    }
    
    /**
     * Adds a default header that will be sent with all requests.
     * 
     * @param name The header name
     * @param value The header value
     * @return This client instance for method chaining
     */
    public CSSmartApiClient addDefaultHeader(String name, String value) {
        defaultHeaders.put(name, value);
        return this;
    }
    
    /**
     * Creates a set of headers with name-value pairs.
     * 
     * @param namesAndValues Header names and values as alternating varargs
     * @return Map of headers
     */
    public static Map<String, String> headers(String... namesAndValues) {
        if (namesAndValues.length % 2 != 0) {
            throw new IllegalArgumentException("Headers must be provided as name-value pairs");
        }
        
        Map<String, String> headers = new HashMap<>();
        for (int i = 0; i < namesAndValues.length; i += 2) {
            headers.put(namesAndValues[i], namesAndValues[i+1]);
        }
        
        return headers;
    }
}


package com.cssmart.core.api;

import com.cssmart.core.exception.CSSmartException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.Map;

/**
 * Represents an API response with status code, headers, body, and metadata.
 */
public class CSSmartApiResponse {
    private final int statusCode;
    private final Map<String, String> headers;
    private final String body;
    private final long responseTime;
    
    private static final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * Constructs a new CSSmartApiResponse.
     * 
     * @param statusCode The HTTP status code
     * @param headers The response headers
     * @param body The response body
     * @param responseTime The response time in milliseconds
     */
    public CSSmartApiResponse(int statusCode, Map<String, String> headers, String body, long responseTime) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.body = body;
        this.responseTime = responseTime;
    }
    
    /**
     * Gets the status code.
     * 
     * @return The HTTP status code
     */
    public int getStatusCode() {
        return statusCode;
    }
    
    /**
     * Gets the response headers.
     * 
     * @return Map of response headers
     */
    public Map<String, String> getHeaders() {
        return headers;
    }
    
    /**
     * Gets a specific response header.
     * 
     * @param name The header name
     * @return The header value, or null if not present
     */
    public String getHeader(String name) {
        return headers.get(name);
    }
    
    /**
     * Gets the response body as a string.
     * 
     * @return The response body
     */
    public String getBody() {
        return body;
    }
    
    /**
     * Gets the response time.
     * 
     * @return The response time in milliseconds
     */
    public long getResponseTime() {
        return responseTime;
    }
    
    /**
     * Checks if the response has a successful status code (2xx).
     * 
     * @return true if successful, false otherwise
     */
    public boolean isSuccess() {
        return statusCode >= 200 && statusCode < 300;
    }
    
    /**
     * Gets the response body as a JSONObject.
     * 
     * @return The response body as JSONObject
     * @throws CSSmartException if the body is not valid JSON
     */
    public JSONObject getBodyAsJsonObject() {
        if (body == null || body.isEmpty()) {
            return new JSONObject();
        }
        
        try {
            return new JSONObject(body);
        } catch (JSONException e) {
            throw new CSSmartException("Response body is not a valid JSON object: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the response body as a JSONArray.
     * 
     * @return The response body as JSONArray
     * @throws CSSmartException if the body is not a valid JSON array
     */
    public JSONArray getBodyAsJsonArray() {
        if (body == null || body.isEmpty()) {
            return new JSONArray();
        }
        
        try {
            return new JSONArray(body);
        } catch (JSONException e) {
            throw new CSSmartException("Response body is not a valid JSON array: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the response body as a JsonNode for flexible JSON parsing.
     * 
     * @return The response body as JsonNode
     * @throws CSSmartException if the body is not valid JSON
     */
    public JsonNode getBodyAsJsonNode() {
        if (body == null || body.isEmpty()) {
            return objectMapper.createObjectNode();
        }
        
        try {
            return objectMapper.readTree(body);
        } catch (JsonProcessingException e) {
            throw new CSSmartException("Response body is not valid JSON: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the response body as a specified object type using Jackson.
     * 
     * @param <T> The object type
     * @param clazz The class of the object type
     * @return The response body converted to the specified type
     * @throws CSSmartException if conversion fails
     */
    public <T> T getBodyAs(Class<T> clazz) {
        if (body == null || body.isEmpty()) {
            return null;
        }
        
        try {
            return objectMapper.readValue(body, clazz);
        } catch (JsonProcessingException e) {
            throw new CSSmartException("Failed to convert response body to " + clazz.getName() + ": " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a specific field from the JSON response body.
     * 
     * @param fieldPath The field path using JSON pointer notation (e.g., "/data/items/0/id")
     * @return The field value as JsonNode
     * @throws CSSmartException if the field does not exist or the body is not valid JSON
     */
    public JsonNode getJsonField(String fieldPath) {
        JsonNode rootNode = getBodyAsJsonNode();
        
        if (fieldPath == null || fieldPath.isEmpty() || fieldPath.equals("/")) {
            return rootNode;
        }
        
        // Handle simple field names without path notation
        if (!fieldPath.startsWith("/")) {
            fieldPath = "/" + fieldPath;
        }
        
        JsonNode node = rootNode.at(fieldPath);
        if (node.isMissingNode()) {
            throw new CSSmartException("Field not found in response: " + fieldPath);
        }
        
        return node;
    }
    
    /**
     * Gets a specific field from the JSON response body as a string.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @return The field value as string
     * @throws CSSmartException if the field does not exist or the body is not valid JSON
     */
    public String getJsonFieldAsString(String fieldPath) {
        JsonNode node = getJsonField(fieldPath);
        
        if (node.isTextual()) {
            return node.asText();
        } else {
            return node.toString();
        }
    }
    
    /**
     * Gets a specific field from the JSON response body as an integer.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @return The field value as integer
     * @throws CSSmartException if the field does not exist, is not a number, or the body is not valid JSON
     */
    public int getJsonFieldAsInt(String fieldPath) {
        JsonNode node = getJsonField(fieldPath);
        
        if (node.isInt()) {
            return node.asInt();
        } else {
            throw new CSSmartException("Field is not an integer: " + fieldPath);
        }
    }
    
    /**
     * Gets a specific field from the JSON response body as a boolean.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @return The field value as boolean
     * @throws CSSmartException if the field does not exist, is not a boolean, or the body is not valid JSON
     */
    public boolean getJsonFieldAsBoolean(String fieldPath) {
        JsonNode node = getJsonField(fieldPath);
        
        if (node.isBoolean()) {
            return node.asBoolean();
        } else {
            throw new CSSmartException("Field is not a boolean: " + fieldPath);
        }
    }
    
    /**
     * Gets a specific field from the JSON response body as a double.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @return The field value as double
     * @throws CSSmartException if the field does not exist, is not a number, or the body is not valid JSON
     */
    public double getJsonFieldAsDouble(String fieldPath) {
        JsonNode node = getJsonField(fieldPath);
        
        if (node.isNumber()) {
            return node.asDouble();
        } else {
            throw new CSSmartException("Field is not a number: " + fieldPath);
        }
    }
    
    /**
     * Validates that a field exists in the response JSON.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @return This response instance for method chaining
     * @throws CSSmartException if the field does not exist or the body is not valid JSON
     */
    public CSSmartApiResponse validateFieldExists(String fieldPath) {
        getJsonField(fieldPath);
        return this;
    }
    
    /**
     * Validates that the response has the expected status code.
     * 
     * @param expectedStatusCode The expected status code
     * @return This response instance for method chaining
     * @throws CSSmartException if the status code does not match
     */
    public CSSmartApiResponse validateStatusCode(int expectedStatusCode) {
        if (statusCode != expectedStatusCode) {
            throw new CSSmartException("Expected status code " + expectedStatusCode + " but got " + statusCode);
        }
        return this;
    }
    
    /**
     * Validates that the response is successful (2xx status code).
     * 
     * @return This response instance for method chaining
     * @throws CSSmartException if the response is not successful
     */
    public CSSmartApiResponse validateSuccess() {
        if (!isSuccess()) {
            throw new CSSmartException("Expected successful status code but got " + statusCode + ": " + body);
        }
        return this;
    }
    
    /**
     * Validates that a JSON field matches the expected value.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @param expectedValue The expected value
     * @return This response instance for method chaining
     * @throws CSSmartException if the field does not match or does not exist
     */
    public CSSmartApiResponse validateFieldEquals(String fieldPath, String expectedValue) {
        String actualValue = getJsonFieldAsString(fieldPath);
        
        if (!actualValue.equals(expectedValue)) {
            throw new CSSmartException("Expected field " + fieldPath + " to be '" + expectedValue + 
                                      "' but got '" + actualValue + "'");
        }
        
        return this;
    }
    
    /**
     * Validates that a JSON field contains the expected value.
     * 
     * @param fieldPath The field path using JSON pointer notation
     * @param expectedSubstring The expected substring
     * @return This response instance for method chaining
     * @throws CSSmartException if the field does not contain the substring or does not exist
     */
    public CSSmartApiResponse validateFieldContains(String fieldPath, String expectedSubstring) {
        String actualValue = getJsonFieldAsString(fieldPath);
        
        if (!actualValue.contains(expectedSubstring)) {
            throw new CSSmartException("Expected field " + fieldPath + " to contain '" + expectedSubstring + 
                                      "' but got '" + actualValue + "'");
        }
        
        return this;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Status: ").append(statusCode).append("\n");
        sb.append("Response Time: ").append(responseTime).append(" ms\n");
        sb.append("Headers: ").append(headers).append("\n");
        sb.append("Body: ").append(body);
        return sb.toString();
    }
}



package com.cssmart.core.api;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.cssmart.core.exception.CSSmartException;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

/**
 * Builder class for creating API requests.
 * Supports fluent API for constructing requests with various parameters.
 */
public class CSSmartApiRequest {
    private String endpoint;
    private String method;
    private String body;
    private Map<String, String> headers = new HashMap<>();
    private Map<String, String> queryParams = new HashMap<>();
    private File uploadFile;
    private String fileParameterName;
    private Map<String, String> formParams = new HashMap<>();
    
    private static final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * Creates a new request with the specified endpoint.
     * 
     * @param endpoint The API endpoint
     * @return A new request builder
     */
    public static CSSmartApiRequest to(String endpoint) {
        CSSmartApiRequest request = new CSSmartApiRequest();
        request.endpoint = endpoint;
        return request;
    }
    
    /**
     * Sets the request method to GET.
     * 
     * @return This request builder
     */
    public CSSmartApiRequest withGet() {
        this.method = "GET";
        return this;
    }
    
    /**
     * Sets the request method to POST.
     * 
     * @return This request builder
     */
    public CSSmartApiRequest withPost() {
        this.method = "POST";
        return this;
    }
    
    /**
     * Sets the request method to PUT.
     * 
     * @return This request builder
     */
    public CSSmartApiRequest withPut() {
        this.method = "PUT";
        return this;
    }
    
    /**
     * Sets the request method to DELETE.
     * 
     * @return This request builder
     */
    public CSSmartApiRequest withDelete() {
        this.method = "DELETE";
        return this;
    }
    
    /**
     * Sets the request method to PATCH.
     * 
     * @return This request builder
     */
    public CSSmartApiRequest withPatch() {
        this.method = "PATCH";
        return this;
    }
    
    /**
     * Sets the request body.
     * 
     * @param body The request body as a string
     * @return This request builder
     */
    public CSSmartApiRequest withBody(String body) {
        this.body = body;
        return this;
    }
    
    /**
     * Sets the request body from an object that will be serialized to JSON.
     * 
     * @param object The object to serialize
     * @return This request builder
     * @throws CSSmartException if serialization fails
     */
    public CSSmartApiRequest withJsonBody(Object object) {
        try {
            this.body = objectMapper.writeValueAsString(object);
            return withHeader("Content-Type", "application/json");
        } catch (JsonProcessingException e) {
            throw new CSSmartException("Failed to serialize object to JSON: " + e.getMessage(), e);
        }
    }
    
    /**
     * Adds a header to the request.
     * 
     * @param name The header name
     * @param value The header value
     * @return This request builder
     */
    public CSSmartApiRequest withHeader(String name, String value) {
        this.headers.put(name, value);
        return this;
    }
    
    /**
     * Adds multiple headers to the request.
     * 
     * @param headers The headers to add
     * @return This request builder
     */
    public CSSmartApiRequest withHeaders(Map<String, String> headers) {
        this.headers.putAll(headers);
        return this;
    }
    
    /**
     * Adds a query parameter to the request.
     * 
     * @param name The parameter name
     * @param value The parameter value
     * @return This request builder
     */
    public CSSmartApiRequest withQueryParam(String name, String value) {
        this.queryParams.put(name, value);
        return this;
    }
    
    /**
     * Adds multiple query parameters to the request.
     * 
     * @param params The parameters to add
     * @return This request builder
     */
    public CSSmartApiRequest withQueryParams(Map<String, String> params) {
        this.queryParams.putAll(params);
        return this;
    }
    
    /**
     * Configures the request for file upload.
     * 
     * @param file The file to upload
     * @param parameterName The parameter name for the file
     * @return This request builder
     */
    public CSSmartApiRequest withFileUpload(File file, String parameterName) {
        this.uploadFile = file;
        this.fileParameterName = parameterName;
        return this;
    }
    
    /**
     * Adds a form parameter for multipart requests.
     * 
     * @param name The parameter name
     * @param value The parameter value
     * @return This request builder
     */
    public CSSmartApiRequest withFormParam(String name, String value) {
        this.formParams.put(name, value);
        return this;
    }
    
    /**
     * Adds multiple form parameters for multipart requests.
     * 
     * @param params The parameters to add
     * @return This request builder
     */
    public CSSmartApiRequest withFormParams(Map<String, String> params) {
        this.formParams.putAll(params);
        return this;
    }
    
    /**
     * Sets basic authentication credentials.
     * 
     * @param username The username
     * @param password The password
     * @return This request builder
     */
    public CSSmartApiRequest withBasicAuth(String username, String password) {
        String credentials = username + ":" + password;
        String encodedCredentials = java.util.Base64.getEncoder().encodeToString(credentials.getBytes());
        return withHeader("Authorization", "Basic " + encodedCredentials);
    }
    
    /**
     * Sets bearer token authentication.
     * 
     * @param token The bearer token
     * @return This request builder
     */
    public CSSmartApiRequest withBearerToken(String token) {
        return withHeader("Authorization", "Bearer " + token);
    }
    
    /**
     * Executes the request using the provided API client.
     * 
     * @param apiClient The API client to use
     * @return The API response
     */
    public CSSmartApiResponse execute(CSSmartApiClient apiClient) {
        // Build the final endpoint with query parameters
        String finalEndpoint = buildEndpointWithQueryParams();
        
        // Execute based on method and configuration
        if ("GET".equals(method)) {
            return apiClient.get(finalEndpoint, headers);
        } else if ("POST".equals(method)) {
            if (uploadFile != null) {
                return apiClient.uploadFile(finalEndpoint, uploadFile, fileParameterName, formParams, headers);
            } else {
                return apiClient.post(finalEndpoint, body, headers);
            }
        } else if ("PUT".equals(method)) {
            return apiClient.put(finalEndpoint, body, headers);
        } else if ("DELETE".equals(method)) {
            return apiClient.delete(finalEndpoint, headers);
        } else if ("PATCH".equals(method)) {
            return apiClient.patch(finalEndpoint, body, headers);
        } else {
            throw new CSSmartException("Unsupported HTTP method: " + method);
        }
    }
    
    /**
     * Builds the endpoint URL with query parameters.
     * 
     * @return The endpoint with query parameters
     */
    private String buildEndpointWithQueryParams() {
        if (queryParams.isEmpty()) {
            return endpoint;
        }
        
        StringBuilder sb = new StringBuilder(endpoint);
        sb.append(endpoint.contains("?") ? "&" : "?");
        
        boolean first = true;
        for (Map.Entry<String, String> entry : queryParams.entrySet()) {
            if (!first) {
                sb.append("&");
            }
            sb.append(entry.getKey()).append("=").append(entry.getValue());
            first = false;
        }
        
        return sb.toString();
    }
    
    /**
     * Gets the endpoint.
     * 
     * @return The endpoint
     */
    public String getEndpoint() {
        return endpoint;
    }
    
    /**
     * Gets the HTTP method.
     * 
     * @return The HTTP method
     */
    public String getMethod() {
        return method;
    }
    
    /**
     * Gets the request body.
     * 
     * @return The request body
     */
    public String getBody() {
        return body;
    }
    
    /**
     * Gets the request headers.
     * 
     * @return The request headers
     */
    public Map<String, String> getHeaders() {
        return headers;
    }
    
    /**
     * Gets the query parameters.
     * 
     * @return The query parameters
     */
    public Map<String, String> getQueryParams() {
        return queryParams;
    }
}



package com.cssmart.core.api;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Set;

/**
 * Utility for validating JSON responses against JSON Schema specifications.
 */
public class CSSmartSchemaValidator {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartSchemaValidator.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * Validates a JSON string against a JSON schema.
     * 
     * @param json The JSON string to validate
     * @param schemaPath The path to the schema file
     * @return true if valid, throws exception if invalid
     */
    public static boolean validate(String json, String schemaPath) {
        try {
            JsonNode jsonNode = objectMapper.readTree(json);
            JsonNode schemaNode;
            
            // Load schema from file or classpath
            if (Files.exists(Paths.get(schemaPath))) {
                // Load from file
                schemaNode = objectMapper.readTree(Files.newInputStream(Paths.get(schemaPath)));
            } else {
                // Load from classpath
                try (InputStream schemaStream = CSSmartSchemaValidator.class.getResourceAsStream(schemaPath)) {
                    if (schemaStream == null) {
                        throw new CSSmartException("Schema file not found: " + schemaPath);
                    }
                    schemaNode = objectMapper.readTree(schemaStream);
                }
            }
            
            return validate(jsonNode, schemaNode);
        } catch (IOException e) {
            throw new CSSmartException("Failed to load schema or parse JSON: " + e.getMessage(), e);
        }
    }
    
    /**
     * Validates a JSON node against a JSON schema node.
     * 
     * @param jsonNode The JSON node to validate
     * @param schemaNode The schema node
     * @return true if valid, throws exception if invalid
     */
    public static boolean validate(JsonNode jsonNode, JsonNode schemaNode) {
        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);
        JsonSchema schema = factory.getSchema(schemaNode);
        
        Set<ValidationMessage> validationMessages = schema.validate(jsonNode);
        
        if (validationMessages.isEmpty()) {
            LOGGER.debug("JSON validation successful against schema");
            return true;
        } else {
            StringBuilder errorMessages = new StringBuilder("JSON validation failed with the following errors:\n");
            
            for (ValidationMessage message : validationMessages) {
                errorMessages.append("- ").append(message.getMessage())
                             .append(" at path: ").append(message.getPath())
                             .append("\n");
            }
            
            LOGGER.error("JSON validation failed: {}", errorMessages);
            throw new CSSmartException(errorMessages.toString());
        }
    }
    
    /**
     * Validates an API response against a JSON schema.
     * 
     * @param response The API response to validate
     * @param schemaPath The path to the schema file
     * @return true if valid, throws exception if invalid
     */
    public static boolean validate(CSSmartApiResponse response, String schemaPath) {
        return validate(response.getBody(), schemaPath);
    }
    
    /**
     * Validates an API response body as JsonNode against a JSON schema.
     * 
     * @param response The API response to validate
     * @param schemaPath The path to the schema file
     * @return true if valid, throws exception if invalid
     */
    public static boolean validateJsonNode(CSSmartApiResponse response, String schemaPath) {
        try {
            JsonNode jsonNode = response.getBodyAsJsonNode();
            JsonNode schemaNode;
            
            // Load schema from file or classpath
            if (Files.exists(Paths.get(schemaPath))) {
                // Load from file
                schemaNode = objectMapper.readTree(Files.newInputStream(Paths.get(schemaPath)));
            } else {
                // Load from classpath
                try (InputStream schemaStream = CSSmartSchemaValidator.class.getResourceAsStream(schemaPath)) {
                    if (schemaStream == null) {
                        throw new CSSmartException("Schema file not found: " + schemaPath);
                    }
                    schemaNode = objectMapper.readTree(schemaStream);
                }
            }
            
            return validate(jsonNode, schemaNode);
        } catch (IOException e) {
            throw new CSSmartException("Failed to load schema: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generates a JSON schema from a sample JSON string.
     * This is a basic implementation and might need enhancement for complex schemas.
     * 
     * @param json The sample JSON string
     * @return A basic JSON schema
     */
    public static JsonNode generateSchema(String json) {
        try {
            JsonNode jsonNode = objectMapper.readTree(json);
            return generateSchemaFromNode(jsonNode);
        } catch (IOException e) {
            throw new CSSmartException("Failed to parse JSON: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generates a JSON schema from a JsonNode.
     * 
     * @param node The JsonNode to generate schema from
     * @return A basic JSON schema node
     */
    private static JsonNode generateSchemaFromNode(JsonNode node) {
        ObjectMapper mapper = new ObjectMapper();
        com.fasterxml.jackson.databind.node.ObjectNode schemaNode = mapper.createObjectNode();
        
        schemaNode.put("$schema", "http://json-schema.org/draft-07/schema#");
        
        if (node.isObject()) {
            schemaNode.put("type", "object");
            com.fasterxml.jackson.databind.node.ObjectNode properties = mapper.createObjectNode();
            
            node.fields().forEachRemaining(entry -> {
                properties.set(entry.getKey(), generateSchemaFromNode(entry.getValue()));
            });
            
            schemaNode.set("properties", properties);
        } else if (node.isArray()) {
            schemaNode.put("type", "array");
            
            if (node.size() > 0) {
                schemaNode.set("items", generateSchemaFromNode(node.get(0)));
            }
        } else if (node.isTextual()) {
            schemaNode.put("type", "string");
        } else if (node.isNumber()) {
            if (node.isInt()) {
                schemaNode.put("type", "integer");
            } else {
                schemaNode.put("type", "number");
            }
        } else if (node.isBoolean()) {
            schemaNode.put("type", "boolean");
        } else if (node.isNull()) {
            schemaNode.put("type", "null");
        }
        
        return schemaNode;
    }
}



package com.cssmart.core.test;

import com.cssmart.core.api.CSSmartApiClient;
import com.cssmart.core.api.CSSmartApiResponse;
import com.cssmart.core.api.CSSmartSchemaValidator;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Base class for API test classes.
 * Provides setup, teardown, and reporting for API tests.
 */
public abstract class CSSmartApiTestBase {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartApiTestBase.class);
    private static final CSSmartReport REPORT = new CSSmartReport("API Test Report", "CSSmart API Test Results");
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    protected CSSmartConfig config;
    protected CSSmartApiClient apiClient;
    
    /**
     * Setup operations before the test suite runs.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp() {
        LOGGER.info("Setting up API test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("API Base URL", config.getString("api.baseUrl", ""))
              .addEnvironmentInfo("Environment", config.getString("env", "test"));
        
        LOGGER.info("API test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down API test suite");
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("API test report generated: {}", reportPath);
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param method The test method
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(Method method) {
        String testName = method.getName();
        String testClass = method.getDeclaringClass().getSimpleName();
        
        LOGGER.info("Setting up API test: {}.{}", testClass, testName);
        
        // Create API client if not already created
        if (apiClient == null) {
            apiClient = new CSSmartApiClient(config);
        }
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(testName, testClass, CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        LOGGER.info("API test setup complete: {}.{}", testClass, testName);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String testClass = result.getTestClass().getName();
        
        LOGGER.info("Tearing down API test: {}.{}", testClass, testName);
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        testResult.addFailStep("Test failed: " + result.getThrowable().getMessage());
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("API test complete: {}.{} with status {}", testClass, testName, 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Gets the current test result for the executing thread.
     * 
     * @return The test result
     */
    protected CSSmartTestResult getCurrentTestResult() {
        return TEST_RESULTS.get(Thread.currentThread().getId());
    }
    
    /**
     * Logs an API request step.
     * 
     * @param description The step description
     * @param method The HTTP method
     * @param endpoint The API endpoint
     * @param headers The request headers
     * @param body The request body
     * @return The current test result
     */
    protected CSSmartTestResult logApiRequest(String description, String method, String endpoint, 
                                             Map<String, String> headers, String body) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            StringBuilder stepDetails = new StringBuilder();
            stepDetails.append("API Request:\n");
            stepDetails.append("Method: ").append(method).append("\n");
            stepDetails.append("Endpoint: ").append(endpoint).append("\n");
            
            if (headers != null && !headers.isEmpty()) {
                stepDetails.append("Headers:\n");
                for (Map.Entry<String, String> entry : headers.entrySet()) {
                    stepDetails.append("  ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
                }
            }
            
            if (body != null && !body.isEmpty()) {
                stepDetails.append("Body:\n").append(formatJson(body));
            }
            
            testResult.addInfoStep(description)
                      .getSteps().get(testResult.getSteps().size() - 1)
                      .setDetails(stepDetails.toString());
        }
        
        return testResult;
    }
    
    /**
     * Logs an API response step.
     * 
     * @param description The step description
     * @param response The API response
     * @param status The step status
     * @return The current test result
     */
    protected CSSmartTestResult logApiResponse(String description, CSSmartApiResponse response, CSSmartTestStatus status) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            StringBuilder stepDetails = new StringBuilder();
            stepDetails.append("API Response:\n");
            stepDetails.append("Status Code: ").append(response.getStatusCode()).append("\n");
            stepDetails.append("Response Time: ").append(response.getResponseTime()).append(" ms\n");
            
            Map<String, String> headers = response.getHeaders();
            if (headers != null && !headers.isEmpty()) {
                stepDetails.append("Headers:\n");
                for (Map.Entry<String, String> entry : headers.entrySet()) {
                    stepDetails.append("  ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
                }
            }
            
            String body = response.getBody();
            if (body != null && !body.isEmpty()) {
                stepDetails.append("Body:\n").append(formatJson(body));
            }
            
            switch (status) {
                case PASS:
                    testResult.addPassStep(description);
                    break;
                case FAIL:
                    testResult.addFailStep(description);
                    break;
                case WARNING:
                    testResult.addWarningStep(description);
                    break;
                default:
                    testResult.addInfoStep(description);
                    break;
            }
            
            testResult.getSteps().get(testResult.getSteps().size() - 1)
                      .setDetails(stepDetails.toString());
        }
        
        return testResult;
    }
    
    /**
     * Validates an API response against a JSON schema and logs the result.
     * 
     * @param response The API response to validate
     * @param schemaPath The path to the schema file
     * @return true if valid, false if invalid
     */
    protected boolean validateSchema(CSSmartApiResponse response, String schemaPath) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        try {
            boolean isValid = CSSmartSchemaValidator.validate(response, schemaPath);
            
            if (testResult != null) {
                testResult.addPassStep("Schema validation successful against: " + schemaPath);
            }
            
            return true;
        } catch (Exception e) {
            if (testResult != null) {
                testResult.addFailStep("Schema validation failed against: " + schemaPath + "\n" + e.getMessage());
            }
            
            return false;
        }
    }
    
    /**
     * Attempts to format a JSON string for better readability.
     * 
     * @param json The JSON string to format
     * @return The formatted JSON string
     */
    private String formatJson(String json) {
        try {
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            Object jsonObj = mapper.readValue(json, Object.class);
            return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObj);
        } catch (Exception e) {
            // If formatting fails, return the original string
            return json;
        }
    }
}



package com.cssmart.core.db;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;

import java.sql.*;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Client for database interactions.
 * Supports different database types, connection pooling, and query execution.
 */
public class CSSmartDatabaseClient {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartDatabaseClient.class);
    
    private final CSSmartConfig config;
    private final String dbType;
    private final String connectionUrl;
    private final String username;
    private final String password;
    private final int queryTimeout;
    
    private Connection connection;
    
    /**
     * Constructs a new CSSmartDatabaseClient with the specified configuration.
     * 
     * @param config The framework configuration
     */
    public CSSmartDatabaseClient(CSSmartConfig config) {
        this.config = config;
        this.dbType = config.getString("db.type", "mysql");
        this.connectionUrl = buildConnectionUrl();
        this.username = config.getString("db.username", "");
        this.password = config.getString("db.password", "");
        this.queryTimeout = config.getInt("db.query.timeout", 30);
    }
    
    /**
     * Constructs a new CSSmartDatabaseClient with the specified connection details.
     * 
     * @param config The framework configuration
     * @param dbType The database type (mysql, postgresql, oracle, sqlserver)
     * @param host The database host
     * @param port The database port
     * @param databaseName The database name
     * @param username The username
     * @param password The password
     */
    public CSSmartDatabaseClient(CSSmartConfig config, String dbType, String host, int port,
                                String databaseName, String username, String password) {
        this.config = config;
        this.dbType = dbType.toLowerCase();
        this.connectionUrl = buildConnectionUrl(dbType, host, port, databaseName);
        this.username = username;
        this.password = password;
        this.queryTimeout = config.getInt("db.query.timeout", 30);
    }
    
    /**
     * Builds a connection URL based on configuration.
     * 
     * @return The connection URL
     */
    private String buildConnectionUrl() {
        String host = config.getString("db.host", "localhost");
        int port = config.getInt("db.port", getDefaultPort(dbType));
        String database = config.getString("db.name", "");
        
        return buildConnectionUrl(dbType, host, port, database);
    }
    
    /**
     * Builds a connection URL for the specified database type and details.
     * 
     * @param dbType The database type
     * @param host The database host
     * @param port The database port
     * @param databaseName The database name
     * @return The connection URL
     */
    private String buildConnectionUrl(String dbType, String host, int port, String databaseName) {
        switch (dbType.toLowerCase()) {
            case "mysql":
                return "jdbc:mysql://" + host + ":" + port + "/" + databaseName + 
                       "?useSSL=false&serverTimezone=UTC";
            case "postgresql":
            case "postgres":
                return "jdbc:postgresql://" + host + ":" + port + "/" + databaseName;
            case "oracle":
                return "jdbc:oracle:thin:@" + host + ":" + port + ":" + databaseName;
            case "sqlserver":
            case "mssql":
                return "jdbc:sqlserver://" + host + ":" + port + ";databaseName=" + databaseName;
            case "h2":
                return "jdbc:h2:" + host + ":" + port + "/" + databaseName;
            default:
                throw new CSSmartException("Unsupported database type: " + dbType);
        }
    }
    
    /**
     * Gets the default port for the specified database type.
     * 
     * @param dbType The database type
     * @return The default port
     */
    private int getDefaultPort(String dbType) {
        switch (dbType.toLowerCase()) {
            case "mysql":
                return 3306;
            case "postgresql":
            case "postgres":
                return 5432;
            case "oracle":
                return 1521;
            case "sqlserver":
            case "mssql":
                return 1433;
            case "h2":
                return 9092;
            default:
                return 0;
        }
    }
    
    /**
     * Gets the JDBC driver class name for the specified database type.
     * 
     * @param dbType The database type
     * @return The driver class name
     */
    private String getDriverClass(String dbType) {
        switch (dbType.toLowerCase()) {
            case "mysql":
                return "com.mysql.cj.jdbc.Driver";
            case "postgresql":
            case "postgres":
                return "org.postgresql.Driver";
            case "oracle":
                return "oracle.jdbc.OracleDriver";
            case "sqlserver":
            case "mssql":
                return "com.microsoft.sqlserver.jdbc.SQLServerDriver";
            case "h2":
                return "org.h2.Driver";
            default:
                throw new CSSmartException("Unsupported database type: " + dbType);
        }
    }
    
    /**
     * Connects to the database.
     * 
     * @return This client instance for method chaining
     */
    public CSSmartDatabaseClient connect() {
        if (connection != null) {
            return this;
        }
        
        LOGGER.info("Connecting to database: {}", connectionUrl);
        
        try {
            // Load the JDBC driver
            String driverClass = getDriverClass(dbType);
            Class.forName(driverClass);
            
            // Create the connection
            connection = DriverManager.getConnection(connectionUrl, username, password);
            LOGGER.info("Connected to database successfully");
            
            return this;
        } catch (ClassNotFoundException e) {
            LOGGER.error("Database driver not found: {}", e.getMessage(), e);
            throw new CSSmartException("Database driver not found: " + e.getMessage(), e);
        } catch (SQLException e) {
            LOGGER.error("Failed to connect to database: {}", e.getMessage(), e);
            throw new CSSmartException("Failed to connect to database: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if connected to the database.
     * 
     * @return true if connected, false otherwise
     */
    public boolean isConnected() {
        if (connection == null) {
            return false;
        }
        
        try {
            return !connection.isClosed();
        } catch (SQLException e) {
            return false;
        }
    }
    
    /**
     * Disconnects from the database.
     */
    public void disconnect() {
        if (connection != null) {
            try {
                if (!connection.isClosed()) {
                    connection.close();
                    LOGGER.info("Disconnected from database");
                }
            } catch (SQLException e) {
                LOGGER.error("Error disconnecting from database", e);
            } finally {
                connection = null;
            }
        }
    }
    
    /**
     * Executes a SQL query and returns the results.
     * 
     * @param sql The SQL query to execute
     * @return The query results as a list of maps
     */
    public List<Map<String, Object>> executeQuery(String sql) {
        return executeQuery(sql, null);
    }
    
    /**
     * Executes a SQL query with parameters and returns the results.
     * 
     * @param sql The SQL query to execute
     * @param params The query parameters
     * @return The query results as a list of maps
     */
    public List<Map<String, Object>> executeQuery(String sql, Object[] params) {
        ensureConnected();
        
        LOGGER.debug("Executing query: {}", sql);
        if (params != null && params.length > 0) {
            LOGGER.debug("Query parameters: {}", (Object) params);
        }
        
        List<Map<String, Object>> results = new ArrayList<>();
        
        try (PreparedStatement stmt = prepareStatement(sql, params);
             ResultSet rs = stmt.executeQuery()) {
            
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            while (rs.next()) {
                Map<String, Object> row = new HashMap<>();
                
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = metaData.getColumnLabel(i);
                    Object value = rs.getObject(i);
                    row.put(columnName, value);
                }
                
                results.add(row);
            }
            
            LOGGER.debug("Query returned {} rows", results.size());
            return results;
        } catch (SQLException e) {
            LOGGER.error("Error executing query: {}", e.getMessage(), e);
            throw new CSSmartException("Error executing query: " + e.getMessage(), e);
        }
    }
    
    /**
     * Executes a SQL update statement (INSERT, UPDATE, DELETE).
     * 
     * @param sql The SQL statement to execute
     * @return The number of affected rows
     */
    public int executeUpdate(String sql) {
        return executeUpdate(sql, null);
    }
    
    /**
     * Executes a SQL update statement with parameters.
     * 
     * @param sql The SQL statement to execute
     * @param params The statement parameters
     * @return The number of affected rows
     */
    public int executeUpdate(String sql, Object[] params) {
        ensureConnected();
        
        LOGGER.debug("Executing update: {}", sql);
        if (params != null && params.length > 0) {
            LOGGER.debug("Update parameters: {}", (Object) params);
        }
        
        try (PreparedStatement stmt = prepareStatement(sql, params)) {
            int affectedRows = stmt.executeUpdate();
            LOGGER.debug("Update affected {} rows", affectedRows);
            return affectedRows;
        } catch (SQLException e) {
            LOGGER.error("Error executing update: {}", e.getMessage(), e);
            throw new CSSmartException("Error executing update: " + e.getMessage(), e);
        }
    }
    
    /**
     * Executes a SQL statement that returns generated keys.
     * 
     * @param sql The SQL statement to execute
     * @param params The statement parameters
     * @return The generated keys as a list
     */
    public List<Object> executeUpdateWithGeneratedKeys(String sql, Object[] params) {
        ensureConnected();
        
        LOGGER.debug("Executing update with generated keys: {}", sql);
        if (params != null && params.length > 0) {
            LOGGER.debug("Update parameters: {}", (Object) params);
        }
        
        List<Object> generatedKeys = new ArrayList<>();
        
        try (PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            setParameters(stmt, params);
            stmt.executeUpdate();
            
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                while (rs.next()) {
                    generatedKeys.add(rs.getObject(1));
                }
            }
            
            LOGGER.debug("Generated {} keys", generatedKeys.size());
            return generatedKeys;
        } catch (SQLException e) {
            LOGGER.error("Error executing update with generated keys: {}", e.getMessage(), e);
            throw new CSSmartException("Error executing update: " + e.getMessage(), e);
        }
    }
    
    /**
     * Executes a stored procedure.
     * 
     * @param procedureName The procedure name
     * @param params The procedure parameters
     * @return The results as a list of maps
     */
    public List<Map<String, Object>> executeStoredProcedure(String procedureName, Object[] params) {
        ensureConnected();
        
        LOGGER.debug("Executing stored procedure: {}", procedureName);
        if (params != null && params.length > 0) {
            LOGGER.debug("Procedure parameters: {}", (Object) params);
        }
        
        String sql = buildStoredProcedureCall(procedureName, params != null ? params.length : 0);
        
        try (CallableStatement stmt = connection.prepareCall(sql)) {
            setParameters(stmt, params);
            
            boolean hasResults = stmt.execute();
            List<Map<String, Object>> results = new ArrayList<>();
            
            while (hasResults) {
                try (ResultSet rs = stmt.getResultSet()) {
                    results.addAll(resultSetToMapList(rs));
                }
                
                hasResults = stmt.getMoreResults();
            }
            
            LOGGER.debug("Stored procedure returned {} rows", results.size());
            return results;
        } catch (SQLException e) {
            LOGGER.error("Error executing stored procedure: {}", e.getMessage(), e);
            throw new CSSmartException("Error executing stored procedure: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a single value from a query result.
     * 
     * @param sql The SQL query
     * @param params The query parameters
     * @return The single value, or null if no results
     */
    public Object getSingleValue(String sql, Object[] params) {
        List<Map<String, Object>> results = executeQuery(sql, params);
        
        if (results.isEmpty()) {
            return null;
        }
        
        Map<String, Object> row = results.get(0);
        if (row.isEmpty()) {
            return null;
        }
        
        return row.values().iterator().next();
    }
    
    /**
     * Begins a transaction.
     */
    public void beginTransaction() {
        ensureConnected();
        
        try {
            connection.setAutoCommit(false);
            LOGGER.debug("Transaction started");
        } catch (SQLException e) {
            LOGGER.error("Error starting transaction", e);
            throw new CSSmartException("Error starting transaction: " + e.getMessage(), e);
        }
    }
    
    /**
     * Commits the current transaction.
     */
    public void commitTransaction() {
        ensureConnected();
        
        try {
            connection.commit();
            connection.setAutoCommit(true);
            LOGGER.debug("Transaction committed");
        } catch (SQLException e) {
            LOGGER.error("Error committing transaction", e);
            throw new CSSmartException("Error committing transaction: " + e.getMessage(), e);
        }
    }
    
    /**
     * Rolls back the current transaction.
     */
    public void rollbackTransaction() {
        ensureConnected();
        
        try {
            connection.rollback();
            connection.setAutoCommit(true);
            LOGGER.debug("Transaction rolled back");
        } catch (SQLException e) {
            LOGGER.error("Error rolling back transaction", e);
            throw new CSSmartException("Error rolling back transaction: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if a table exists in the database.
     * 
     * @param tableName The table name
     * @return true if the table exists, false otherwise
     */
    public boolean tableExists(String tableName) {
        ensureConnected();
        
        try {
            DatabaseMetaData metaData = connection.getMetaData();
            try (ResultSet rs = metaData.getTables(null, null, tableName, null)) {
                return rs.next();
            }
        } catch (SQLException e) {
            LOGGER.error("Error checking if table exists: {}", e.getMessage(), e);
            throw new CSSmartException("Error checking if table exists: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets information about the database.
     * 
     * @return Map of database information
     */
    public Map<String, String> getDatabaseInfo() {
        ensureConnected();
        
        try {
            DatabaseMetaData metaData = connection.getMetaData();
            Map<String, String> info = new HashMap<>();
            
            info.put("Database Product Name", metaData.getDatabaseProductName());
            info.put("Database Product Version", metaData.getDatabaseProductVersion());
            info.put("Driver Name", metaData.getDriverName());
            info.put("Driver Version", metaData.getDriverVersion());
            info.put("JDBC Major Version", String.valueOf(metaData.getJDBCMajorVersion()));
            info.put("JDBC Minor Version", String.valueOf(metaData.getJDBCMinorVersion()));
            
            return info;
        } catch (SQLException e) {
            LOGGER.error("Error getting database information: {}", e.getMessage(), e);
            throw new CSSmartException("Error getting database information: " + e.getMessage(), e);
        }
    }
    
    /**
     * Prepares a statement with parameters.
     * 
     * @param sql The SQL statement
     * @param params The parameters
     * @return The prepared statement
     * @throws SQLException if preparation fails
     */
    private PreparedStatement prepareStatement(String sql, Object[] params) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement(sql);
        stmt.setQueryTimeout(queryTimeout);
        
        setParameters(stmt, params);
        return stmt;
    }
    
    /**
     * Sets parameters on a prepared statement.
     * 
     * @param stmt The prepared statement
     * @param params The parameters
     * @throws SQLException if setting parameters fails
     */
    private void setParameters(PreparedStatement stmt, Object[] params) throws SQLException {
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                Object param = params[i];
                
                if (param == null) {
                    stmt.setNull(i + 1, Types.NULL);
                } else if (param instanceof String) {
                    stmt.setString(i + 1, (String) param);
                } else if (param instanceof Integer) {
                    stmt.setInt(i + 1, (Integer) param);
                } else if (param instanceof Long) {
                    stmt.setLong(i + 1, (Long) param);
                } else if (param instanceof Double) {
                    stmt.setDouble(i + 1, (Double) param);
                } else if (param instanceof Boolean) {
                    stmt.setBoolean(i + 1, (Boolean) param);
                } else if (param instanceof java.util.Date) {
                    stmt.setTimestamp(i + 1, new Timestamp(((java.util.Date) param).getTime()));
                } else if (param instanceof java.time.LocalDate) {
                    stmt.setDate(i + 1, java.sql.Date.valueOf((java.time.LocalDate) param));
                } else if (param instanceof java.time.LocalDateTime) {
                    stmt.setTimestamp(i + 1, Timestamp.valueOf((java.time.LocalDateTime) param));
                } else {
                    stmt.setObject(i + 1, param);
                }
            }
        }
    }
    
    /**
     * Builds a stored procedure call SQL string.
     * 
     * @param procedureName The procedure name
     * @param paramCount The number of parameters
     * @return The procedure call SQL
     */
    private String buildStoredProcedureCall(String procedureName, int paramCount) {
        StringBuilder sql = new StringBuilder();
        sql.append("{ call ").append(procedureName).append("(");
        
        for (int i = 0; i < paramCount; i++) {
            if (i > 0) {
                sql.append(", ");
            }
            sql.append("?");
        }
        
        sql.append(") }");
        return sql.toString();
    }
    
    /**
     * Converts a ResultSet to a list of maps.
     * 
     * @param rs The ResultSet
     * @return List of maps representing the rows
     * @throws SQLException if conversion fails
     */
    private List<Map<String, Object>> resultSetToMapList(ResultSet rs) throws SQLException {
        List<Map<String, Object>> results = new ArrayList<>();
        
        if (rs == null) {
            return results;
        }
        
        ResultSetMetaData metaData = rs.getMetaData();
        int columnCount = metaData.getColumnCount();
        
        while (rs.next()) {
            Map<String, Object> row = new HashMap<>();
            
            for (int i = 1; i <= columnCount; i++) {
                String columnName = metaData.getColumnLabel(i);
                Object value = rs.getObject(i);
                row.put(columnName, value);
            }
            
            results.add(row);
        }
        
        return results;
    }
    
    /**
     * Ensures that a connection to the database exists.
     * 
     * @throws CSSmartException if not connected
     */
    private void ensureConnected() {
        if (!isConnected()) {
            connect();
        }
    }
}



package com.cssmart.core.test;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.db.CSSmartDatabaseClient;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Base class for database test classes.
 * Provides setup, teardown, and reporting for database tests.
 */
public abstract class CSSmartDbTestBase {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartDbTestBase.class);
    private static final CSSmartReport REPORT = new CSSmartReport("Database Test Report", "CSSmart Database Test Results");
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    protected CSSmartConfig config;
    protected CSSmartDatabaseClient dbClient;
    
    /**
     * Setup operations before the test suite runs.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp() {
        LOGGER.info("Setting up database test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Database Type", config.getString("db.type", ""))
              .addEnvironmentInfo("Database Host", config.getString("db.host", ""))
              .addEnvironmentInfo("Database Name", config.getString("db.name", ""))
              .addEnvironmentInfo("Environment", config.getString("env", "test"));
        
        LOGGER.info("Database test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down database test suite");
        
        // Disconnect from database if still connected
        if (dbClient != null && dbClient.isConnected()) {
            dbClient.disconnect();
        }
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("Database test report generated: {}", reportPath);
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param method The test method
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(Method method) {
        String testName = method.getName();
        String testClass = method.getDeclaringClass().getSimpleName();
        
        LOGGER.info("Setting up database test: {}.{}", testClass, testName);
        
        // Create database client if not already created
        if (dbClient == null) {
            dbClient = new CSSmartDatabaseClient(config);
            dbClient.connect();
        } else if (!dbClient.isConnected()) {
            dbClient.connect();
        }
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(testName, testClass, CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        LOGGER.info("Database test setup complete: {}.{}", testClass, testName);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String testClass = result.getTestClass().getName();
        
        LOGGER.info("Tearing down database test: {}.{}", testClass, testName);
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        testResult.addFailStep("Test failed: " + result.getThrowable().getMessage());
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("Database test complete: {}.{} with status {}", testClass, testName, 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Gets the current test result for the executing thread.
     * 
     * @return The test result
     */
    protected CSSmartTestResult getCurrentTestResult() {
        return TEST_RESULTS.get(Thread.currentThread().getId());
    }
    
    /**
     * Logs a database query step.
     * 
     * @param description The step description
     * @param sql The SQL query
     * @param params The query parameters
     * @return The current test result
     */
    protected CSSmartTestResult logQuery(String description, String sql, Object[] params) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            StringBuilder stepDetails = new StringBuilder();
            stepDetails.append("SQL Query:\n").append(formatSql(sql)).append("\n");
            
            if (params != null && params.length > 0) {
                stepDetails.append("Parameters:\n");
                for (int i = 0; i < params.length; i++) {
                    stepDetails.append("  ").append(i + 1).append(": ").append(params[i]).append("\n");
                }
            }
            
            testResult.addInfoStep(description)
                      .getSteps().get(testResult.getSteps().size() - 1)
                      .setDetails(stepDetails.toString());
        }
        
        return testResult;
    }
    
    /**
     * Logs a database query result step.
     * 
     * @param description The step description
     * @param results The query results
     * @param status The step status
     * @return The current test result
     */
    protected CSSmartTestResult logQueryResult(String description, List<Map<String, Object>> results, CSSmartTestStatus status) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            StringBuilder stepDetails = new StringBuilder();
            stepDetails.append("Query Results:\n");
            stepDetails.append("Row Count: ").append(results.size()).append("\n");
            
            if (!results.isEmpty()) {
                // Get column names from first row
                Map<String, Object> firstRow = results.get(0);
                stepDetails.append("\nColumns: ");
                for (String column : firstRow.keySet()) {
                    stepDetails.append(column).append(", ");
                }
                
                // Remove trailing comma and space
                if (!firstRow.isEmpty()) {
                    stepDetails.setLength(stepDetails.length() - 2);
                }
                
                // Add first few rows as sample
                int rowsToShow = Math.min(results.size(), 5);
                stepDetails.append("\n\nSample Data (").append(rowsToShow).append(" rows):\n");
                
                for (int i = 0; i < rowsToShow; i++) {
                    Map<String, Object> row = results.get(i);
                    stepDetails.append("Row ").append(i + 1).append(": ");
                    
                    for (Map.Entry<String, Object> entry : row.entrySet()) {
                        Object value = entry.getValue();
                        String valueStr = (value != null) ? value.toString() : "NULL";
                        stepDetails.append(entry.getKey()).append("=").append(valueStr).append(", ");
                    }
                    
                    // Remove trailing comma and space
                    if (!row.isEmpty()) {
                        stepDetails.setLength(stepDetails.length() - 2);
                    }
                    
                    stepDetails.append("\n");
                }
            }
            
            switch (status) {
                case PASS:
                    testResult.addPassStep(description);
                    break;
                case FAIL:
                    testResult.addFailStep(description);
                    break;
                case WARNING:
                    testResult.addWarningStep(description);
                    break;
                default:
                    testResult.addInfoStep(description);
                    break;
            }
            
            testResult.getSteps().get(testResult.getSteps().size() - 1)
                      .setDetails(stepDetails.toString());
        }
        
        return testResult;
    }
    
    /**
     * Logs a database update step.
     * 
     * @param description The step description
     * @param sql The SQL statement
     * @param params The statement parameters
     * @param affectedRows The number of affected rows
     * @param status The step status
     * @return The current test result
     */
    protected CSSmartTestResult logUpdate(String description, String sql, Object[] params, int affectedRows, CSSmartTestStatus status) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            StringBuilder stepDetails = new StringBuilder();
            stepDetails.append("SQL Update:\n").append(formatSql(sql)).append("\n");
            
            if (params != null && params.length > 0) {
                stepDetails.append("Parameters:\n");
                for (int i = 0; i < params.length; i++) {
                    stepDetails.append("  ").append(i + 1).append(": ").append(params[i]).append("\n");
                }
            }
            
            stepDetails.append("\nAffected Rows: ").append(affectedRows);
            
            switch (status) {
                case PASS:
                    testResult.addPassStep(description);
                    break;
                case FAIL:
                    testResult.addFailStep(description);
                    break;
                case WARNING:
                    testResult.addWarningStep(description);
                    break;
                default:
                    testResult.addInfoStep(description);
                    break;
            }
            
            testResult.getSteps().get(testResult.getSteps().size() - 1)
                      .setDetails(stepDetails.toString());
        }
        
        return testResult;
    }
    
    /**
     * Formats SQL for better readability.
     * 
     * @param sql The SQL to format
     * @return The formatted SQL
     */
    private String formatSql(String sql) {
        // This is a simple formatter, more sophisticated ones could be used
        return sql.replaceAll("(?i)\\b(SELECT|FROM|WHERE|AND|OR|GROUP BY|ORDER BY|HAVING|JOIN|LEFT|RIGHT|INNER|OUTER|FULL|ON|AS|UNION|INSERT|VALUES|UPDATE|SET|DELETE)\\b", "\n$1")
                 .replaceAll("\\s+", " ")
                 .trim();
    }
}



package com.cssmart.core.ai;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.WebElement;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Provides AI-assisted analysis capabilities for test automation.
 * Implements intelligent verification, text analysis, and automation assistance.
 */
public class CSSmartAIAnalyzer {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartAIAnalyzer.class);
    
    private final CSSmartConfig config;
    
    /**
     * Constructs a new CSSmartAIAnalyzer with the specified configuration.
     * 
     * @param config The framework configuration
     */
    public CSSmartAIAnalyzer(CSSmartConfig config) {
        this.config = config;
    }
    
    /**
     * Analyzes text similarity between expected and actual values.
     * 
     * @param expected The expected text
     * @param actual The actual text
     * @param similarityThreshold The threshold for similarity (0.0 to 1.0)
     * @return true if texts are similar, false otherwise
     */
    public boolean areTextsSimilar(String expected, String actual, double similarityThreshold) {
        LOGGER.debug("Analyzing text similarity between: '{}' and '{}'", expected, actual);
        
        if (expected == null || actual == null) {
            return expected == actual;
        }
        
        if (expected.equals(actual)) {
            return true;
        }
        
        // Calculate Jaccard similarity coefficient for word-level comparison
        double similarity = calculateJaccardSimilarity(expected, actual);
        boolean similar = similarity >= similarityThreshold;
        
        LOGGER.debug("Text similarity: {}, threshold: {}, similar: {}", 
                   similarity, similarityThreshold, similar);
        
        return similar;
    }
    
    /**
     * Calculates Jaccard similarity coefficient between two texts.
     * 
     * @param text1 The first text
     * @param text2 The second text
     * @return The similarity coefficient (0.0 to 1.0)
     */
    public double calculateJaccardSimilarity(String text1, String text2) {
        // Convert to lowercase and split into words
        String[] words1 = text1.toLowerCase().split("\\W+");
        String[] words2 = text2.toLowerCase().split("\\W+");
        
        // Create sets for comparison
        Map<String, Integer> wordSet1 = new HashMap<>();
        Map<String, Integer> wordSet2 = new HashMap<>();
        
        // Count word frequencies
        for (String word : words1) {
            if (!word.isEmpty()) {
                wordSet1.put(word, wordSet1.getOrDefault(word, 0) + 1);
            }
        }
        
        for (String word : words2) {
            if (!word.isEmpty()) {
                wordSet2.put(word, wordSet2.getOrDefault(word, 0) + 1);
            }
        }
        
        // Calculate intersection and union sizes
        int intersection = 0;
        for (Map.Entry<String, Integer> entry : wordSet1.entrySet()) {
            String word = entry.getKey();
            int count1 = entry.getValue();
            int count2 = wordSet2.getOrDefault(word, 0);
            intersection += Math.min(count1, count2);
        }
        
        int union = 0;
        for (Map.Entry<String, Integer> entry : wordSet1.entrySet()) {
            String word = entry.getKey();
            int count1 = entry.getValue();
            int count2 = wordSet2.getOrDefault(word, 0);
            union += Math.max(count1, count2);
        }
        
        for (Map.Entry<String, Integer> entry : wordSet2.entrySet()) {
            if (!wordSet1.containsKey(entry.getKey())) {
                union += entry.getValue();
            }
        }
        
        // Calculate Jaccard similarity
        return union == 0 ? 0 : (double) intersection / union;
    }
    
    /**
     * Checks for semantic similarity between texts using pattern matching and key concept extraction.
     * 
     * @param expected The expected text
     * @param actual The actual text
     * @param threshold The threshold for similarity (0.0 to 1.0)
     * @return true if texts are semantically similar, false otherwise
     */
    public boolean areTextsSemanticallySimilar(String expected, String actual, double threshold) {
        LOGGER.debug("Analyzing semantic similarity between: '{}' and '{}'", expected, actual);
        
        if (expected == null || actual == null) {
            return expected == actual;
        }
        
        if (expected.equals(actual)) {
            return true;
        }
        
        // Extract key concepts (nouns, verbs, numbers, named entities)
        Map<String, Integer> expectedConcepts = extractKeyConcepts(expected);
        Map<String, Integer> actualConcepts = extractKeyConcepts(actual);
        
        // Calculate concept overlap
        double conceptSimilarity = calculateConceptSimilarity(expectedConcepts, actualConcepts);
        boolean similar = conceptSimilarity >= threshold;
        
        LOGGER.debug("Semantic similarity: {}, threshold: {}, similar: {}", 
                   conceptSimilarity, threshold, similar);
        
        return similar;
    }
    
    /**
     * Extracts key concepts from text for semantic comparison.
     * 
     * @param text The input text
     * @return Map of concepts and their frequencies
     */
    private Map<String, Integer> extractKeyConcepts(String text) {
        Map<String, Integer> concepts = new HashMap<>();
        
        // Extract entities (words starting with uppercase after space)
        Pattern entityPattern = Pattern.compile("\\s([A-Z][a-z]+)");
        Matcher entityMatcher = entityPattern.matcher(" " + text);
        while (entityMatcher.find()) {
            String entity = entityMatcher.group(1);
            concepts.put(entity, concepts.getOrDefault(entity, 0) + 3); // Higher weight for entities
        }
        
        // Extract numbers
        Pattern numberPattern = Pattern.compile("\\d+(\\.\\d+)?");
        Matcher numberMatcher = numberPattern.matcher(text);
        while (numberMatcher.find()) {
            String number = numberMatcher.group();
            concepts.put(number, concepts.getOrDefault(number, 0) + 2); // Higher weight for numbers
        }
        
        // Extract nouns and verbs (simplified by looking at word length)
        String[] words = text.toLowerCase().split("\\W+");
        for (String word : words) {
            if (word.length() > 3) { // Assume more meaningful words are longer
                concepts.put(word, concepts.getOrDefault(word, 0) + 1);
            }
        }
        
        return concepts;
    }
    
    /**
     * Calculates similarity between concept maps.
     * 
     * @param concepts1 The first concept map
     * @param concepts2 The second concept map
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateConceptSimilarity(Map<String, Integer> concepts1, Map<String, Integer> concepts2) {
        int totalWeight1 = concepts1.values().stream().mapToInt(Integer::intValue).sum();
        int totalWeight2 = concepts2.values().stream().mapToInt(Integer::intValue).sum();
        
        if (totalWeight1 == 0 || totalWeight2 == 0) {
            return 0.0;
        }
        
        int sharedWeight = 0;
        for (Map.Entry<String, Integer> entry : concepts1.entrySet()) {
            String concept = entry.getKey();
            int weight1 = entry.getValue();
            int weight2 = concepts2.getOrDefault(concept, 0);
            sharedWeight += Math.min(weight1, weight2);
        }
        
        // Calculate F1-like score
        double precision = (double) sharedWeight / totalWeight1;
        double recall = (double) sharedWeight / totalWeight2;
        
        if (precision + recall == 0) {
            return 0.0;
        }
        
        return 2 * precision * recall / (precision + recall);
    }
    
    /**
     * Analyzes sentiment of the given text.
     * 
     * @param text The text to analyze
     * @return The sentiment result (POSITIVE, NEGATIVE, NEUTRAL)
     */
    public CSSmartSentiment analyzeSentiment(String text) {
        LOGGER.debug("Analyzing sentiment for text: '{}'", text);
        
        if (text == null || text.isEmpty()) {
            return CSSmartSentiment.NEUTRAL;
        }
        
        // Simple rule-based sentiment analysis
        int positiveScore = 0;
        int negativeScore = 0;
        
        // Positive patterns
        positiveScore += countPatternMatches(text, "\\b(good|great|excellent|awesome|nice|happy|like|love|best|beautiful|perfect|recommended|enjoyed)\\b");
        positiveScore += countPatternMatches(text, "\\b(success|successful|works|working|passed|resolved)\\b");
        positiveScore += countPatternMatches(text, ":-\\)|:\\)|😊|👍|❤️");
        
        // Negative patterns
        negativeScore += countPatternMatches(text, "\\b(bad|poor|terrible|awful|horrible|hate|dislike|worst|ugly|failure|failed)\\b");
        negativeScore += countPatternMatches(text, "\\b(error|bug|issue|problem|crash|not working|doesn't work|broken|fail)\\b");
        negativeScore += countPatternMatches(text, ":-\\(|:\\(|😞|👎|❌");
        
        // Check for negation
        int negationCount = countPatternMatches(text, "\\b(not|no|never|neither|nor|without)\\b");
        
        // Adjust scores based on negation
        if (negationCount > 0) {
            int temp = positiveScore;
            positiveScore = negativeScore;
            negativeScore = temp;
        }
        
        // Determine sentiment
        CSSmartSentiment sentiment;
        if (positiveScore > negativeScore * 1.5) {
            sentiment = CSSmartSentiment.POSITIVE;
        } else if (negativeScore > positiveScore * 1.5) {
            sentiment = CSSmartSentiment.NEGATIVE;
        } else {
            sentiment = CSSmartSentiment.NEUTRAL;
        }
        
        LOGGER.debug("Sentiment analysis result: {} (positive: {}, negative: {})", 
                   sentiment, positiveScore, negativeScore);
        
        return sentiment;
    }
    
    /**
     * Counts the number of pattern matches in text.
     * 
     * @param text The text to search in
     * @param patternRegex The regex pattern to search for
     * @return The number of matches
     */
    private int countPatternMatches(String text, String patternRegex) {
        Pattern pattern = Pattern.compile(patternRegex, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(text);
        
        int count = 0;
        while (matcher.find()) {
            count++;
        }
        
        return count;
    }
    
    /**
     * Checks if an element is likely to be an important functional element.
     * 
     * @param element The web element to check
     * @return true if important, false otherwise
     */
    public boolean isImportantElement(WebElement element) {
        // Get element attributes
        String tagName = element.getTagName().toLowerCase();
        String type = element.getAttribute("type");
        if (type != null) {
            type = type.toLowerCase();
        }
        String className = element.getAttribute("class");
        String id = element.getAttribute("id");
        String text = element.getText();
        
        // Check tag types that are typically interactive or important
        if ("button".equals(tagName) || "a".equals(tagName) || "input".equals(tagName) ||
            "select".equals(tagName) || "textarea".equals(tagName)) {
            return true;
        }
        
        // Check input types that are interactive
        if ("input".equals(tagName) && 
            ("submit".equals(type) || "button".equals(type) || "checkbox".equals(type) || 
             "radio".equals(type) || "text".equals(type) || "password".equals(type))) {
            return true;
        }
        
        // Check for elements that look like buttons or links by class/id/role
        if ((className != null && (className.contains("btn") || className.contains("button") || 
                                 className.contains("link") || className.contains("nav"))) ||
            (id != null && (id.contains("btn") || id.contains("button") || 
                          id.contains("link") || id.contains("nav")))) {
            return true;
        }
        
        // Check by common UI text patterns for buttons/links
        if (text != null && !text.isEmpty() && 
            (text.matches("(?i).*\\b(submit|save|cancel|delete|edit|view|add|remove|login|logout|sign in|next|previous)\\b.*"))) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Suggests elements to interact with based on desired action.
     * 
     * @param elements List of available web elements
     * @param action Description of desired action
     * @return The most likely element to use, or null if none found
     */
    public WebElement suggestElementForAction(List<WebElement> elements, String action) {
        LOGGER.debug("Suggesting element for action: '{}'", action);
        
        if (elements == null || elements.isEmpty() || action == null || action.isEmpty()) {
            return null;
        }
        
        // Normalize action text
        String normalizedAction = action.toLowerCase();
        
        // Score each element based on relevance to the action
        WebElement bestElement = null;
        double bestScore = 0.0;
        
        for (WebElement element : elements) {
            double score = calculateElementRelevance(element, normalizedAction);
            
            if (score > bestScore) {
                bestScore = score;
                bestElement = element;
            }
        }
        
        // Require a minimum score to consider it a match
        if (bestScore < 0.3) {
            LOGGER.debug("No suitable element found for action");
            return null;
        }
        
        LOGGER.debug("Suggested element for action with score {}: {}", 
                   bestScore, elementToString(bestElement));
        
        return bestElement;
    }
    
    /**
     * Calculates relevance score of an element for a given action.
     * 
     * @param element The web element
     * @param action The action description
     * @return Relevance score (0.0 to 1.0)
     */
    private double calculateElementRelevance(WebElement element, String action) {
        double score = 0.0;
        
        // Get element attributes
        String tagName = element.getTagName().toLowerCase();
        String type = element.getAttribute("type");
        if (type != null) {
            type = type.toLowerCase();
        }
        String id = element.getAttribute("id");
        String className = element.getAttribute("class");
        String name = element.getAttribute("name");
        String value = element.getAttribute("value");
        String text = element.getText();
        String placeholder = element.getAttribute("placeholder");
        
        // Action keywords mapping to element types
        if ((action.contains("click") || action.contains("press") || action.contains("select") || 
             action.contains("choose") || action.contains("submit")) && 
            ("button".equals(tagName) || "a".equals(tagName) || 
             ("input".equals(tagName) && ("submit".equals(type) || "button".equals(type))))) {
            score += 0.3;
        }
        
        if ((action.contains("type") || action.contains("enter") || action.contains("input") || 
             action.contains("fill")) && 
            ("input".equals(tagName) || "textarea".equals(tagName))) {
            score += 0.3;
        }
        
        if ((action.contains("check") || action.contains("uncheck")) && 
            ("input".equals(tagName) && "checkbox".equals(type))) {
            score += 0.3;
        }
        
        if ((action.contains("select") || action.contains("choose") || action.contains("dropdown")) && 
            "select".equals(tagName)) {
            score += 0.3;
        }
        
        // Text content matching
        if (text != null && !text.isEmpty()) {
            String[] actionWords = action.split("\\s+");
            for (String word : actionWords) {
                if (word.length() > 3 && 
                    (text.toLowerCase().contains(word) || 
                     (value != null && value.toLowerCase().contains(word)))) {
                    score += 0.2;
                    break;
                }
            }
        }
        
        // Attribute name matching
        if ((id != null && containsAnyKeyword(id.toLowerCase(), action)) ||
            (name != null && containsAnyKeyword(name.toLowerCase(), action)) ||
            (placeholder != null && containsAnyKeyword(placeholder.toLowerCase(), action))) {
            score += 0.2;
        }
        
        // Visible and enabled status
        try {
            if (element.isDisplayed()) {
                score += 0.1;
            } else {
                score -= 0.2; // Penalize non-visible elements
            }
            
            if (element.isEnabled()) {
                score += 0.1;
            } else {
                score -= 0.2; // Penalize disabled elements
            }
        } catch (Exception e) {
            // Ignore errors when checking element state
        }
        
        return Math.min(1.0, Math.max(0.0, score));
    }
    
    /**
     * Checks if a string contains any keyword from a space-separated list.
     * 
     * @param str The string to check
     * @param keywords Space-separated keywords
     * @return true if any keyword is found, false otherwise
     */
    private boolean containsAnyKeyword(String str, String keywords) {
        String[] words = keywords.split("\\s+");
        for (String word : words) {
            if (word.length() > 3 && str.contains(word)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Converts an element to a readable string representation.
     * 
     * @param element The web element
     * @return String representation
     */
    private String elementToString(WebElement element) {
        if (element == null) {
            return "null";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(element.getTagName());
        
        String id = element.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            sb.append("#").append(id);
        }
        
        String className = element.getAttribute("class");
        if (className != null && !className.isEmpty()) {
            sb.append(".").append(className.replace(" ", "."));
        }
        
        String text = element.getText();
        if (text != null && !text.isEmpty()) {
            if (text.length() > 20) {
                text = text.substring(0, 17) + "...";
            }
            sb.append("[text='").append(text).append("']");
        }
        
        return sb.toString();
    }
    
    /**
     * Analyzes UI accessibility issues based on WCAG guidelines.
     * 
     * @param element The web element to analyze
     * @return Map of identified issues and their severity
     */
    public Map<String, CSSmartSeverity> analyzeAccessibility(WebElement element) {
        Map<String, CSSmartSeverity> issues = new HashMap<>();
        
        try {
            // Check alt text for images
            if ("img".equals(element.getTagName().toLowerCase())) {
                String altText = element.getAttribute("alt");
                if (altText == null || altText.isEmpty()) {
                    issues.put("Missing alt text for image", CSSmartSeverity.HIGH);
                }
            }
            
            // Check for proper labels on form elements
            if ("input".equals(element.getTagName().toLowerCase()) || 
                "select".equals(element.getTagName().toLowerCase()) || 
                "textarea".equals(element.getTagName().toLowerCase())) {
                
                String id = element.getAttribute("id");
                String ariaLabel = element.getAttribute("aria-label");
                String ariaLabelledBy = element.getAttribute("aria-labelledby");
                String title = element.getAttribute("title");
                
                if ((id == null || id.isEmpty()) && 
                    (ariaLabel == null || ariaLabel.isEmpty()) && 
                    (ariaLabelledBy == null || ariaLabelledBy.isEmpty()) && 
                    (title == null || title.isEmpty())) {
                    issues.put("Form element lacks proper labeling", CSSmartSeverity.MEDIUM);
                }
            }
            
            // Check contrast (simplified check for very light text on light background)
            String color = element.getCssValue("color");
            String bgColor = element.getCssValue("background-color");
            
            if ((color != null && bgColor != null) && 
                (color.contains("255, 255, 255") && bgColor.contains("255, 255, 2"))) {
                issues.put("Potential low contrast issue", CSSmartSeverity.LOW);
            }
            
            // Check for proper roles on interactive elements
            if (isImportantElement(element)) {
                String role = element.getAttribute("role");
                if (role == null || role.isEmpty()) {
                    String tag = element.getTagName().toLowerCase();
                    if (!"a".equals(tag) && !"button".equals(tag) && !"input".equals(tag) && 
                        !"select".equals(tag) && !"textarea".equals(tag)) {
                        issues.put("Interactive element missing role attribute", CSSmartSeverity.MEDIUM);
                    }
                }
            }
            
        } catch (Exception e) {
            LOGGER.warn("Error during accessibility analysis", e);
        }
        
        return issues;
    }
}


package com.cssmart.core.ai;

/**
 * Enum representing sentiment analysis results.
 */
public enum CSSmartSentiment {
    /**
     * Positive sentiment.
     */
    POSITIVE,
    
    /**
     * Negative sentiment.
     */
    NEGATIVE,
    
    /**
     * Neutral sentiment.
     */
    NEUTRAL
}


package com.cssmart.core.ai;

/**
 * Enum representing issue severity levels.
 */
public enum CSSmartSeverity {
    /**
     * High severity issue that should be addressed immediately.
     */
    HIGH,
    
    /**
     * Medium severity issue that should be addressed soon.
     */
    MEDIUM,
    
    /**
     * Low severity issue that should be noted for future improvement.
     */
    LOW
}

package com.cssmart.core.ai;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.regex.Pattern;

/**
 * Intelligent element finder that uses natural language descriptions to locate elements.
 */
public class CSSmartAIElementFinder {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartAIElementFinder.class);
    
    private final CSSmartDriver driver;
    private final CSSmartConfig config;
    private final CSSmartAIAnalyzer analyzer;
    
    /**
     * Constructs a new CSSmartAIElementFinder with the specified driver and configuration.
     * 
     * @param driver The CSSmartDriver
     * @param config The framework configuration
     */
    public CSSmartAIElementFinder(CSSmartDriver driver, CSSmartConfig config) {
        this.driver = driver;
        this.config = config;
        this.analyzer = new CSSmartAIAnalyzer(config);
    }
    
    /**
     * Finds an element by natural language description.
     * 
     * @param description The element description
     * @return The found web element
     * @throws CSSmartElementNotFoundException if element cannot be found
     */
    public WebElement findElementByDescription(String description) {
        LOGGER.info("Finding element by description: {}", description);
        
        // Get all visible elements on the page
        List<WebElement> candidates = driver.findElements(By.xpath("//*[not(self::script) and not(self::style)]"));
        
        // Filter only visible elements
        List<WebElement> visibleElements = new ArrayList<>();
        for (WebElement element : candidates) {
            try {
                if (element.isDisplayed()) {
                    visibleElements.add(element);
                }
            } catch (Exception e) {
                // Ignore errors when checking visibility
            }
        }
        
        // Score elements based on relevance to description
        WebElement bestMatch = null;
        double bestScore = 0.0;
        
        for (WebElement element : visibleElements) {
            double score = scoreElementMatch(element, description);
            
            if (score > bestScore) {
                bestScore = score;
                bestMatch = element;
            }
        }
        
        // Require a minimum score to consider it a match
        double threshold = config.getDouble("ai.element.finder.threshold", 0.4);
        if (bestScore < threshold) {
            LOGGER.warn("No element found matching description: {}", description);
            throw new CSSmartElementNotFoundException(
                "No element found matching description: " + description, By.xpath("*"));
        }
        
        LOGGER.info("Found element matching description with score {}: {}", 
                  bestScore, elementToString(bestMatch));
        
        return bestMatch;
    }
    
    /**
     * Scores an element's match against a natural language description.
     * 
     * @param element The web element
     * @param description The element description
     * @return Score (0.0 to 1.0) indicating match quality
     */
    private double scoreElementMatch(WebElement element, String description) {
        double score = 0.0;
        String normalizedDescription = description.toLowerCase();
        
        try {
            // Get element attributes
            String tagName = element.getTagName().toLowerCase();
            String id = element.getAttribute("id");
            String className = element.getAttribute("class");
            String name = element.getAttribute("name");
            String type = element.getAttribute("type");
            String placeholder = element.getAttribute("placeholder");
            String value = element.getAttribute("value");
            String href = element.getAttribute("href");
            String text = element.getText();
            String ariaLabel = element.getAttribute("aria-label");
            
            // Element type matching
            if (normalizedDescription.contains("button")) {
                if ("button".equals(tagName) || 
                    ("input".equals(tagName) && ("submit".equals(type) || "button".equals(type)))) {
                    score += 0.3;
                } else if ((className != null && (className.contains("btn") || className.contains("button"))) ||
                           (id != null && (id.contains("btn") || id.contains("button")))) {
                    score += 0.2;
                }
            }
            
            if (normalizedDescription.contains("link")) {
                if ("a".equals(tagName) || (href != null && !href.isEmpty())) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("input") || 
                normalizedDescription.contains("field") || 
                normalizedDescription.contains("text") || 
                normalizedDescription.contains("box")) {
                if ("input".equals(tagName) || "textarea".equals(tagName)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("image")) {
                if ("img".equals(tagName)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("dropdown") || 
                normalizedDescription.contains("select")) {
                if ("select".equals(tagName)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("checkbox")) {
                if ("input".equals(tagName) && "checkbox".equals(type)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("radio")) {
                if ("input".equals(tagName) && "radio".equals(type)) {
                    score += 0.3;
                }
            }
            
            // Text content matching
            if (text != null && !text.isEmpty()) {
                // Exact text match gets highest score
                if (text.equalsIgnoreCase(description)) {
                    score += 0.8;
                }
                // Text contains description
                else if (text.toLowerCase().contains(normalizedDescription)) {
                    score += 0.6;
                }
                // Description contains text (partial)
                else if (normalizedDescription.contains(text.toLowerCase())) {
                    score += 0.4;
                }
                // Words in description match words in text
                else {
                    Set<String> descWords = new HashSet<>(
                        Arrays.asList(normalizedDescription.split("\\s+")));
                    Set<String> textWords = new HashSet<>(
                        Arrays.asList(text.toLowerCase().split("\\s+")));
                    
                    // Count matching words
                    int matchCount = 0;
                    for (String word : descWords) {
                        if (word.length() > 2 && textWords.contains(word)) {
                            matchCount++;
                        }
                    }
                    
                    if (matchCount > 0) {
                        score += 0.2 * Math.min(1.0, (double) matchCount / descWords.size());
                    }
                }
            }
            
            // Attribute matching (ID, name, placeholder, aria-label)
            if (id != null && !id.isEmpty()) {
                if (id.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (containsWords(id.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (name != null && !name.isEmpty()) {
                if (name.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (containsWords(name.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (placeholder != null && !placeholder.isEmpty()) {
                if (placeholder.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (placeholder.toLowerCase().contains(normalizedDescription)) {
                    score += 0.4;
                } else if (containsWords(placeholder.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (ariaLabel != null && !ariaLabel.isEmpty()) {
                if (ariaLabel.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (ariaLabel.toLowerCase().contains(normalizedDescription)) {
                    score += 0.4;
                } else if (containsWords(ariaLabel.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (value != null && !value.isEmpty()) {
                if (value.equalsIgnoreCase(description)) {
                    score += 0.4;
                } else if (containsWords(value.toLowerCase(), normalizedDescription)) {
                    score += 0.2;
                }
            }
            
            // Additional context matching for buttons
            if ("button".equals(tagName) || 
                ("input".equals(tagName) && ("submit".equals(type) || "button".equals(type)))) {
                
                // Button descriptions often contain action words
                String[] actionWords = {"click", "press", "submit", "save", "cancel", "ok", "next", "previous"};
                for (String action : actionWords) {
                    if (normalizedDescription.contains(action)) {
                        score += 0.1;
                        break;
                    }
                }
            }
            
        } catch (Exception e) {
            // Ignore errors when checking element properties
            return 0.0;
        }
        
        return Math.min(1.0, score);
    }
    
    /**
     * Finds elements that match a specified semantic concept or category.
     * 
     * @param concept The semantic concept (e.g., "navigation", "main content", "footer")
     * @return List of matching elements
     */
    public List<WebElement> findElementsByCategory(String concept) {
        LOGGER.info("Finding elements by category: {}", concept);
        
        List<WebElement> results = new ArrayList<>();
        String normalizedConcept = concept.toLowerCase();
        
        // Define common patterns for different semantic categories
        if (normalizedConcept.contains("navigation") || normalizedConcept.contains("menu")) {
            results.addAll(driver.findElements(By.xpath(
                "//nav | //ul[contains(@class, 'nav') or contains(@class, 'menu')] | " +
                "//div[contains(@class, 'nav') or contains(@class, 'menu')] | " +
                "//header//ul | //header//ol | //*[@role='navigation']")));
        }
        else if (normalizedConcept.contains("header") || normalizedConcept.contains("banner")) {
            results.addAll(driver.findElements(By.xpath(
                "//header | //div[contains(@class, 'header') or contains(@id, 'header')] | " +
                "//*[@role='banner']")));
        }
        else if (normalizedConcept.contains("footer")) {
            results.addAll(driver.findElements(By.xpath(
                "//footer | //div[contains(@class, 'footer') or contains(@id, 'footer')] | " +
                "//*[@role='contentinfo']")));
        }
        else if (normalizedConcept.contains("main") || normalizedConcept.contains("content")) {
            results.addAll(driver.findElements(By.xpath(
                "//main | //div[contains(@class, 'main') or contains(@class, 'content') or " +
                "contains(@id, 'main') or contains(@id, 'content')] | //*[@role='main']")));
        }
        else if (normalizedConcept.contains("sidebar") || normalizedConcept.contains("aside")) {
            results.addAll(driver.findElements(By.xpath(
                "//aside | //div[contains(@class, 'sidebar') or contains(@class, 'aside') or " +
                "contains(@id, 'sidebar')] | //*[@role='complementary']")));
        }
        else if (normalizedConcept.contains("form")) {
            results.addAll(driver.findElements(By.xpath(
                "//form | //div[contains(@class, 'form')] | //*[@role='form']")));
        }
        else if (normalizedConcept.contains("search")) {
            results.addAll(driver.findElements(By.xpath(
                "//input[@type='search'] | //form[contains(@class, 'search') or " +
                "contains(@id, 'search')] | //*[@role='search']")));
        }
        else if (normalizedConcept.contains("button") || normalizedConcept.contains("action")) {
            results.addAll(driver.findElements(By.xpath(
                "//button | //input[@type='button' or @type='submit'] | " +
                "//a[contains(@class, 'btn') or contains(@class, 'button')] | " +
                "//div[contains(@class, 'btn') or contains(@class, 'button')] | " +
                "//*[@role='button']")));
        }
        else if (normalizedConcept.contains("image") || normalizedConcept.contains("picture")) {
            results.addAll(driver.findElements(By.xpath("//img | //picture | //*[@role='img']")));
        }
        else if (normalizedConcept.contains("video") || normalizedConcept.contains("media")) {
            results.addAll(driver.findElements(By.xpath(
                "//video | //audio | //*[contains(@class, 'video') or " +
                "contains(@class, 'media')] | //*[@role='video']")));
        }
        else if (normalizedConcept.contains("table") || normalizedConcept.contains("data")) {
            results.addAll(driver.findElements(By.xpath("//table | //*[@role='table' or @role='grid']")));
        }
        else if (normalizedConcept.contains("link")) {
            results.addAll(driver.findElements(By.xpath("//a")));
        }
        else if (normalizedConcept.contains("input") || normalizedConcept.contains("field")) {
            results.addAll(driver.findElements(By.xpath(
                "//input | //textarea | //select | //button | " +
                "//*[@role='textbox' or @role='combobox' or @role='checkbox' or @role='radio']")));
        }
        else {
            // If no specific category is matched, try to find elements with matching text
            results.addAll(driver.findElements(By.xpath(
                "//*[contains(text(), '" + concept + "') or contains(@class, '" + concept + "') or " +
                "contains(@id, '" + concept + "')]")));
        }
        
        // Filter to only displayed elements
        results.removeIf(element -> {
            try {
                return !element.isDisplayed();
            } catch (Exception e) {
                return true;
            }
        });
        
        LOGGER.info("Found {} elements matching category: {}", results.size(), concept);
        return results;
    }
    
    /**
     * Checks if a string contains words from a space-separated phrase.
     * 
     * @param str The string to check
     * @param phrase The phrase with words to find
     * @return true if any word is found, false otherwise
     */
    private boolean containsWords(String str, String phrase) {
        String[] words = phrase.split("\\s+");
        for (String word : words) {
            if (word.length() > 2 && (str.contains(word) || 
                Pattern.compile("\\b" + word + "\\b").matcher(str).find())) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Converts an element to a readable string representation.
     * 
     * @param element The web element
     * @return String representation
     */
    private String elementToString(WebElement element) {
        if (element == null) {
            return "null";
        }
        
        StringBuilder sb = new StringBuilder();
        try {
            sb.append(element.getTagName());
            
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                sb.append("#").append(id);
            }
            
            String className = element.getAttribute("class");
            if (className != null && !className.isEmpty()) {
                sb.append(".").append(className.replace(" ", "."));
            }
            
            String text = element.getText();
            if (text != null && !text.isEmpty()) {
                if (text.length() > 20) {
                    text = text.substring(0, 17) + "...";
                }
                sb.append("[text='").append(text).append("']");
            }
        } catch (Exception e) {
            return element.toString();
        }
        
        return sb.toString();
    }
}


package com.cssmart.core.test;

import com.cssmart.core.ai.CSSmartAIAnalyzer;
import com.cssmart.core.ai.CSSmartAIElementFinder;
import com.cssmart.core.ai.CSSmartSentiment;
import com.cssmart.core.ai.CSSmartSeverity;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.driver.BrowserManager;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.CSSmartScreenshot;
import org.openqa.selenium.WebElement;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Base class for AI-assisted test classes.
 * Provides enhanced testing capabilities with intelligent analysis and verification.
 */
public abstract class CSSmartAITestBase {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartAITestBase.class);
    private static final CSSmartReport REPORT = new CSSmartReport("AI-Assisted Test Report", "CSSmart AI Test Results");
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    protected CSSmartConfig config;
    protected CSSmartDriver driver;
    protected CSSmartScreenshot screenshot;
    protected CSSmartAIAnalyzer aiAnalyzer;
    protected CSSmartAIElementFinder aiFinder;
    
    /**
     * Setup operations before the test suite runs.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp() {
        LOGGER.info("Setting up AI test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Browser", config.getString("browser.type", "chrome"))
              .addEnvironmentInfo("Environment", config.getString("env", "test"))
              .addEnvironmentInfo("Base URL", config.getString("base.url", ""))
              .addEnvironmentInfo("AI Features", "Enabled");
        
        LOGGER.info("AI test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down AI test suite");
        
        // Quit all browser instances
        BrowserManager.quitAllDrivers();
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("AI test report generated: {}", reportPath);
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param method The test method
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(Method method) {
        String testName = method.getName();
        String testClass = method.getDeclaringClass().getSimpleName();
        
        LOGGER.info("Setting up AI test: {}.{}", testClass, testName);
        
        // Create driver if not already created
        if (driver == null) {
            driver = new BrowserManager(config).createDriver();
        }
        
        // Initialize screenshot utility
        screenshot = new CSSmartScreenshot(driver);
        
        // Initialize AI components
        aiAnalyzer = new CSSmartAIAnalyzer(config);
        aiFinder = new CSSmartAIElementFinder(driver, config);
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(testName, testClass, CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        LOGGER.info("AI test setup complete: {}.{}", testClass, testName);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String testClass = result.getTestClass().getName();
        
        LOGGER.info("Tearing down AI test: {}.{}", testClass, testName);
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        // Take screenshot on failure
                        if (driver != null) {
                            String screenshotPath = screenshot.takeScreenshot("failure_" + testName);
                            testResult.addFailStep("Test failed: " + result.getThrowable().getMessage())
                                      .getSteps().get(testResult.getSteps().size() - 1)
                                      .setScreenshotPath(screenshotPath);
                        }
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("AI test complete: {}.{} with status {}", testClass, testName, 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Gets the current test result for the executing thread.
     * 
     * @return The test result
     */
    protected CSSmartTestResult getCurrentTestResult() {
        return TEST_RESULTS.get(Thread.currentThread().getId());
    }
    
    /**
     * Finds an element by natural language description.
     * 
     * @param description The element description
     * @return The found web element
     */
    protected WebElement findByDescription(String description) {
        LOGGER.info("Finding element by description: {}", description);
        WebElement element = aiFinder.findElementByDescription(description);
        logIntelligentAction("Found element by description: " + description);
        return element;
    }
    
    /**
     * Finds elements that match a semantic category.
     * 
     * @param category The semantic category
     * @return List of matching elements
     */
    protected List<WebElement> findByCategory(String category) {
        LOGGER.info("Finding elements by category: {}", category);
        List<WebElement> elements = aiFinder.findElementsByCategory(category);
        logIntelligentAction("Found " + elements.size() + " elements in category: " + category);
        return elements;
    }
    
    /**
     * Verifies if text content is semantically similar to expected value.
     * 
     * @param expectedText The expected text content
     * @param actualText The actual text content
     * @param threshold The similarity threshold (0.0 to 1.0)
     * @return true if similar, false otherwise
     */
    protected boolean verifyTextSemanticallySimilar(String expectedText, String actualText, double threshold) {
        LOGGER.info("Verifying semantic similarity between texts");
        
        boolean similar = aiAnalyzer.areTextsSemanticallySimilar(expectedText, actualText, threshold);
        double similarity = aiAnalyzer.calculateJaccardSimilarity(expectedText, actualText);
        
        if (similar) {
            logPass("Text is semantically similar (score: " + String.format("%.2f", similarity) + 
                   ", threshold: " + threshold + ")");
        } else {
            logFail("Text is not semantically similar (score: " + String.format("%.2f", similarity) + 
                   ", threshold: " + threshold + ")");
        }
        
        return similar;
    }
    
    /**
     * Analyzes the sentiment of text content.
     * 
     * @param text The text to analyze
     * @return The sentiment result
     */
    protected CSSmartSentiment analyzeSentiment(String text) {
        LOGGER.info("Analyzing sentiment of text: {}", text);
        
        CSSmartSentiment sentiment = aiAnalyzer.analyzeSentiment(text);
        logIntelligentAction("Text sentiment analysis: " + sentiment);
        
        return sentiment;
    }
    
    /**
     * Checks if a web element is an important functional element.
     * 
     * @param element The web element to check
     * @return true if important, false otherwise
     */
    protected boolean isImportantElement(WebElement element) {
        boolean important = aiAnalyzer.isImportantElement(element);
        logIntelligentAction("Element importance check: " + (important ? "Important" : "Not important"));
        return important;
    }
    
    /**
     * Suggests an element to use for a specific action from a list of candidates.
     * 
     * @param elements The list of candidate elements
     * @param action The desired action description
     * @return The suggested element, or null if none found
     */
    protected WebElement suggestElementForAction(List<WebElement> elements, String action) {
        LOGGER.info("Suggesting element for action: {}", action);
        
        WebElement element = aiAnalyzer.suggestElementForAction(elements, action);
        
        if (element != null) {
            logIntelligentAction("Suggested element for action '" + action + "': " + element.toString());
        } else {
            logIntelligentAction("No element suggested for action: " + action);
        }
        
        return element;
    }
    
    /**
     * Analyzes accessibility issues in a web element.
     * 
     * @param element The web element to analyze
     * @return Map of accessibility issues and their severity
     */
    protected Map<String, CSSmartSeverity> analyzeAccessibility(WebElement element) {
        LOGGER.info("Analyzing accessibility of element");
        
        Map<String, CSSmartSeverity> issues = aiAnalyzer.analyzeAccessibility(element);
        
        if (issues.isEmpty()) {
            logPass("No accessibility issues found");
        } else {
            StringBuilder issueDetails = new StringBuilder("Found accessibility issues:\n");
            issues.forEach((issue, severity) -> 
                issueDetails.append("- ").append(issue).append(" (").append(severity).append(")\n"));
            
            logWarning(issueDetails.toString());
        }
        
        return issues;
    }
    
    /**
     * Logs a test step with intelligent action information.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logIntelligentAction(String description) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            testResult.addInfoStep("AI: " + description);
        }
        
        return testResult;
    }
    
    /**
     * Logs a passed test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logPass(String description) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            testResult.addPassStep(description);
        }
        
        return testResult;
    }
    
    /**
     * Logs a failed test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logFail(String description) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            testResult.addFailStep(description);
        }
        
        return testResult;
    }
    
    /**
     * Logs a warning test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logWarning(String description) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            testResult.addWarningStep(description);
        }
        
        return testResult;
    }
    
    /**
     * Checks if a page appears to match an expected page based on key content.
     * 
     * @param expectedPageIndicators Keywords or phrases expected on the page
     * @return true if page appears to match, false otherwise
     */
    protected boolean verifyPageContentMatches(String... expectedPageIndicators) {
        LOGGER.info("Verifying page content matches expected indicators");
        
        if (expectedPageIndicators == null || expectedPageIndicators.length == 0) {
            return false;
        }
        
        String pageSource = driver.getDriver().getPageSource().toLowerCase();
        String pageText = driver.getDriver().findElement(org.openqa.selenium.By.tagName("body")).getText().toLowerCase();
        
        int matchCount = 0;
        StringBuilder matches = new StringBuilder();
        StringBuilder misses = new StringBuilder();
        
        for (String indicator : expectedPageIndicators) {
            String normalizedIndicator = indicator.toLowerCase();
            if (pageSource.contains(normalizedIndicator) || pageText.contains(normalizedIndicator)) {
                matchCount++;
                matches.append("- Found: '").append(indicator).append("'\n");
            } else {
                misses.append("- Not found: '").append(indicator).append("'\n");
            }
        }
        
        double matchPercentage = (double) matchCount / expectedPageIndicators.length;
        boolean matches85Percent = matchPercentage >= 0.85;
        
        if (matches85Percent) {
            logPass("Page content matches expected indicators (" + 
                   String.format("%.0f%%", matchPercentage * 100) + " match)\n" + matches.toString());
        } else {
            logFail("Page content does not match expected indicators (" + 
                   String.format("%.0f%%", matchPercentage * 100) + " match)\n" + 
                   matches.toString() + misses.toString());
        }
        
        return matches85Percent;
    }
}


package com.cssmart.core.bdd;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation to mark methods as BDD step definitions.
 * Supports Gherkin syntax with regex pattern matching.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSSmartStepDefinition {
    
    /**
     * The step pattern in regex format.
     * Should match Gherkin syntax (Given/When/Then).
     * @return The step pattern
     */
    String value();
    
    /**
     * The step type (Given, When, Then, And, But).
     * @return The step type
     */
    StepType type() default StepType.ANY;
    
    /**
     * Enum representing different types of BDD steps.
     */
    enum StepType {
        /**
         * Given step (precondition).
         */
        GIVEN,
        
        /**
         * When step (action).
         */
        WHEN,
        
        /**
         * Then step (verification).
         */
        THEN,
        
        /**
         * And step (additional conditions).
         */
        AND,
        
        /**
         * But step (exception conditions).
         */
        BUT,
        
        /**
         * Any step type.
         */
        ANY
    }
}


package com.cssmart.core.bdd;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Runner to execute BDD step definitions based on Gherkin syntax.
 */
public class CSSmartStepRunner {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartStepRunner.class);
    
    private final Object stepDefinitionInstance;
    private final Map<Pattern, Method> stepDefinitions = new HashMap<>();
    private final CSSmartTestResult testResult;
    
    /**
     * Constructs a new CSSmartStepRunner.
     * 
     * @param stepDefinitionInstance The instance containing step definition methods
     * @param testResult The test result for reporting
     */
    public CSSmartStepRunner(Object stepDefinitionInstance, CSSmartTestResult testResult) {
        this.stepDefinitionInstance = stepDefinitionInstance;
        this.testResult = testResult;
        
        // Register all step definitions from the instance
        registerStepDefinitions();
    }
    
    /**
     * Registers all step definition methods from the instance.
     */
    private void registerStepDefinitions() {
        LOGGER.debug("Registering step definitions from: {}", 
                   stepDefinitionInstance.getClass().getSimpleName());
        
        for (Method method : stepDefinitionInstance.getClass().getDeclaredMethods()) {
            CSSmartStepDefinition annotation = method.getAnnotation(CSSmartStepDefinition.class);
            
            if (annotation != null) {
                String pattern = annotation.value();
                Pattern compiledPattern = Pattern.compile(pattern);
                stepDefinitions.put(compiledPattern, method);
                
                LOGGER.debug("Registered step definition: {}", pattern);
            }
        }
        
        LOGGER.info("Registered {} step definitions", stepDefinitions.size());
    }
    
    /**
     * Executes a Gherkin step statement.
     * 
     * @param stepStatement The step statement to execute
     * @return true if executed successfully, false otherwise
     */
    public boolean executeStep(String stepStatement) {
        LOGGER.info("Executing step: {}", stepStatement);
        
        // Normalize step statement by removing leading Given/When/Then/And/But
        String normalizedStep = normalizeStepStatement(stepStatement);
        
        // Find matching step definition
        Map.Entry<Pattern, Method> matchingStep = findMatchingStepDefinition(normalizedStep);
        
        if (matchingStep == null) {
            String errorMessage = "No matching step definition found for: " + stepStatement;
            LOGGER.error(errorMessage);
            
            if (testResult != null) {
                testResult.addFailStep(stepStatement)
                          .setErrorMessage(errorMessage);
            }
            
            return false;
        }
        
        // Extract parameters from step
        List<String> parameters = extractStepParameters(matchingStep.getKey(), normalizedStep);
        
        // Execute step definition
        try {
            Method method = matchingStep.getValue();
            Object[] args = convertParameters(parameters, method);
            
            method.setAccessible(true);
            method.invoke(stepDefinitionInstance, args);
            
            if (testResult != null) {
                testResult.addPassStep(stepStatement);
            }
            
            LOGGER.debug("Step executed successfully: {}", stepStatement);
            return true;
            
        } catch (Exception e) {
            String errorMessage = "Error executing step: " + e.getMessage();
            LOGGER.error(errorMessage, e);
            
            if (testResult != null) {
                testResult.addFailStep(stepStatement)
                          .setErrorMessage(errorMessage);
            }
            
            if (e.getCause() instanceof CSSmartException) {
                throw (CSSmartException) e.getCause();
            } else {
                throw new CSSmartException("Failed to execute step: " + stepStatement, e);
            }
        }
    }
    
    /**
     * Executes a list of Gherkin steps.
     * 
     * @param steps The steps to execute
     * @return true if all steps executed successfully, false otherwise
     */
    public boolean executeSteps(List<String> steps) {
        LOGGER.info("Executing {} steps", steps.size());
        
        boolean allSuccess = true;
        
        for (String step : steps) {
            try {
                boolean success = executeStep(step);
                if (!success) {
                    allSuccess = false;
                    break;
                }
            } catch (Exception e) {
                LOGGER.error("Step execution failed: {}", step, e);
                
                if (testResult != null) {
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                }
                
                return false;
            }
        }
        
        return allSuccess;
    }
    
    /**
     * Normalizes a step statement by removing leading step type keywords.
     * 
     * @param stepStatement The original step statement
     * @return The normalized step statement
     */
    private String normalizeStepStatement(String stepStatement) {
        String trimmed = stepStatement.trim();
        
        // Remove leading step type (Given/When/Then/And/But)
        String[] stepTypes = {"Given", "When", "Then", "And", "But"};
        
        for (String stepType : stepTypes) {
            if (trimmed.startsWith(stepType + " ")) {
                return trimmed.substring(stepType.length()).trim();
            }
        }
        
        return trimmed;
    }
    
    /**
     * Finds a matching step definition for a normalized step statement.
     * 
     * @param normalizedStep The normalized step statement
     * @return The matching pattern and method, or null if no match found
     */
    private Map.Entry<Pattern, Method> findMatchingStepDefinition(String normalizedStep) {
        for (Map.Entry<Pattern, Method> entry : stepDefinitions.entrySet()) {
            Pattern pattern = entry.getKey();
            Matcher matcher = pattern.matcher(normalizedStep);
            
            if (matcher.matches()) {
                return entry;
            }
        }
        
        return null;
    }
    
    /**
     * Extracts parameters from a step statement based on the matching pattern.
     * 
     * @param pattern The matching pattern
     * @param normalizedStep The normalized step statement
     * @return List of extracted parameters
     */
    private List<String> extractStepParameters(Pattern pattern, String normalizedStep) {
        List<String> parameters = new ArrayList<>();
        Matcher matcher = pattern.matcher(normalizedStep);
        
        if (matcher.matches()) {
            for (int i = 1; i <= matcher.groupCount(); i++) {
                parameters.add(matcher.group(i));
            }
        }
        
        return parameters;
    }
    
    /**
     * Converts string parameters to the appropriate types for a method.
     * 
     * @param parameters The string parameters
     * @param method The method to invoke
     * @return Array of converted parameters
     */
    private Object[] convertParameters(List<String> parameters, Method method) {
        Class<?>[] paramTypes = method.getParameterTypes();
        Object[] args = new Object[paramTypes.length];
        
        for (int i = 0; i < paramTypes.length && i < parameters.size(); i++) {
            String param = parameters.get(i);
            Class<?> type = paramTypes[i];
            
            args[i] = convertParameter(param, type);
        }
        
        return args;
    }
    
    /**
     * Converts a string parameter to the specified type.
     * 
     * @param param The string parameter
     * @param type The target type
     * @return The converted parameter
     */
    private Object convertParameter(String param, Class<?> type) {
        if (type == String.class) {
            return param;
        } else if (type == int.class || type == Integer.class) {
            return Integer.parseInt(param);
        } else if (type == long.class || type == Long.class) {
            return Long.parseLong(param);
        } else if (type == double.class || type == Double.class) {
            return Double.parseDouble(param);
        } else if (type == boolean.class || type == Boolean.class) {
            return Boolean.parseBoolean(param);
        } else if (type == float.class || type == Float.class) {
            return Float.parseFloat(param);
        } else if (type.isEnum()) {
            return Enum.valueOf((Class<Enum>) type, param);
        } else {
            throw new CSSmartException("Unsupported parameter type: " + type.getName());
        }
    }
}


package com.cssmart.core.bdd;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Loader for BDD feature files in Gherkin syntax.
 */
public class CSSmartFeatureLoader {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartFeatureLoader.class);
    
    private static final Pattern FEATURE_PATTERN = Pattern.compile("Feature:(.*)");
    private static final Pattern SCENARIO_PATTERN = Pattern.compile("Scenario:(.*)");
    private static final Pattern SCENARIO_OUTLINE_PATTERN = Pattern.compile("Scenario Outline:(.*)");
    private static final Pattern EXAMPLES_PATTERN = Pattern.compile("Examples:.*");
    private static final Pattern TABLE_ROW_PATTERN = Pattern.compile("\\s*\\|(.*)\\|.*");
    private static final Pattern STEP_PATTERN = Pattern.compile("\\s*(Given|When|Then|And|But)(.*)");
    
    /**
     * Loads a feature file from the specified path.
     * 
     * @param featureFilePath The path to the feature file
     * @return The loaded feature
     */
    public CSSmartFeature loadFeature(String featureFilePath) {
        LOGGER.info("Loading feature file: {}", featureFilePath);
        
        try (BufferedReader reader = new BufferedReader(new FileReader(featureFilePath))) {
            String line;
            String featureTitle = null;
            String featureDescription = new StringBuilder().toString();
            List<CSSmartScenario> scenarios = new ArrayList<>();
            List<CSSmartScenarioOutline> scenarioOutlines = new ArrayList<>();
            
            CSSmartScenario currentScenario = null;
            CSSmartScenarioOutline currentScenarioOutline = null;
            boolean inExamples = false;
            List<String> exampleHeaders = null;
            List<Map<String, String>> examples = new ArrayList<>();
            
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                
                // Skip empty lines and comments
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }
                
                // Parse Feature
                Matcher featureMatcher = FEATURE_PATTERN.matcher(line);
                if (featureMatcher.matches()) {
                    featureTitle = featureMatcher.group(1).trim();
                    continue;
                }
                
                // Parse Scenario
                Matcher scenarioMatcher = SCENARIO_PATTERN.matcher(line);
                if (scenarioMatcher.matches()) {
                    // Finish previous scenario outline if any
                    if (currentScenarioOutline != null) {
                        if (!examples.isEmpty()) {
                            currentScenarioOutline.setExamples(examples);
                        }
                        scenarioOutlines.add(currentScenarioOutline);
                        currentScenarioOutline = null;
                        examples = new ArrayList<>();
                        exampleHeaders = null;
                        inExamples = false;
                    }
                    
                    // Start new scenario
                    String scenarioTitle = scenarioMatcher.group(1).trim();
                    currentScenario = new CSSmartScenario(scenarioTitle);
                    scenarios.add(currentScenario);
                    continue;
                }
                
                // Parse Scenario Outline
                Matcher scenarioOutlineMatcher = SCENARIO_OUTLINE_PATTERN.matcher(line);
                if (scenarioOutlineMatcher.matches()) {
                    // Finish previous scenario if any
                    if (currentScenario != null) {
                        scenarios.add(currentScenario);
                        currentScenario = null;
                    }
                    
                    // Start new scenario outline
                    String outlineTitle = scenarioOutlineMatcher.group(1).trim();
                    currentScenarioOutline = new CSSmartScenarioOutline(outlineTitle);
                    inExamples = false;
                    continue;
                }
                
                // Parse Steps
                Matcher stepMatcher = STEP_PATTERN.matcher(line);
                if (stepMatcher.matches()) {
                    String stepType = stepMatcher.group(1).trim();
                    String stepText = stepType + stepMatcher.group(2).trim();
                    
                    if (currentScenario != null) {
                        currentScenario.addStep(stepText);
                    } else if (currentScenarioOutline != null && !inExamples) {
                        currentScenarioOutline.addStep(stepText);
                    }
                    continue;
                }
                
                // Parse Examples
                Matcher examplesMatcher = EXAMPLES_PATTERN.matcher(line);
                if (examplesMatcher.matches() && currentScenarioOutline != null) {
                    inExamples = true;
                    continue;
                }
                
                // Parse Example table
                Matcher tableRowMatcher = TABLE_ROW_PATTERN.matcher(line);
                if (tableRowMatcher.matches() && inExamples) {
                    String[] cells = tableRowMatcher.group(1).split("\\|");
                    
                    // Trim each cell
                    for (int i = 0; i < cells.length; i++) {
                        cells[i] = cells[i].trim();
                    }
                    
                    if (exampleHeaders == null) {
                        // First row is headers
                        exampleHeaders = new ArrayList<>();
                        for (String cell : cells) {
                            exampleHeaders.add(cell.trim());
                        }
                    } else {
                        // Data rows
                        Map<String, String> exampleRow = new HashMap<>();
                        for (int i = 0; i < Math.min(cells.length, exampleHeaders.size()); i++) {
                            exampleRow.put(exampleHeaders.get(i), cells[i]);
                        }
                        examples.add(exampleRow);
                    }
                    continue;
                }
            }
            
            // Add the last scenario if any
            if (currentScenario != null) {
                scenarios.add(currentScenario);
            }
            
            // Add the last scenario outline if any
            if (currentScenarioOutline != null) {
                if (!examples.isEmpty()) {
                    currentScenarioOutline.setExamples(examples);
                }
                scenarioOutlines.add(currentScenarioOutline);
            }
            
            CSSmartFeature feature = new CSSmartFeature(featureTitle, featureDescription);
            feature.setScenarios(scenarios);
            feature.setScenarioOutlines(scenarioOutlines);
            
            LOGGER.info("Loaded feature: {} with {} scenarios and {} scenario outlines", 
                      featureTitle, scenarios.size(), scenarioOutlines.size());
            
            return feature;
            
        } catch (IOException e) {
            LOGGER.error("Error loading feature file: {}", featureFilePath, e);
            throw new CSSmartException("Error loading feature file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds all feature files in a directory.
     * 
     * @param directory The directory to search
     * @return List of feature file paths
     */
    public List<String> findFeatureFiles(String directory) {
        LOGGER.info("Finding feature files in directory: {}", directory);
        
        List<String> featureFiles = new ArrayList<>();
        
        try (Stream<Path> paths = Files.walk(Paths.get(directory))) {
            featureFiles = paths
                .filter(Files::isRegularFile)
                .filter(path -> path.toString().endsWith(".feature"))
                .map(Path::toString)
                .collect(Collectors.toList());
        } catch (IOException e) {
            LOGGER.error("Error finding feature files: {}", e.getMessage(), e);
            throw new CSSmartException("Error finding feature files: " + e.getMessage(), e);
        }
        
        LOGGER.info("Found {} feature files", featureFiles.size());
        return featureFiles;
    }
    
    /**
     * Loads all feature files in a directory.
     * 
     * @param directory The directory to search
     * @return List of loaded features
     */
    public List<CSSmartFeature> loadFeatures(String directory) {
        LOGGER.info("Loading all features from directory: {}", directory);
        
        List<String> featureFiles = findFeatureFiles(directory);
        List<CSSmartFeature> features = new ArrayList<>();
        
        for (String featureFile : featureFiles) {
            features.add(loadFeature(featureFile));
        }
        
        return features;
    }
}


package com.cssmart.core.bdd;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a BDD feature with scenarios and scenario outlines.
 */
public class CSSmartFeature {
    private final String title;
    private final String description;
    private List<CSSmartScenario> scenarios;
    private List<CSSmartScenarioOutline> scenarioOutlines;
    
    /**
     * Constructs a new CSSmartFeature.
     * 
     * @param title The feature title
     * @param description The feature description
     */
    public CSSmartFeature(String title, String description) {
        this.title = title;
        this.description = description;
        this.scenarios = new ArrayList<>();
        this.scenarioOutlines = new ArrayList<>();
    }
    
    /**
     * Gets the feature title.
     * 
     * @return The feature title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Gets the feature description.
     * 
     * @return The feature description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Gets the scenarios in this feature.
     * 
     * @return List of scenarios
     */
    public List<CSSmartScenario> getScenarios() {
        return scenarios;
    }
    
    /**
     * Sets the scenarios for this feature.
     * 
     * @param scenarios The scenarios to set
     */
    public void setScenarios(List<CSSmartScenario> scenarios) {
        this.scenarios = scenarios;
    }
    
    /**
     * Adds a scenario to this feature.
     * 
     * @param scenario The scenario to add
     */
    public void addScenario(CSSmartScenario scenario) {
        this.scenarios.add(scenario);
    }
    
    /**
     * Gets the scenario outlines in this feature.
     * 
     * @return List of scenario outlines
     */
    public List<CSSmartScenarioOutline> getScenarioOutlines() {
        return scenarioOutlines;
    }
    
    /**
     * Sets the scenario outlines for this feature.
     * 
     * @param scenarioOutlines The scenario outlines to set
     */
    public void setScenarioOutlines(List<CSSmartScenarioOutline> scenarioOutlines) {
        this.scenarioOutlines = scenarioOutlines;
    }
    
    /**
     * Adds a scenario outline to this feature.
     * 
     * @param scenarioOutline The scenario outline to add
     */
    public void addScenarioOutline(CSSmartScenarioOutline scenarioOutline) {
        this.scenarioOutlines.add(scenarioOutline);
    }
    
    /**
     * Gets all scenarios including those generated from scenario outlines.
     * 
     * @return List of all scenarios
     */
    public List<CSSmartScenario> getAllScenarios() {
        List<CSSmartScenario> allScenarios = new ArrayList<>(scenarios);
        
        for (CSSmartScenarioOutline outline : scenarioOutlines) {
            allScenarios.addAll(outline.generateScenarios());
        }
        
        return allScenarios;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Feature: ").append(title).append("\n");
        
        if (description != null && !description.isEmpty()) {
            sb.append(description).append("\n\n");
        }
        
        for (CSSmartScenario scenario : scenarios) {
            sb.append(scenario.toString()).append("\n\n");
        }
        
        for (CSSmartScenarioOutline outline : scenarioOutlines) {
            sb.append(outline.toString()).append("\n\n");
        }
        
        return sb.toString();
    }
}


package com.cssmart.core.bdd;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a BDD scenario with steps.
 */
public class CSSmartScenario {
    private final String title;
    private final List<String> steps;
    
    /**
     * Constructs a new CSSmartScenario.
     * 
     * @param title The scenario title
     */
    public CSSmartScenario(String title) {
        this.title = title;
        this.steps = new ArrayList<>();
    }
    
    /**
     * Gets the scenario title.
     * 
     * @return The scenario title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Gets the steps in this scenario.
     * 
     * @return List of steps
     */
    public List<String> getSteps() {
        return steps;
    }
    
    /**
     * Adds a step to this scenario.
     * 
     * @param step The step to add
     */
    public void addStep(String step) {
        this.steps.add(step);
    }
    
    /**
     * Sets the steps for this scenario.
     * 
     * @param steps The steps to set
     */
    public void setSteps(List<String> steps) {
        this.steps.clear();
        this.steps.addAll(steps);
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Scenario: ").append(title).append("\n");
        
        for (String step : steps) {
            sb.append("  ").append(step).append("\n");
        }
        
        return sb.toString();
    }
}


package com.cssmart.core.bdd;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Represents a BDD scenario outline with examples.
 */
public class CSSmartScenarioOutline {
    private final String title;
    private final List<String> steps;
    private List<Map<String, String>> examples;
    
    // Pattern to match parameters in steps (e.g., <username>)
    private static final Pattern PARAMETER_PATTERN = Pattern.compile("<([^>]+)>");
    
    /**
     * Constructs a new CSSmartScenarioOutline.
     * 
     * @param title The scenario outline title
     */
    public CSSmartScenarioOutline(String title) {
        this.title = title;
        this.steps = new ArrayList<>();
        this.examples = new ArrayList<>();
    }
    
    /**
     * Gets the scenario outline title.
     * 
     * @return The scenario outline title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Gets the steps in this scenario outline.
     * 
     * @return List of steps
     */
    public List<String> getSteps() {
        return steps;
    }
    
    /**
     * Adds a step to this scenario outline.
     * 
     * @param step The step to add
     */
    public void addStep(String step) {
        this.steps.add(step);
    }
    
    /**
     * Sets the steps for this scenario outline.
     * 
     * @param steps The steps to set
     */
    public void setSteps(List<String> steps) {
        this.steps.clear();
        this.steps.addAll(steps);
    }
    
    /**
     * Gets the examples for this scenario outline.
     * 
     * @return List of example maps
     */
    public List<Map<String, String>> getExamples() {
        return examples;
    }
    
    /**
     * Sets the examples for this scenario outline.
     * 
     * @param examples The examples to set
     */
    public void setExamples(List<Map<String, String>> examples) {
        this.examples = examples;
    }
    
    /**
     * Adds an example to this scenario outline.
     * 
     * @param example The example to add
     */
    public void addExample(Map<String, String> example) {
        this.examples.add(example);
    }
    
    /**
     * Generates scenarios by applying examples to the outline.
     * 
     * @return List of generated scenarios
     */
    public List<CSSmartScenario> generateScenarios() {
        List<CSSmartScenario> scenarios = new ArrayList<>();
        
        for (int i = 0; i < examples.size(); i++) {
            Map<String, String> example = examples.get(i);
            String scenarioTitle = title + " (Example " + (i + 1) + ")";
            CSSmartScenario scenario = new CSSmartScenario(scenarioTitle);
            
            // Apply example values to steps
            for (String outlineStep : steps) {
                String resolvedStep = resolveStep(outlineStep, example);
                scenario.addStep(resolvedStep);
            }
            
            scenarios.add(scenario);
        }
        
        return scenarios;
    }
    
    /**
     * Resolves a step by replacing parameters with values from an example.
     * 
     * @param step The step with parameters
     * @param example The example with values
     * @return The resolved step
     */
    private String resolveStep(String step, Map<String, String> example) {
        String resolvedStep = step;
        Matcher matcher = PARAMETER_PATTERN.matcher(step);
        
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            String paramName = matcher.group(1);
            String paramValue = example.getOrDefault(paramName, "<" + paramName + ">");
            matcher.appendReplacement(sb, Matcher.quoteReplacement(paramValue));
        }
        matcher.appendTail(sb);
        
        return sb.toString();
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Scenario Outline: ").append(title).append("\n");
        
        for (String step : steps) {
            sb.append("  ").append(step).append("\n");
        }
        
        sb.append("\n  Examples:\n");
        if (!examples.isEmpty()) {
            // Get headers from first example
            Map<String, String> firstExample = examples.get(0);
            sb.append("    |");
            for (String header : firstExample.keySet()) {
                sb.append(" ").append(header).append(" |");
            }
            sb.append("\n");
            
            // Add example rows
            for (Map<String, String> example : examples) {
                sb.append("    |");
                for (String header : firstExample.keySet()) {
                    sb.append(" ").append(example.getOrDefault(header, "")).append(" |");
                }
                sb.append("\n");
            }
        }
        
        return sb.toString();
    }
}


package com.cssmart.core.test;

import com.cssmart.core.bdd.CSSmartFeature;
import com.cssmart.core.bdd.CSSmartFeatureLoader;
import com.cssmart.core.bdd.CSSmartScenario;
import com.cssmart.core.bdd.CSSmartStepRunner;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.driver.BrowserManager;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.CSSmartScreenshot;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Base class for BDD-style tests using Gherkin syntax.
 */
public abstract class CSSmartBDDTestBase {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDTestBase.class);
    private static final CSSmartReport REPORT = new CSSmartReport("BDD Test Report", "CSSmart BDD Test Results");
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    protected CSSmartConfig config;
    protected CSSmartDriver driver;
    protected CSSmartScreenshot screenshot;
    protected CSSmartStepRunner stepRunner;
    protected CSSmartFeatureLoader featureLoader;
    
    /**
     * Gets the directory containing feature files.
     * 
     * @return The feature directory path
     */
    protected abstract String getFeatureDirectory();
    
    /**
     * Setup operations before the test suite runs.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp() {
        LOGGER.info("Setting up BDD test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Browser", config.getString("browser.type", "chrome"))
              .addEnvironmentInfo("Environment", config.getString("env", "test"))
              .addEnvironmentInfo("Base URL", config.getString("base.url", ""))
              .addEnvironmentInfo("Features", getFeatureDirectory());
        
        // Initialize feature loader
        featureLoader = new CSSmartFeatureLoader();
        
        LOGGER.info("BDD test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down BDD test suite");
        
        // Quit all browser instances
        BrowserManager.quitAllDrivers();
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("BDD test report generated: {}", reportPath);
    }
    
    /**
     * Creates a data provider for scenarios.
     * 
     * @return Array of scenario data
     */
    @DataProvider(name = "scenarios")
    public Object[][] scenarioDataProvider() {
        LOGGER.info("Creating data provider for scenarios");
        
        List<CSSmartFeature> features = featureLoader.loadFeatures(getFeatureDirectory());
        List<CSSmartScenario> allScenarios = new java.util.ArrayList<>();
        
        // Collect all scenarios from all features
        for (CSSmartFeature feature : features) {
            allScenarios.addAll(feature.getAllScenarios());
        }
        
        LOGGER.info("Found {} scenarios in total", allScenarios.size());
        
        // Create data provider array
        Object[][] data = new Object[allScenarios.size()][2];
        for (int i = 0; i < allScenarios.size(); i++) {
            CSSmartScenario scenario = allScenarios.get(i);
            data[i][0] = scenario.getTitle();
            data[i][1] = scenario;
        }
        
        return data;
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param scenarioTitle The scenario title
     * @param scenario The scenario to run
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(String scenarioTitle, CSSmartScenario scenario) {
        LOGGER.info("Setting up BDD test for scenario: {}", scenarioTitle);
        
        // Create driver if not already created
        if (driver == null) {
            driver = new BrowserManager(config).createDriver();
        }
        
        // Initialize screenshot utility
        screenshot = new CSSmartScreenshot(driver);
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(scenarioTitle, "BDD Scenario", CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        // Initialize step runner
        stepRunner = new CSSmartStepRunner(this, testResult);
        
        LOGGER.info("BDD test setup complete for scenario: {}", scenarioTitle);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        LOGGER.info("Tearing down BDD test: {}", result.getName());
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        // Take screenshot on failure
                        if (driver != null) {
                            String screenshotPath = screenshot.takeScreenshot("failure_" + result.getName());
                            testResult.addFailStep("Test failed: " + result.getThrowable().getMessage())
                                      .getSteps().get(testResult.getSteps().size() - 1)
                                      .setScreenshotPath(screenshotPath);
                        }
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("BDD test complete: {} with status {}", result.getName(), 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Runs a scenario.
     * 
     * @param scenarioTitle The scenario title
     * @param scenario The scenario to run
     */
    @Test(dataProvider = "scenarios")
    public void runScenario(String scenarioTitle, CSSmartScenario scenario) {
        LOGGER.info("Running scenario: {}", scenarioTitle);
        
        try {
            // Execute all steps in the scenario
            boolean success = stepRunner.executeSteps(scenario.getSteps());
            
            if (!success) {
                LOGGER.error("Scenario failed: {}", scenarioTitle);
                throw new CSSmartException("Scenario failed: " + scenarioTitle);
            }
            
            LOGGER.info("Scenario completed successfully: {}", scenarioTitle);
        } catch (Exception e) {
            LOGGER.error("Error executing scenario: {}", scenarioTitle, e);
            throw e;
        }
    }
    
    /**
     * Gets the current test result for the executing thread.
     * 
     * @return The test result
     */
    protected CSSmartTestResult getCurrentTestResult() {
        return TEST_RESULTS.get(Thread.currentThread().getId());
    }
}


<!-- Here are the dependencies required for our framework -->

<dependencies>
    <!-- Selenium Dependencies -->
    <dependency>
        <groupId>org.seleniumhq.selenium</groupId>
        <artifactId>selenium-java</artifactId>
        <version>4.12.0</version>
    </dependency>
    
    <!-- WebDriverManager for driver management -->
    <dependency>
        <groupId>io.github.bonigarcia</groupId>
        <artifactId>webdrivermanager</artifactId>
        <version>5.5.0</version>
    </dependency>
    
    <!-- Testing Framework -->
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>7.8.0</version>
    </dependency>
    
    <!-- Logging -->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>2.20.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.20.0</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.7</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-slf4j2-impl</artifactId>
        <version>2.20.0</version>
    </dependency>
    
    <!-- HTTP Client for API testing -->
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
        <version>4.5.14</version>
    </dependency>
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpmime</artifactId>
        <version>4.5.14</version>
    </dependency>
    
    <!-- JSON Processing -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
    </dependency>
    <dependency>
        <groupId>org.json</groupId>
        <artifactId>json</artifactId>
        <version>20230618</version>
    </dependency>
    
    <!-- JSON Schema Validation -->
    <dependency>
        <groupId>com.networknt</groupId>
        <artifactId>json-schema-validator</artifactId>
        <version>1.0.86</version>
    </dependency>
    
    <!-- Database connectivity -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.33</version>
    </dependency>
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.6.0</version>
    </dependency>
    
    <!-- For reporting and utility functions -->
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.13.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.13.0</version>
    </dependency>
    
    <!-- For image processing in screenshots -->
    <dependency>
        <groupId>org.imgscalr</groupId>
        <artifactId>imgscalr-lib</artifactId>
        <version>4.2</version>
    </dependency>
</dependencies>




package com.cssmart.core.bdd;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation to mark methods as BDD step definitions.
 * Mimics QAF's QAFTestStep annotation.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSSmartTestStep {
    
    /**
     * The step description/pattern in Gherkin format.
     * Can include parameters in {param} format.
     * @return The step description/pattern
     */
    String description() default "";
    
    /**
     * Alternative way to specify the step description/pattern.
     * @return The step description/pattern
     */
    String value() default "";
    
    /**
     * Gauntlet (substep) to be executed before this step.
     * @return The gauntlet to execute
     */
    String gauntlet() default "";
    
    /**
     * Optional threshold time in milliseconds to consider this step slow.
     * @return The threshold time in milliseconds
     */
    long threshold() default 0;
    
    /**
     * Optional inParallel flag for substeps.
     * @return True if substeps should run in parallel
     */
    boolean inParallel() default false;
}


package com.cssmart.core.bdd;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Factory for BDD test execution.
 * Similar to QAF's BDDTestFactory2.
 */
public class CSSmartBDDTestFactory {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDTestFactory.class);
    private static final CSSmartReport REPORT = new CSSmartReport("BDD Test Report", "CSSmart BDD Test Results");
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    private static CSSmartConfig config;
    private static CSSmartBDDScanner scanner;
    private static Set<String> stepProviderPackages = new HashSet<>();
    private static String scenarioFileLocation;
    
    /**
     * Setup operations before the test suite runs.
     * 
     * @param context The test context
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp(ITestContext context) {
        LOGGER.info("Setting up BDD test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Get step provider packages from TestNG parameters
        String stepProviderPkg = context.getCurrentXmlTest().getParameter("step.provider.pkg");
        if (stepProviderPkg != null && !stepProviderPkg.isEmpty()) {
            stepProviderPackages.addAll(Arrays.asList(stepProviderPkg.split(";")));
        } else {
            stepProviderPackages.add("com.cssmart.steps"); // Default package
        }
        
        // Get scenario file location from TestNG parameters
        scenarioFileLocation = context.getCurrentXmlTest().getParameter("scenario.file.loc");
        if (scenarioFileLocation == null || scenarioFileLocation.isEmpty()) {
            scenarioFileLocation = "scenarios"; // Default location
        }
        
        // Initialize step scanner
        scanner = new CSSmartBDDScanner(stepProviderPackages);
        scanner.scanForStepDefinitions();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Environment", config.getString("env", "test"))
              .addEnvironmentInfo("Step Packages", String.join(", ", stepProviderPackages))
              .addEnvironmentInfo("Scenario Location", scenarioFileLocation);
        
        LOGGER.info("BDD test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down BDD test suite");
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("BDD test report generated: {}", reportPath);
    }
    
    /**
     * Creates a data provider for scenarios.
     * 
     * @param context The test context
     * @return Array of scenario data
     */
    @DataProvider(name = "scenarios")
    public Object[][] scenarioDataProvider(ITestContext context) {
        LOGGER.info("Creating data provider for scenarios");
        
        try {
            // Load scenarios from the specified location
            List<CSSmartScenario> scenarios = loadScenarios(scenarioFileLocation);
            LOGGER.info("Found {} scenarios", scenarios.size());
            
            // Create data provider array
            Object[][] data = new Object[scenarios.size()][2];
            for (int i = 0; i < scenarios.size(); i++) {
                CSSmartScenario scenario = scenarios.get(i);
                data[i][0] = scenario.getTitle();
                data[i][1] = scenario;
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error creating data provider", e);
            throw new CSSmartException("Error creating data provider: " + e.getMessage(), e);
        }
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param scenarioTitle The scenario title
     * @param scenario The scenario to run
     * @param context The test context
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(String scenarioTitle, CSSmartScenario scenario, ITestContext context) {
        LOGGER.info("Setting up BDD test for scenario: {}", scenarioTitle);
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(scenarioTitle, 
                                                              scenario.getFeatureTitle(), 
                                                              CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        LOGGER.info("BDD test setup complete for scenario: {}", scenarioTitle);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        LOGGER.info("Tearing down BDD test: {}", result.getName());
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        testResult.addFailStep("Test failed: " + result.getThrowable().getMessage());
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("BDD test complete: {} with status {}", result.getName(), 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Runs a scenario.
     * 
     * @param scenarioTitle The scenario title
     * @param scenario The scenario to run
     */
    @Test(dataProvider = "scenarios")
    public void runScenario(String scenarioTitle, CSSmartScenario scenario) {
        LOGGER.info("Running scenario: {}", scenarioTitle);
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        try {
            CSSmartBDDExecutor executor = new CSSmartBDDExecutor(scanner, testResult);
            
            // Execute all steps in the scenario
            boolean success = executor.executeScenario(scenario);
            
            if (!success) {
                LOGGER.error("Scenario failed: {}", scenarioTitle);
                throw new CSSmartException("Scenario failed: " + scenarioTitle);
            }
            
            LOGGER.info("Scenario completed successfully: {}", scenarioTitle);
        } catch (Exception e) {
            LOGGER.error("Error executing scenario: {}", scenarioTitle, e);
            throw e;
        }
    }
    
    /**
     * Loads scenarios from the specified location.
     * 
     * @param location The scenario file location
     * @return List of loaded scenarios
     */
    private List<CSSmartScenario> loadScenarios(String location) {
        LOGGER.info("Loading scenarios from location: {}", location);
        List<CSSmartScenario> scenarios = new ArrayList<>();
        
        try {
            // Parse location for multiple paths
            String[] locations = location.split(";");
            
            for (String loc : locations) {
                Path path = Paths.get(loc);
                
                if (Files.isDirectory(path)) {
                    // Find all .scenario files in directory
                    try (Stream<Path> paths = Files.walk(path)) {
                        List<Path> scenarioFiles = paths
                            .filter(Files::isRegularFile)
                            .filter(p -> p.toString().endsWith(".scenario") || p.toString().endsWith(".feature"))
                            .collect(Collectors.toList());
                        
                        for (Path scenarioFile : scenarioFiles) {
                            scenarios.addAll(parseScenarioFile(scenarioFile));
                        }
                    }
                } else if (Files.isRegularFile(path)) {
                    // Parse single scenario file
                    scenarios.addAll(parseScenarioFile(path));
                } else {
                    LOGGER.warn("Scenario location not found: {}", loc);
                }
            }
        } catch (IOException e) {
            LOGGER.error("Error loading scenarios", e);
            throw new CSSmartException("Error loading scenarios: " + e.getMessage(), e);
        }
        
        return scenarios;
    }
    
    /**
     * Parses a scenario file into scenario objects.
     * 
     * @param scenarioFile The scenario file path
     * @return List of scenarios
     */
    private List<CSSmartScenario> parseScenarioFile(Path scenarioFile) {
        LOGGER.info("Parsing scenario file: {}", scenarioFile);
        List<CSSmartScenario> scenarios = new ArrayList<>();
        
        try {
            CSSmartBDDParser parser = new CSSmartBDDParser();
            scenarios.addAll(parser.parseFile(scenarioFile));
        } catch (Exception e) {
            LOGGER.error("Error parsing scenario file: {}", scenarioFile, e);
            throw new CSSmartException("Error parsing scenario file: " + e.getMessage(), e);
        }
        
        return scenarios;
    }
}


package com.cssmart.core.bdd;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import org.reflections.Reflections;
import org.reflections.scanners.MethodAnnotationsScanner;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;

import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Scanner to discover BDD step definitions in the classpath.
 */
public class CSSmartBDDScanner {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDScanner.class);
    
    private final Set<String> stepPackages;
    private final Map<Method, CSSmartTestStep> stepDefinitions = new HashMap<>();
    private final Map<Pattern, Method> stepPatterns = new HashMap<>();
    
    /**
     * Constructs a new CSSmartBDDScanner with the specified packages.
     * 
     * @param stepPackages The packages to scan for step definitions
     */
    public CSSmartBDDScanner(Set<String> stepPackages) {
        this.stepPackages = stepPackages;
    }
    
    /**
     * Scans for step definitions in the specified packages.
     */
    public void scanForStepDefinitions() {
        LOGGER.info("Scanning for step definitions in packages: {}", stepPackages);
        
        for (String packageName : stepPackages) {
            try {
                Reflections reflections = new Reflections(new ConfigurationBuilder()
                    .setUrls(ClasspathHelper.forPackage(packageName))
                    .setScanners(new MethodAnnotationsScanner()));
                
                Set<Method> methods = reflections.getMethodsAnnotatedWith(CSSmartTestStep.class);
                
                for (Method method : methods) {
                    CSSmartTestStep annotation = method.getAnnotation(CSSmartTestStep.class);
                    
                    if (annotation != null) {
                        // Get step description from annotation
                        String stepDescription = annotation.description();
                        if (stepDescription.isEmpty()) {
                            stepDescription = annotation.value();
                        }
                        
                        if (stepDescription.isEmpty()) {
                            LOGGER.warn("Step definition without description: {}.{}", 
                                       method.getDeclaringClass().getName(), method.getName());
                            continue;
                        }
                        
                        // Register step definition
                        stepDefinitions.put(method, annotation);
                        
                        // Convert Gherkin-style parameters to regex
                        String regexPattern = convertGherkinToRegex(stepDescription);
                        Pattern pattern = Pattern.compile(regexPattern, Pattern.CASE_INSENSITIVE);
                        stepPatterns.put(pattern, method);
                        
                        LOGGER.debug("Registered step definition: {} -> {}.{}", 
                                   stepDescription, method.getDeclaringClass().getName(), method.getName());
                    }
                }
            } catch (Exception e) {
                LOGGER.error("Error scanning package: {}", packageName, e);
            }
        }
        
        LOGGER.info("Found {} step definitions", stepDefinitions.size());
    }
    
    /**
     * Gets all registered step definitions.
     * 
     * @return Map of methods to step annotations
     */
    public Map<Method, CSSmartTestStep> getStepDefinitions() {
        return Collections.unmodifiableMap(stepDefinitions);
    }
    
    /**
     * Gets all registered step patterns.
     * 
     * @return Map of patterns to methods
     */
    public Map<Pattern, Method> getStepPatterns() {
        return Collections.unmodifiableMap(stepPatterns);
    }
    
    /**
     * Finds a matching step definition for a step statement.
     * 
     * @param stepStatement The step statement
     * @return Map entry with pattern and method, or null if no match found
     */
    public Map.Entry<Pattern, Method> findMatchingStepDefinition(String stepStatement) {
        for (Map.Entry<Pattern, Method> entry : stepPatterns.entrySet()) {
            Pattern pattern = entry.getKey();
            if (pattern.matcher(stepStatement).matches()) {
                return entry;
            }
        }
        
        return null;
    }
    
    /**
     * Creates a new instance of a step definition class.
     * 
     * @param method The method containing the step definition
     * @return A new instance of the declaring class
     */
    public Object createStepInstance(Method method) {
        try {
            Class<?> declaringClass = method.getDeclaringClass();
            return declaringClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            LOGGER.error("Error creating step instance: {}", method.getDeclaringClass().getName(), e);
            throw new CSSmartException("Error creating step instance: " + e.getMessage(), e);
        }
    }
    
    /**
     * Converts a Gherkin-style step description to a regex pattern.
     * Handles both {param} style and "quoted parameter" style.
     * 
     * @param gherkinPattern The Gherkin pattern
     * @return The regex pattern
     */
    private String convertGherkinToRegex(String gherkinPattern) {
        // Replace {param} style parameters with regex groups
        String regex = gherkinPattern.replaceAll("\\{([^}]+)\\}", "(.+?)");
        
        // Replace quoted parameters with regex groups
        regex = regex.replaceAll("\"([^\"]*)\"", "\"(.+?)\"");
        
        // Add word boundary anchors and escape special regex characters
        regex = "^" + escapeSpecialRegexChars(regex) + "$";
        
        return regex;
    }
    
    /**
     * Escapes special regex characters in a string, except for
     * those already used in capture groups.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeSpecialRegexChars(String input) {
        // Escape all special regex characters, but preserve parentheses for groups
        return input
            .replace("\\", "\\\\")
            .replace(".", "\\.")
            .replace("[", "\\[")
            .replace("]", "\\]")
            .replace("^", "\\^")
            .replace("$", "\\$")
            .replace("|", "\\|")
            .replace("?", "\\?")
            .replace("*", "\\*")
            .replace("+", "\\+")
            .replaceAll("\\\\\\((.+?)\\\\\\)", "($1)"); // Restore parentheses for capture groups
    }
}



package com.cssmart.core.bdd;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;

import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Executor to run BDD scenarios and steps.
 */
public class CSSmartBDDExecutor {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDExecutor.class);
    
    private final CSSmartBDDScanner scanner;
    private final CSSmartTestResult testResult;
    private final Map<Class<?>, Object> stepInstances = new HashMap<>();
    
    /**
     * Constructs a new CSSmartBDDExecutor.
     * 
     * @param scanner The BDD scanner with step definitions
     * @param testResult The test result for reporting
     */
    public CSSmartBDDExecutor(CSSmartBDDScanner scanner, CSSmartTestResult testResult) {
        this.scanner = scanner;
        this.testResult = testResult;
    }
    
    /**
     * Executes a scenario.
     * 
     * @param scenario The scenario to execute
     * @return true if executed successfully, false otherwise
     */
    public boolean executeScenario(CSSmartScenario scenario) {
        LOGGER.info("Executing scenario: {}", scenario.getTitle());
        
        if (testResult != null) {
            testResult.addInfoStep("Starting scenario: " + scenario.getTitle());
        }
        
        List<String> steps = scenario.getSteps();
        if (steps.isEmpty()) {
            LOGGER.warn("Scenario has no steps: {}", scenario.getTitle());
            return true;
        }
        
        boolean allSuccess = true;
        
        for (String step : steps) {
            try {
                boolean success = executeStep(step);
                if (!success) {
                    allSuccess = false;
                    break;
                }
            } catch (Exception e) {
                LOGGER.error("Error executing step: {}", step, e);
                
                if (testResult != null) {
                    testResult.addFailStep("Failed to execute step: " + step)
                             .setErrorMessage(e.getMessage());
                }
                
                return false;
            }
        }
        
        if (allSuccess && testResult != null) {
            testResult.addPassStep("Scenario completed successfully: " + scenario.getTitle());
        }
        
        return allSuccess;
    }
    
    /**
     * Executes a step.
     * 
     * @param step The step to execute
     * @return true if executed successfully, false otherwise
     */
    public boolean executeStep(String step) {
        LOGGER.info("Executing step: {}", step);
        
        // Find matching step definition
        Map.Entry<Pattern, Method> matchingStep = scanner.findMatchingStepDefinition(step);
        
        if (matchingStep == null) {
            String errorMessage = "No matching step definition found for: " + step;
            LOGGER.error(errorMessage);
            
            if (testResult != null) {
                testResult.addFailStep(step)
                         .setErrorMessage(errorMessage);
            }
            
            return false;
        }
        
        Pattern pattern = matchingStep.getKey();
        Method method = matchingStep.getValue();
        
        // Extract parameters from step
        List<String> parameters = extractStepParameters(pattern, step);
        
        // Execute step definition
        try {
            // Get or create step instance
            Object stepInstance = getStepInstance(method.getDeclaringClass());
            
            // Convert parameters to method argument types
            Object[] args = convertParameters(parameters, method);
            
            // Add step info to report
            if (testResult != null) {
                testResult.addInfoStep("Executing step: " + step);
            }
            
            // Track execution time for threshold warning
            long startTime = System.currentTimeMillis();
            
            // Execute step
            method.setAccessible(true);
            Object result = method.invoke(stepInstance, args);
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            // Check execution time against threshold
            CSSmartTestStep annotation = method.getAnnotation(CSSmartTestStep.class);
            if (annotation.threshold() > 0 && executionTime > annotation.threshold()) {
                LOGGER.warn("Step execution exceeded threshold ({} ms): {} (took {} ms)", 
                          annotation.threshold(), step, executionTime);
                
                if (testResult != null) {
                    testResult.addWarningStep("Step execution time (" + executionTime + 
                                            " ms) exceeded threshold (" + annotation.threshold() + " ms)");
                }
            }
            
            // Add success to report
            if (testResult != null) {
                testResult.addPassStep("Step completed: " + step);
            }
            
            LOGGER.debug("Step executed successfully: {}", step);
            return true;
            
        } catch (Exception e) {
            String errorMessage = "Error executing step: " + e.getMessage();
            LOGGER.error(errorMessage, e);
            
            if (testResult != null) {
                testResult.addFailStep(step)
                         .setErrorMessage(errorMessage);
            }
            
            if (e.getCause() instanceof CSSmartException) {
                throw (CSSmartException) e.getCause();
            } else {
                throw new CSSmartException("Failed to execute step: " + step, e);
            }
        }
    }
    
    /**
     * Gets or creates an instance of a step definition class.
     * 
     * @param stepClass The step class
     * @return The step instance
     */
    private Object getStepInstance(Class<?> stepClass) {
        return stepInstances.computeIfAbsent(stepClass, clazz -> {
            try {
                return clazz.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                LOGGER.error("Error creating step instance: {}", clazz.getName(), e);
                throw new CSSmartException("Error creating step instance: " + e.getMessage(), e);
            }
        });
    }
    
    /**
     * Extracts parameters from a step statement based on the matching pattern.
     * 
     * @param pattern The matching pattern
     * @param step The step statement
     * @return List of extracted parameters
     */
    private List<String> extractStepParameters(Pattern pattern, String step) {
        List<String> parameters = new ArrayList<>();
        Matcher matcher = pattern.matcher(step);
        
        if (matcher.matches()) {
            for (int i = 1; i <= matcher.groupCount(); i++) {
                String param = matcher.group(i);
                // Remove quotes from quoted parameters
                if (param.startsWith("\"") && param.endsWith("\"")) {
                    param = param.substring(1, param.length() - 1);
                }
                parameters.add(param);
            }
        }
        
        return parameters;
    }
    
    /**
     * Converts string parameters to the appropriate types for a method.
     * 
     * @param parameters The string parameters
     * @param method The method to invoke
     * @return Array of converted parameters
     */
    private Object[] convertParameters(List<String> parameters, Method method) {
        Class<?>[] paramTypes = method.getParameterTypes();
        Object[] args = new Object[paramTypes.length];
        
        for (int i = 0; i < paramTypes.length && i < parameters.size(); i++) {
            String param = parameters.get(i);
            Class<?> type = paramTypes[i];
            
            args[i] = convertParameter(param, type);
        }
        
        return args;
    }
    
    /**
     * Converts a string parameter to the specified type.
     * 
     * @param param The string parameter
     * @param type The target type
     * @return The converted parameter
     */
    private Object convertParameter(String param, Class<?> type) {
        if (type == String.class) {
            return param;
        } else if (type == int.class || type == Integer.class) {
            return Integer.parseInt(param);
        } else if (type == long.class || type == Long.class) {
            return Long.parseLong(param);
        } else if (type == double.class || type == Double.class) {
            return Double.parseDouble(param);
        } else if (type == boolean.class || type == Boolean.class) {
            return Boolean.parseBoolean(param);
        } else if (type == float.class || type == Float.class) {
            return Float.parseFloat(param);
        } else if (type.isEnum()) {
            return Enum.valueOf((Class<Enum>) type, param);
        } else {
            throw new CSSmartException("Unsupported parameter type: " + type.getName());
        }
    }
}


package com.cssmart.core.bdd;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parser for BDD feature/scenario files.
 */
public class CSSmartBDDParser {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDParser.class);
    
    // Patterns for parsing feature files
    private static final Pattern FEATURE_PATTERN = Pattern.compile("\\s*Feature:(.*)");
    private static final Pattern SCENARIO_PATTERN = Pattern.compile("\\s*Scenario:(.*)");
    private static final Pattern SCENARIO_OUTLINE_PATTERN = Pattern.compile("\\s*Scenario Outline:(.*)");
    private static final Pattern EXAMPLES_PATTERN = Pattern.compile("\\s*Examples:.*");
    private static final Pattern TABLE_ROW_PATTERN = Pattern.compile("\\s*\\|(.*)\\|.*");
    private static final Pattern STEP_PATTERN = Pattern.compile("\\s*(Given|When|Then|And|But)(.*)");
    
    /**
     * Parses a feature/scenario file into scenarios.
     * 
     * @param filePath The file path
     * @return List of scenarios
     */
    public List<CSSmartScenario> parseFile(Path filePath) {
        LOGGER.info("Parsing BDD file: {}", filePath);
        
        List<CSSmartScenario> scenarios = new ArrayList<>();
        String featureTitle = filePath.getFileName().toString();
        
        try (BufferedReader reader = Files.newBufferedReader(filePath)) {
            String line;
            StringBuilder featureDescription = new StringBuilder();
            boolean inFeatureDescription = false;
            
            CSSmartScenario currentScenario = null;
            boolean inScenarioOutline = false;
            boolean inExamples = false;
            List<String> exampleHeaders = null;
            List<Map<String, String>> examples = new ArrayList<>();
            List<String> outlineSteps = new ArrayList<>();
            String outlineTitle = null;
            
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                
                // Skip empty lines and comments
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }
                
                // Parse Feature
                Matcher featureMatcher = FEATURE_PATTERN.matcher(line);
                if (featureMatcher.matches()) {
                    featureTitle = featureMatcher.group(1).trim();
                    inFeatureDescription = true;
                    continue;
                }
                
                // Parse Scenario
                Matcher scenarioMatcher = SCENARIO_PATTERN.matcher(line);
                if (scenarioMatcher.matches()) {
                    inFeatureDescription = false;
                    
                    // Process previous scenario outline if any
                    if (inScenarioOutline) {
                        processScenarioOutline(scenarios, outlineTitle, outlineSteps, examples, featureTitle);
                        inScenarioOutline = false;
                        outlineSteps.clear();
                        examples.clear();
                        exampleHeaders = null;
                    }
                    
                    // Start new scenario
                    String scenarioTitle = scenarioMatcher.group(1).trim();
                    currentScenario = new CSSmartScenario(scenarioTitle);
                    currentScenario.setFeatureTitle(featureTitle);
                    scenarios.add(currentScenario);
                    continue;
                }
                
                // Parse Scenario Outline
                Matcher scenarioOutlineMatcher = SCENARIO_OUTLINE_PATTERN.matcher(line);
                if (scenarioOutlineMatcher.matches()) {
                    inFeatureDescription = false;
                    
                    // Finish previous scenario if any
                    if (currentScenario != null) {
                        currentScenario = null;
                    }
                    
                    // Start new scenario outline
                    outlineTitle = scenarioOutlineMatcher.group(1).trim();
                    inScenarioOutline = true;
                    inExamples = false;
                    continue;
                }
                
                // Parse Steps
                Matcher stepMatcher = STEP_PATTERN.matcher(line);
                if (stepMatcher.matches()) {
                    inFeatureDescription = false;
                    
                    String stepType = stepMatcher.group(1).trim();
                    String stepText = stepType + stepMatcher.group(2).trim();
                    
                    if (currentScenario != null) {
                        currentScenario.addStep(stepText);
                    } else if (inScenarioOutline && !inExamples) {
                        outlineSteps.add(stepText);
                    }
                    continue;
                }
                
                // Parse Examples
                Matcher examplesMatcher = EXAMPLES_PATTERN.matcher(line);
                if (examplesMatcher.matches() && inScenarioOutline) {
                    inExamples = true;
                    continue;
                }
                
                // Parse Example table
                Matcher tableRowMatcher = TABLE_ROW_PATTERN.matcher(line);
                if (tableRowMatcher.matches() && inExamples) {
                    String[] cells = tableRowMatcher.group(1).split("\\|");
                    
                    // Trim each cell
                    for (int i = 0; i < cells.length; i++) {
                        cells[i] = cells[i].trim();
                    }
                    
                    if (exampleHeaders == null) {
                        // First row is headers
                        exampleHeaders = new ArrayList<>();
                        for (String cell : cells) {
                            exampleHeaders.add(cell);
                        }
                    } else {
                        // Data rows
                        Map<String, String> exampleRow = new HashMap<>();
                        for (int i = 0; i < Math.min(cells.length, exampleHeaders.size()); i++) {
                            exampleRow.put(exampleHeaders.get(i), cells[i]);
                        }
                        examples.add(exampleRow);
                    }
                    continue;
                }
                
                // Add to feature description if in feature description section
                if (inFeatureDescription) {
                    featureDescription.append(line).append("\n");
                }
            }
            
            // Process the last scenario outline if any
            if (inScenarioOutline) {
                processScenarioOutline(scenarios, outlineTitle, outlineSteps, examples, featureTitle);
            }
            
            LOGGER.info("Parsed {} scenarios from file: {}", scenarios.size(), filePath);
            
        } catch (IOException e) {
            LOGGER.error("Error parsing BDD file: {}", filePath, e);
            throw new CSSmartException("Error parsing BDD file: " + e.getMessage(), e);
        }
        
        return scenarios;
    }
    
    /**
     * Processes a scenario outline, generating scenarios from examples.
     * 
     * @param scenarios The list to add scenarios to
     * @param outlineTitle The outline title
     * @param outlineSteps The outline steps
     * @param examples The examples
     * @param featureTitle The feature title
     */
    private void processScenarioOutline(List<CSSmartScenario> scenarios, String outlineTitle,
                                     List<String> outlineSteps, List<Map<String, String>> examples,
                                     String featureTitle) {
        if (examples.isEmpty()) {
            LOGGER.warn("Scenario outline has no examples: {}", outlineTitle);
            return;
        }
        
        for (int i = 0; i < examples.size(); i++) {
            Map<String, String> example = examples.get(i);
            String scenarioTitle = outlineTitle + " (Example " + (i + 1) + ")";
            CSSmartScenario scenario = new CSSmartScenario(scenarioTitle);
            scenario.setFeatureTitle(featureTitle);
            
            // Apply example values to steps
            for (String outlineStep : outlineSteps) {
                String resolvedStep = resolveStep(outlineStep, example);
                scenario.addStep(resolvedStep);
            }
            
            scenarios.add(scenario);
        }
    }
    
    /**
     * Resolves a step by replacing parameters with values from an example.
     * 
     * @param step The step with parameters
     * @param example The example with values
     * @return The resolved step
     */
    private String resolveStep(String step, Map<String, String> example) {
        String resolvedStep = step;
        
        // Replace <param> style parameters
        Pattern paramPattern = Pattern.compile("<([^>]+)>");
        Matcher matcher = paramPattern.matcher(step);
        
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            String paramName = matcher.group(1);
            String paramValue = example.getOrDefault(paramName, "<" + paramName + ">");
            matcher.appendReplacement(sb, Matcher.quoteReplacement(paramValue));
        }
        matcher.appendTail(sb);
        
        return sb.toString();
    }
}


package com.cssmart.core.bdd;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a BDD scenario with steps.
 */
public class CSSmartScenario {
    private final String title;
    private String featureTitle;
    private final List<String> steps;
    
    /**
     * Constructs a new CSSmartScenario.
     * 
     * @param title The scenario title
     */
    public CSSmartScenario(String title) {
        this.title = title;
        this.steps = new ArrayList<>();
    }
    
    /**
     * Gets the scenario title.
     * 
     * @return The scenario title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Gets the feature title.
     * 
     * @return The feature title
     */
    public String getFeatureTitle() {
        return featureTitle;
    }
    
    /**
     * Sets the feature title.
     * 
     * @param featureTitle The feature title
     */
    public void setFeatureTitle(String featureTitle) {
        this.featureTitle = featureTitle;
    }
    
    /**
     * Gets the steps in this scenario.
     * 
     * @return List of steps
     */
    public List<String> getSteps() {
        return steps;
    }
    
    /**
     * Adds a step to this scenario.
     * 
     * @param step The step to add
     */
    public void addStep(String step) {
        this.steps.add(step);
    }
    
    /**
     * Sets the steps for this scenario.
     * 
     * @param steps The steps to set
     */
    public void setSteps(List<String> steps) {
        this.steps.clear();
        this.steps.addAll(steps);
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Scenario: ").append(title).append("\n");
        
        for (String step : steps) {
            sb.append("  ").append(step).append("\n");
        }
        
        return sb.toString();
    }
}


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="CSSmart BDD Test Suite" parallel="tests" thread-count="3">
    <test name="Login Tests">
        <parameter name="step.provider.pkg" value="com.cssmart.example.steps"/>
        <parameter name="scenario.file.loc" value="src/test/resources/features/login.feature"/>
        <classes>
            <class name="com.cssmart.core.bdd.CSSmartBDDTestFactory"/>
        </classes>
    </test>
    
    <!-- Additional test groups can be added here -->
    <!-- Example:
    <test name="Profile Tests">
        <parameter name="step.provider.pkg" value="com.cssmart.example.steps"/>
        <parameter name="scenario.file.loc" value="src/test/resources/features/profile.feature"/>
        <classes>
            <class name="com.cssmart.core.bdd.CSSmartBDDTestFactory"/>
        </classes>
    </test>
    -->
</suite>



package com.cssmart.core.bdd;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.driver.BrowserManager;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.util.CSSmartScreenshot;

/**
 * Base class for all step definition classes.
 * Provides common functionality and initialization for test steps.
 */
public class CSSmartBaseTestSteps {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBaseTestSteps.class);
    
    protected static CSSmartConfig config;
    protected static String baseUrl;
    protected CSSmartDriver driver;
    protected CSSmartScreenshot screenshot;
    
    // Initialize static configuration once
    static {
        try {
            LOGGER.info("Initializing CSSmartBaseTestSteps configuration");
            config = new PropertyManager().initialize();
            baseUrl = config.getString("base.url", "https://example.com");
            LOGGER.info("Initialized with base URL: {}", baseUrl);
        } catch (Exception e) {
            LOGGER.error("Failed to initialize configuration", e);
            throw new RuntimeException("Failed to initialize CSSmartBaseTestSteps", e);
        }
    }
    
    /**
     * Default constructor that initializes driver.
     */
    public CSSmartBaseTestSteps() {
        try {
            LOGGER.debug("Initializing WebDriver for steps");
            driver = new BrowserManager(config).createDriver();
            screenshot = new CSSmartScreenshot(driver);
        } catch (Exception e) {
            LOGGER.error("Failed to initialize WebDriver", e);
            throw new RuntimeException("Failed to initialize WebDriver", e);
        }
    }
    
    /**
     * Get the CSSmartDriver instance.
     * 
     * @return The CSSmartDriver instance
     */
    public CSSmartDriver getDriver() {
        return driver;
    }
    
    /**
     * Get the CSSmartConfig instance.
     * 
     * @return The CSSmartConfig instance
     */
    public CSSmartConfig getConfig() {
        return config;
    }
    
    /**
     * Get the base URL.
     * 
     * @return The base URL
     */
    public String getBaseUrl() {
        return baseUrl;
    }
    
    /**
     * Get the screenshot utility.
     * 
     * @return The CSSmartScreenshot instance
     */
    public CSSmartScreenshot getScreenshot() {
        return screenshot;
    }
    
    /**
     * Navigate to a page using the base URL.
     * 
     * @param path The path to navigate to
     */
    protected void navigateTo(String path) {
        String url = baseUrl;
        if (!url.endsWith("/") && !path.startsWith("/")) {
            url += "/";
        } else if (url.endsWith("/") && path.startsWith("/")) {
            path = path.substring(1);
        }
        
        LOGGER.info("Navigating to: {}{}", url, path);
        driver.navigateTo(url + path);
        driver.waitForPageLoad();
    }
    
    /**
     * Takes a screenshot with the given name.
     * 
     * @param name The screenshot name
     * @return The path to the screenshot
     */
    protected String takeScreenshot(String name) {
        return screenshot.takeScreenshot(name);
    }
    
    /**
     * Cleanup method to be called after test execution.
     * Should be called by a method with @AfterMethod annotation in step classes.
     */
    protected void cleanup() {
        LOGGER.debug("Cleaning up resources");
        if (driver != null) {
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.warn("Error while quitting driver", e);
            }
        }
    }
}


package com.cssmart.example.steps;

import com.cssmart.core.bdd.CSSmartBaseTestSteps;
import com.cssmart.core.bdd.CSSmartTestStep;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.testng.Assert;
import org.testng.annotations.AfterMethod;

/**
 * Login step definitions using the CSSmartTestStep annotation.
 */
public class LoginSteps extends CSSmartBaseTestSteps {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(LoginSteps.class);
    
    /**
     * Constructor inherits configuration from CSSmartBaseTestSteps.
     */
    public LoginSteps() {
        super();
    }
    
    /**
     * Method to clean up resources after test execution.
     */
    @AfterMethod
    public void tearDown() {
        cleanup();
    }
    
    /**
     * Navigates to the login page.
     */
    @CSSmartTestStep(description = "I navigate to the login page")
    public void navigateToLoginPage() {
        LOGGER.info("Navigating to login page");
        navigateTo("/login");
    }
    
    /**
     * Enters username and password.
     * 
     * @param username The username
     * @param password The password
     */
    @CSSmartTestStep(description = "I enter username {username} and password {password}")
    public void enterCredentials(String username, String password) {
        LOGGER.info("Entering credentials: username={}, password=****", username);
        driver.sendKeys(By.id("username"), username);
        driver.sendKeys(By.id("password"), password);
    }
    
    /**
     * Clicks the login button.
     */
    @CSSmartTestStep(description = "I click the login button")
    public void clickLoginButton() {
        LOGGER.info("Clicking login button");
        driver.click(By.id("loginBtn"));
        driver.waitForPageLoad();
    }
    
    /**
     * Verifies successful login.
     */
    @CSSmartTestStep(description = "I should be logged in successfully")
    public void verifySuccessfulLogin() {
        LOGGER.info("Verifying successful login");
        boolean isLoggedIn = driver.elementExists(By.id("welcomeMessage"));
        Assert.assertTrue(isLoggedIn, "User should be logged in successfully");
    }
    
    /**
     * Verifies welcome message.
     */
    @CSSmartTestStep(description = "I should see the welcome message")
    public void verifyWelcomeMessage() {
        LOGGER.info("Verifying welcome message");
        String welcomeMessage = driver.getText(By.id("welcomeMessage"));
        Assert.assertTrue(welcomeMessage.contains("Welcome"), 
                        "Welcome message should contain 'Welcome'");
    }
    
    /**
     * Verifies error message.
     * 
     * @param expectedMessage The expected error message
     */
    @CSSmartTestStep(description = "I should see an error message {expectedMessage}")
    public void verifyErrorMessage(String expectedMessage) {
        LOGGER.info("Verifying error message: {}", expectedMessage);
        String actualMessage = driver.getText(By.id("errorMessage"));
        Assert.assertEquals(actualMessage, expectedMessage, 
                          "Error message should match expected message");
    }
    
    /**
     * Verifies status message.
     * 
     * @param status The expected status
     */
    @CSSmartTestStep(description = "I should see status {status}")
    public void verifyStatus(String status) {
        LOGGER.info("Verifying status: {}", status);
        boolean isSuccess = "success".equalsIgnoreCase(status);
        boolean actualSuccess = driver.elementExists(By.id("welcomeMessage"));
        Assert.assertEquals(actualSuccess, isSuccess, 
                          "Login status should match expected status");
    }
    
    /**
     * Verifies message.
     * 
     * @param expectedMessage The expected message
     */
    @CSSmartTestStep(description = "I should see message {expectedMessage}")
    public void verifyMessage(String expectedMessage) {
        LOGGER.info("Verifying message: {}", expectedMessage);
        String actualMessage = "";
        
        if (driver.elementExists(By.id("welcomeMessage"))) {
            actualMessage = driver.getText(By.id("welcomeMessage"));
        } else if (driver.elementExists(By.id("errorMessage"))) {
            actualMessage = driver.getText(By.id("errorMessage"));
        }
        
        Assert.assertEquals(actualMessage, expectedMessage, 
                          "Message should match expected message");
    }
    

}



package com.cssmart.core.bdd;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.util.CSSmartScreenshot;

/**
 * Base class for all step definition classes.
 * Provides common functionality for test steps.
 */
public class CSSmartBaseTestSteps {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBaseTestSteps.class);
    
    protected static CSSmartConfig config;
    protected static String baseUrl;
    protected CSSmartDriver driver;
    protected CSSmartScreenshot screenshot;
    
    // Initialize static configuration once
    static {
        try {
            LOGGER.info("Initializing CSSmartBaseTestSteps configuration");
            config = new PropertyManager().initialize();
            baseUrl = config.getString("base.url", "https://example.com");
            LOGGER.info("Initialized with base URL: {}", baseUrl);
        } catch (Exception e) {
            LOGGER.error("Failed to initialize configuration", e);
            throw new RuntimeException("Failed to initialize CSSmartBaseTestSteps", e);
        }
    }
    
    /**
     * Default constructor that accepts a driver instance.
     * This allows the factory to inject a managed driver instance.
     * 
     * @param driver The driver instance to use
     */
    public CSSmartBaseTestSteps(CSSmartDriver driver) {
        this.driver = driver;
        this.screenshot = new CSSmartScreenshot(driver);
    }
    
    /**
     * Get the CSSmartDriver instance.
     * 
     * @return The CSSmartDriver instance
     */
    public CSSmartDriver getDriver() {
        return driver;
    }
    
    /**
     * Get the CSSmartConfig instance.
     * 
     * @return The CSSmartConfig instance
     */
    public CSSmartConfig getConfig() {
        return config;
    }
    
    /**
     * Get the base URL.
     * 
     * @return The base URL
     */
    public String getBaseUrl() {
        return baseUrl;
    }
    
    /**
     * Get the screenshot utility.
     * 
     * @return The CSSmartScreenshot instance
     */
    public CSSmartScreenshot getScreenshot() {
        return screenshot;
    }
    
    /**
     * Navigate to a page using the base URL.
     * 
     * @param path The path to navigate to
     */
    protected void navigateTo(String path) {
        String url = baseUrl;
        if (!url.endsWith("/") && !path.startsWith("/")) {
            url += "/";
        } else if (url.endsWith("/") && path.startsWith("/")) {
            path = path.substring(1);
        }
        
        LOGGER.info("Navigating to: {}{}", url, path);
        driver.navigateTo(url + path);
        driver.waitForPageLoad();
    }
    
    /**
     * Takes a screenshot with the given name.
     * 
     * @param name The screenshot name
     * @return The path to the screenshot
     */
    protected String takeScreenshot(String name) {
        return screenshot.takeScreenshot(name);
    }
}


package com.cssmart.core.bdd;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Factory for BDD test execution.
 * Similar to QAF's BDDTestFactory2.
 */
public class CSSmartBDDTestFactory {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDTestFactory.class);
    private static final CSSmartReport REPORT = new CSSmartReport("BDD Test Report", "CSSmart BDD Test Results");
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    private static CSSmartConfig config;
    private static CSSmartBDDScanner scanner;
    private static Set<String> stepProviderPackages = new HashSet<>();
    private static String scenarioFileLocation;
    
    /**
     * Setup operations before the test suite runs.
     * 
     * @param context The test context
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp(ITestContext context) {
        LOGGER.info("Setting up BDD test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Get step provider packages from TestNG parameters
        String stepProviderPkg = context.getCurrentXmlTest().getParameter("step.provider.pkg");
        if (stepProviderPkg != null && !stepProviderPkg.isEmpty()) {
            stepProviderPackages.addAll(Arrays.asList(stepProviderPkg.split(";")));
        } else {
            stepProviderPackages.add("com.cssmart.steps"); // Default package
        }
        
        // Get scenario file location from TestNG parameters
        scenarioFileLocation = context.getCurrentXmlTest().getParameter("scenario.file.loc");
        if (scenarioFileLocation == null || scenarioFileLocation.isEmpty()) {
            scenarioFileLocation = "scenarios"; // Default location
        }
        
        // Initialize step scanner
        scanner = new CSSmartBDDScanner(stepProviderPackages);
        scanner.scanForStepDefinitions();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Environment", config.getString("env", "test"))
              .addEnvironmentInfo("Step Packages", String.join(", ", stepProviderPackages))
              .addEnvironmentInfo("Scenario Location", scenarioFileLocation);
        
        LOGGER.info("BDD test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down BDD test suite");
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("BDD test report generated: {}", reportPath);
    }
    
    /**
     * Creates a data provider for scenarios.
     * 
     * @param context The test context
     * @return Array of scenario data
     */
    @DataProvider(name = "scenarios")
    public Object[][] scenarioDataProvider(ITestContext context) {
        LOGGER.info("Creating data provider for scenarios");
        
        try {
            // Load scenarios from the specified location
            List<CSSmartScenario> scenarios = loadScenarios(scenarioFileLocation);
            LOGGER.info("Found {} scenarios", scenarios.size());
            
            // Create data provider array
            Object[][] data = new Object[scenarios.size()][2];
            for (int i = 0; i < scenarios.size(); i++) {
                CSSmartScenario scenario = scenarios.get(i);
                data[i][0] = scenario.getTitle();
                data[i][1] = scenario;
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error creating data provider", e);
            throw new CSSmartException("Error creating data provider: " + e.getMessage(), e);
        }
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param scenarioTitle The scenario title
     * @param scenario The scenario to run
     * @param context The test context
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(String scenarioTitle, CSSmartScenario scenario, ITestContext context) {
        LOGGER.info("Setting up BDD test for scenario: {}", scenarioTitle);
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(scenarioTitle, 
                                                              scenario.getFeatureTitle(), 
                                                              CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        LOGGER.info("BDD test setup complete for scenario: {}", scenarioTitle);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        LOGGER.info("Tearing down BDD test: {}", result.getName());
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        testResult.addFailStep("Test failed: " + result.getThrowable().getMessage());
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("BDD test complete: {} with status {}", result.getName(), 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Runs a scenario.
     * 
     * @param scenarioTitle The scenario title
     * @param scenario The scenario to run
     */
    @Test(dataProvider = "scenarios")
    public void runScenario(String scenarioTitle, CSSmartScenario scenario) {
        LOGGER.info("Running scenario: {}", scenarioTitle);
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        try {
            CSSmartBDDExecutor executor = new CSSmartBDDExecutor(scanner, testResult);
            
            // Execute all steps in the scenario
            boolean success = executor.executeScenario(scenario);
            
            if (!success) {
                LOGGER.error("Scenario failed: {}", scenarioTitle);
                throw new CSSmartException("Scenario failed: " + scenarioTitle);
            }
            
            LOGGER.info("Scenario completed successfully: {}", scenarioTitle);
        } catch (Exception e) {
            LOGGER.error("Error executing scenario: {}", scenarioTitle, e);
            throw e;
        }
    }
    
    /**
     * Loads scenarios from the specified location.
     * 
     * @param location The scenario file location
     * @return List of loaded scenarios
     */
    private List<CSSmartScenario> loadScenarios(String location) {
        LOGGER.info("Loading scenarios from location: {}", location);
        List<CSSmartScenario> scenarios = new ArrayList<>();
        
        try {
            // Parse location for multiple paths
            String[] locations = location.split(";");
            
            for (String loc : locations) {
                Path path = Paths.get(loc);
                
                if (Files.isDirectory(path)) {
                    // Find all .scenario files in directory
                    try (Stream<Path> paths = Files.walk(path)) {
                        List<Path> scenarioFiles = paths
                            .filter(Files::isRegularFile)
                            .filter(p -> p.toString().endsWith(".scenario") || p.toString().endsWith(".feature"))
                            .collect(Collectors.toList());
                        
                        for (Path scenarioFile : scenarioFiles) {
                            scenarios.addAll(parseScenarioFile(scenarioFile));
                        }
                    }
                } else if (Files.isRegularFile(path)) {
                    // Parse single scenario file
                    scenarios.addAll(parseScenarioFile(path));
                } else {
                    LOGGER.warn("Scenario location not found: {}", loc);
                }
            }
        } catch (IOException e) {
            LOGGER.error("Error loading scenarios", e);
            throw new CSSmartException("Error loading scenarios: " + e.getMessage(), e);
        }
        
        return scenarios;
    }
    
    /**
     * Parses a scenario file into scenario objects.
     * 
     * @param scenarioFile The scenario file path
     * @return List of scenarios
     */
    private List<CSSmartScenario> parseScenarioFile(Path scenarioFile) {
        LOGGER.info("Parsing scenario file: {}", scenarioFile);
        List<CSSmartScenario> scenarios = new ArrayList<>();
        
        try {
            CSSmartBDDParser parser = new CSSmartBDDParser();
            scenarios.addAll(parser.parseFile(scenarioFile));
        } catch (Exception e) {
            LOGGER.error("Error parsing scenario file: {}", scenarioFile, e);
            throw new CSSmartException("Error parsing scenario file: " + e.getMessage(), e);
        }
        
        return scenarios;
    }
}



package com.cssmart.core.bdd;

import com.cssmart.core.exception.CSSmartException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;

import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Executor to run BDD scenarios and steps.
 */
public class CSSmartBDDExecutor {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartBDDExecutor.class);
    
    private final CSSmartBDDScanner scanner;
    private final CSSmartTestResult testResult;
    
    /**
     * Constructs a new CSSmartBDDExecutor.
     * 
     * @param scanner The BDD scanner with step definitions
     * @param testResult The test result for reporting
     */
    public CSSmartBDDExecutor(CSSmartBDDScanner scanner, CSSmartTestResult testResult) {
        this.scanner = scanner;
        this.testResult = testResult;
    }
    
    /**
     * Executes a scenario.
     * 
     * @param scenario The scenario to execute
     * @return true if executed successfully, false otherwise
     */
    public boolean executeScenario(CSSmartScenario scenario) {
        LOGGER.info("Executing scenario: {}", scenario.getTitle());
        
        if (testResult != null) {
            testResult.addInfoStep("Starting scenario: " + scenario.getTitle());
        }
        
        List<String> steps = scenario.getSteps();
        if (steps.isEmpty()) {
            LOGGER.warn("Scenario has no steps: {}", scenario.getTitle());
            return true;
        }
        
        boolean allSuccess = true;
        
        for (String step : steps) {
            try {
                boolean success = executeStep(step);
                if (!success) {
                    allSuccess = false;
                    break;
                }
            } catch (Exception e) {
                LOGGER.error("Error executing step: {}", step, e);
                
                if (testResult != null) {
                    testResult.addFailStep("Failed to execute step: " + step)
                             .setErrorMessage(e.getMessage());
                }
                
                return false;
            }
        }
        
        if (allSuccess && testResult != null) {
            testResult.addPassStep("Scenario completed successfully: " + scenario.getTitle());
        }
        
        return allSuccess;
    }
    
    /**
     * Executes a step.
     * 
     * @param step The step to execute
     * @return true if executed successfully, false otherwise
     */
    public boolean executeStep(String step) {
        LOGGER.info("Executing step: {}", step);
        
        // Find matching step definition
        Map.Entry<Pattern, Method> matchingStep = scanner.findMatchingStepDefinition(step);
        
        if (matchingStep == null) {
            String errorMessage = "No matching step definition found for: " + step;
            LOGGER.error(errorMessage);
            
            if (testResult != null) {
                testResult.addFailStep(step)
                         .setErrorMessage(errorMessage);
            }
            
            return false;
        }
        
        Pattern pattern = matchingStep.getKey();
        Method method = matchingStep.getValue();
        
        // Extract parameters from step
        List<String> parameters = extractStepParameters(pattern, step);
        
        // Execute step definition
        try {
            // Get step instance
            Object stepInstance = getStepInstance(method.getDeclaringClass());
            
            // Convert parameters to method argument types
            Object[] args = convertParameters(parameters, method);
            
            // Add step info to report
            if (testResult != null) {
                testResult.addInfoStep("Executing step: " + step);
            }
            
            // Track execution time for threshold warning
            long startTime = System.currentTimeMillis();
            
            // Execute step
            method.setAccessible(true);
            Object result = method.invoke(stepInstance, args);
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            // Check execution time against threshold
            CSSmartTestStep annotation = method.getAnnotation(CSSmartTestStep.class);
            if (annotation.threshold() > 0 && executionTime > annotation.threshold()) {
                LOGGER.warn("Step execution exceeded threshold ({} ms): {} (took {} ms)", 
                          annotation.threshold(), step, executionTime);
                
                if (testResult != null) {
                    testResult.addWarningStep("Step execution time (" + executionTime + 
                                            " ms) exceeded threshold (" + annotation.threshold() + " ms)");
                }
            }
            
            // Add success to report
            if (testResult != null) {
                testResult.addPassStep("Step completed: " + step);
            }
            
            LOGGER.debug("Step executed successfully: {}", step);
            return true;
            
        } catch (Exception e) {
            String errorMessage = "Error executing step: " + e.getMessage();
            LOGGER.error(errorMessage, e);
            
            if (testResult != null) {
                testResult.addFailStep(step)
                         .setErrorMessage(errorMessage);
            }
            
            if (e.getCause() instanceof CSSmartException) {
                throw (CSSmartException) e.getCause();
            } else {
                throw new CSSmartException("Failed to execute step: " + step, e);
            }
        }
    }
    
    /**
     * Gets or creates an instance of a step definition class.
     * This method is designed to be overridden by subclasses to customize
     * step instance creation and management.
     * 
     * @param stepClass The step class
     * @return The step instance
     */
    protected Object getStepInstance(Class<?> stepClass) {
        return scanner.createStepInstance(stepClass);
    }
    
    /**
     * Extracts parameters from a step statement based on the matching pattern.
     * 
     * @param pattern The matching pattern
     * @param step The step statement
     * @return List of extracted parameters
     */
    private List<String> extractStepParameters(Pattern pattern, String step) {
        List<String> parameters = new ArrayList<>();
        Matcher matcher = pattern.matcher(step);
        
        if (matcher.matches()) {
            for (int i = 1; i <= matcher.groupCount(); i++) {
                String param = matcher.group(i);
                // Remove quotes from quoted parameters
                if (param.startsWith("\"") && param.endsWith("\"")) {
                    param = param.substring(1, param.length() - 1);
                }
                parameters.add(param);
            }
        }
        
        return parameters;
    }
    
    /**
     * Converts string parameters to the appropriate types for a method.
     * 
     * @param parameters The string parameters
     * @param method The method to invoke
     * @return Array of converted parameters
     */
    private Object[] convertParameters(List<String> parameters, Method method) {
        Class<?>[] paramTypes = method.getParameterTypes();
        Object[] args = new Object[paramTypes.length];
        
        for (int i = 0; i < paramTypes.length && i < parameters.size(); i++) {
            String param = parameters.get(i);
            Class<?> type = paramTypes[i];
            
            args[i] = convertParameter(param, type);
        }
        
        return args;
    }
    
    /**
     * Converts a string parameter to the specified type.
     * 
     * @param param The string parameter
     * @param type The target type
     * @return The converted parameter
     */
    private Object convertParameter(String param, Class<?> type) {
        if (type == String.class) {
            return param;
        } else if (type == int.class || type == Integer.class) {
            return Integer.parseInt(param);
        } else if (type == long.class || type == Long.class) {
            return Long.parseLong(param);
        } else if (type == double.class || type == Double.class) {
            return Double.parseDouble(param);
        } else if (type == boolean.class || type == Boolean.class) {
            return Boolean.parseBoolean(param);
        } else if (type == float.class || type == Float.class) {
            return Float.parseFloat(param);
        } else if (type.isEnum()) {
            return Enum.valueOf((Class<Enum>) type, param);
        } else {
            throw new CSSmartException("Unsupported parameter type: " + type.getName());
        }
    }
}



package com.cssmart.example.steps;

import com.cssmart.core.bdd.CSSmartBaseTestSteps;
import com.cssmart.core.bdd.CSSmartTestStep;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.testng.Assert;

/**
 * Login step definitions using the CSSmartTestStep annotation.
 */
public class LoginSteps extends CSSmartBaseTestSteps {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(LoginSteps.class);
    
    /**
     * Constructor that accepts a driver from the test factory.
     * 
     * @param driver The driver instance
     */
    public LoginSteps(CSSmartDriver driver) {
        super(driver);
    }
    
    
    /**
     * Navigates to the login page.
     */
    @CSSmartTestStep(description = "I navigate to the login page")
    public void navigateToLoginPage() {
        LOGGER.info("Navigating to login page");
        navigateTo("/login");
    }
    
    /**
     * Enters username and password.
     * 
     * @param username The username
     * @param password The password
     */
    @CSSmartTestStep(description = "I enter username {username} and password {password}")
    public void enterCredentials(String username, String password) {
        LOGGER.info("Entering credentials: username={}, password=****", username);
        driver.sendKeys(By.id("username"), username);
        driver.sendKeys(By.id("password"), password);
    }
    
    /**
     * Clicks the login button.
     */
    @CSSmartTestStep(description = "I click the login button")
    public void clickLoginButton() {
        LOGGER.info("Clicking login button");
        driver.click(By.id("loginBtn"));
        driver.waitForPageLoad();
    }
    
    /**
     * Verifies successful login.
     */
    @CSSmartTestStep(description = "I should be logged in successfully")
    public void verifySuccessfulLogin() {
        LOGGER.info("Verifying successful login");
        boolean isLoggedIn = driver.elementExists(By.id("welcomeMessage"));
        Assert.assertTrue(isLoggedIn, "User should be logged in successfully");
    }
    
    /**
     * Verifies welcome message.
     */
    @CSSmartTestStep(description = "I should see the welcome message")
    public void verifyWelcomeMessage() {
        LOGGER.info("Verifying welcome message");
        String welcomeMessage = driver.getText(By.id("welcomeMessage"));
        Assert.assertTrue(welcomeMessage.contains("Welcome"), 
                        "Welcome message should contain 'Welcome'");
    }
    
    /**
     * Verifies error message.
     * 
     * @param expectedMessage The expected error message
     */
    @CSSmartTestStep(description = "I should see an error message {expectedMessage}")
    public void verifyErrorMessage(String expectedMessage) {
        LOGGER.info("Verifying error message: {}", expectedMessage);
        String actualMessage = driver.getText(By.id("errorMessage"));
        Assert.assertEquals(actualMessage, expectedMessage, 
                          "Error message should match expected message");
    }
    
    /**
     * Verifies status message.
     * 
     * @param status The expected status
     */
    @CSSmartTestStep(description = "I should see status {status}")
    public void verifyStatus(String status) {
        LOGGER.info("Verifying status: {}", status);
        boolean isSuccess = "success".equalsIgnoreCase(status);
        boolean actualSuccess = driver.elementExists(By.id("welcomeMessage"));
        Assert.assertEquals(actualSuccess, isSuccess, 
                          "Login status should match expected status");
    }
    
    /**
     * Verifies message.
     * 
     * @param expectedMessage The expected message
     */
    @CSSmartTestStep(description = "I should see message {expectedMessage}")
    public void verifyMessage(String expectedMessage) {
        LOGGER.info("Verifying message: {}", expectedMessage);
        String actualMessage = "";
        
        if (driver.elementExists(By.id("welcomeMessage"))) {
            actualMessage = driver.getText(By.id("welcomeMessage"));
        } else if (driver.elementExists(By.id("errorMessage"))) {
            actualMessage = driver.getText(By.id("errorMessage"));
        }
        
        Assert.assertEquals(actualMessage, expectedMessage, 
                          "Message should match expected message");
    }
    

}



package com.cssmart.core.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Enhanced element location annotation with additional capabilities.
 * Supports standard Selenium locators plus description-based and self-healing features.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.TYPE})
public @interface CSSmartFindBy {
    /**
     * ID locator strategy
     */
    String id() default "";
    
    /**
     * Name locator strategy
     */
    String name() default "";
    
    /**
     * Class name locator strategy
     */
    String className() default "";
    
    /**
     * CSS selector locator strategy
     */
    String css() default "";
    
    /**
     * Tag name locator strategy
     */
    String tagName() default "";
    
    /**
     * Link text locator strategy
     */
    String linkText() default "";
    
    /**
     * Partial link text locator strategy
     */
    String partialLinkText() default "";
    
    /**
     * XPath locator strategy
     */
    String xpath() default "";
    
    /**
     * Human-readable description of the element.
     * Used for reporting and self-healing.
     */
    String description() default "";
    
    /**
     * Timeout in seconds for finding this element
     */
    int timeoutInSeconds() default 30;
    
    /**
     * Whether this element is optional.
     * If true, no exception will be thrown if the element is not found.
     */
    boolean optional() default false;
    
    /**
     * Alternative locator expressions for self-healing.
     * Format: "strategy=expression", e.g., "css=#login", "xpath=//button[@id='login']"
     */
    String[] alternateLocators() default {};
    
    /**
     * AI assistance level for finding this element.
     */
    AIAssistance aiAssistance() default AIAssistance.AUTO;
    
    /**
     * Enum for AI assistance levels.
     */
    enum AIAssistance {
        /**
         * No AI assistance, use only explicit locators.
         */
        NONE,
        
        /**
         * Use AI only if explicit locators fail.
         */
        FALLBACK,
        
        /**
         * Let the framework decide when to use AI.
         */
        AUTO,
        
        /**
         * Always prioritize AI-based location.
         */
        PRIORITIZE
    }
}



package com.cssmart.core.annotation;

import com.cssmart.core.ai.CSSmartAIElementFinder;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.element.CSSmartWebElement;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.pagefactory.ElementLocator;
import org.openqa.selenium.support.pagefactory.ElementLocatorFactory;

import java.lang.reflect.Field;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * Processor for CSSmartFindBy annotation.
 * Handles enhanced element location with self-healing capabilities.
 */
public class CSSmartFindByProcessor {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartFindByProcessor.class);
    
    private final ElementLocatorFactory factory;
    private final CSSmartDriver driver;
    private final CSSmartAIElementFinder aiFinder;
    
    /**
     * Constructs a new CSSmartFindByProcessor.
     * 
     * @param factory The element locator factory
     * @param driver The CSSmartDriver instance
     */
    public CSSmartFindByProcessor(ElementLocatorFactory factory, CSSmartDriver driver) {
        this.factory = factory;
        this.driver = driver;
        this.aiFinder = new CSSmartAIElementFinder(driver, driver.getConfig());
    }
    
    /**
     * Creates an element locator for a field with CSSmartFindBy annotation.
     * 
     * @param field The field to create a locator for
     * @return The element locator
     */
    public ElementLocator createLocator(Field field) {
        CSSmartFindBy annotation = field.getAnnotation(CSSmartFindBy.class);
        
        if (annotation == null) {
            // If no CSSmartFindBy annotation, delegate to the factory
            return factory.createLocator(field);
        }
        
        return new CSSmartElementLocator(field, annotation, driver, aiFinder);
    }
    
    /**
     * Custom element locator for CSSmartFindBy annotation.
     */
    private static class CSSmartElementLocator implements ElementLocator {
        private final Field field;
        private final CSSmartFindBy annotation;
        private final CSSmartDriver driver;
        private final CSSmartAIElementFinder aiFinder;
        private final List<By> locators = new ArrayList<>();
        private final String description;
        private final boolean optional;
        private final Duration timeout;
        private final CSSmartFindBy.AIAssistance aiAssistance;
        
        /**
         * Constructs a new CSSmartElementLocator.
         * 
         * @param field The field to create a locator for
         * @param annotation The CSSmartFindBy annotation
         * @param driver The CSSmartDriver instance
         * @param aiFinder The CSSmartAIElementFinder instance
         */
        public CSSmartElementLocator(Field field, CSSmartFindBy annotation, 
                                     CSSmartDriver driver, CSSmartAIElementFinder aiFinder) {
            this.field = field;
            this.annotation = annotation;
            this.driver = driver;
            this.aiFinder = aiFinder;
            this.description = annotation.description();
            this.optional = annotation.optional();
            this.timeout = Duration.ofSeconds(annotation.timeoutInSeconds());
            this.aiAssistance = annotation.aiAssistance();
            
            // Process primary locator
            By primaryLocator = processLocatorAnnotation(annotation);
            if (primaryLocator != null) {
                locators.add(primaryLocator);
            }
            
            // Process alternate locators
            for (String alternateLocatorStr : annotation.alternateLocators()) {
                By alternateLocator = parseLocatorString(alternateLocatorStr);
                if (alternateLocator != null) {
                    locators.add(alternateLocator);
                }
            }
            
            if (locators.isEmpty() && aiAssistance == CSSmartFindBy.AIAssistance.NONE && 
                (description == null || description.isEmpty())) {
                LOGGER.error("No locators defined for element: {}", field.getName());
                throw new IllegalArgumentException("No locators defined for element: " + field.getName());
            }
        }
        
        /**
         * Creates a By locator from the CSSmartFindBy annotation.
         * 
         * @param annotation The CSSmartFindBy annotation
         * @return The By locator
         */
        private By processLocatorAnnotation(CSSmartFindBy annotation) {
            if (!annotation.id().isEmpty()) {
                return By.id(annotation.id());
            } else if (!annotation.name().isEmpty()) {
                return By.name(annotation.name());
            } else if (!annotation.className().isEmpty()) {
                return By.className(annotation.className());
            } else if (!annotation.css().isEmpty()) {
                return By.cssSelector(annotation.css());
            } else if (!annotation.tagName().isEmpty()) {
                return By.tagName(annotation.tagName());
            } else if (!annotation.linkText().isEmpty()) {
                return By.linkText(annotation.linkText());
            } else if (!annotation.partialLinkText().isEmpty()) {
                return By.partialLinkText(annotation.partialLinkText());
            } else if (!annotation.xpath().isEmpty()) {
                return By.xpath(annotation.xpath());
            }
            
            return null;
        }
        
        /**
         * Parses a locator string in the format "strategy=expression".
         * 
         * @param locatorStr The locator string
         * @return The By locator
         */
        private By parseLocatorString(String locatorStr) {
            String[] parts = locatorStr.split("=", 2);
            if (parts.length != 2) {
                LOGGER.warn("Invalid locator format: {}", locatorStr);
                return null;
            }
            
            String strategy = parts[0].trim().toLowerCase();
            String expression = parts[1].trim();
            
            switch (strategy) {
                case "id":
                    return By.id(expression);
                case "name":
                    return By.name(expression);
                case "classname":
                case "class":
                    return By.className(expression);
                case "css":
                case "cssselector":
                    return By.cssSelector(expression);
                case "tagname":
                case "tag":
                    return By.tagName(expression);
                case "linktext":
                case "link":
                    return By.linkText(expression);
                case "partiallinktext":
                case "partiallink":
                    return By.partialLinkText(expression);
                case "xpath":
                    return By.xpath(expression);
                default:
                    LOGGER.warn("Unknown locator strategy: {}", strategy);
                    return null;
            }
        }
        
        @Override
        public WebElement findElement() {
            LOGGER.debug("Finding element for field: {}", field.getName());
            
            // Check if AI should be prioritized
            if (aiAssistance == CSSmartFindBy.AIAssistance.PRIORITIZE && 
                description != null && !description.isEmpty()) {
                try {
                    WebElement element = aiFinder.findElementByDescription(description);
                    return wrapElement(element);
                } catch (Exception e) {
                    LOGGER.debug("AI-based element finding failed, trying explicit locators");
                }
            }
            
            // Try all explicit locators
            List<Exception> exceptions = new ArrayList<>();
            for (By locator : locators) {
                try {
                    WebElement element = driver.findElement(locator, timeout);
                    return wrapElement(element);
                } catch (Exception e) {
                    exceptions.add(e);
                    LOGGER.debug("Failed to find element with locator: {}", locator, e);
                }
            }
            
            // If explicit locators failed, try AI as fallback
            if ((aiAssistance == CSSmartFindBy.AIAssistance.FALLBACK || 
                 aiAssistance == CSSmartFindBy.AIAssistance.AUTO) && 
                description != null && !description.isEmpty()) {
                try {
                    WebElement element = aiFinder.findElementByDescription(description);
                    return wrapElement(element);
                } catch (Exception e) {
                    exceptions.add(e);
                    LOGGER.debug("AI-based fallback element finding failed", e);
                }
            }
            
            // If optional, return null instead of throwing an exception
            if (optional) {
                LOGGER.info("Optional element not found for field: {}", field.getName());
                return null;
            }
            
            // If all attempts failed, throw an exception with combined info
            throw new CSSmartElementNotFoundException(
                "Failed to find element for field: " + field.getName() + 
                " using " + locators.size() + " locators. " + 
                (description != null && !description.isEmpty() ? 
                 "Description: " + description : ""), 
                locators.isEmpty() ? null : locators.get(0),
                exceptions.isEmpty() ? null : exceptions.get(0)
            );
        }
        
        @Override
        public List<WebElement> findElements() {
            LOGGER.debug("Finding elements for field: {}", field.getName());
            
            // For collections, use only the first locator for simplicity
            if (!locators.isEmpty()) {
                try {
                    List<WebElement> elements = driver.findElements(locators.get(0), timeout);
                    return wrapElements(elements);
                } catch (Exception e) {
                    LOGGER.debug("Failed to find elements with locator: {}", locators.get(0), e);
                }
            }
            
            // Return empty list for optional elements
            if (optional) {
                LOGGER.info("Optional elements not found for field: {}", field.getName());
                return new ArrayList<>();
            }
            
            throw new CSSmartElementNotFoundException(
                "Failed to find elements for field: " + field.getName(),
                locators.isEmpty() ? null : locators.get(0));
        }
        
        /**
         * Wraps a WebElement in a CSSmartWebElement.
         * 
         * @param element The WebElement to wrap
         * @return The wrapped element
         */
        private WebElement wrapElement(WebElement element) {
            if (element == null) {
                return null;
            }
            
            return new CSSmartWebElement(
                driver, 
                locators.isEmpty() ? null : locators.get(0),
                element,
                timeout,
                description
            );
        }
        
        /**
         * Wraps a list of WebElements in CSSmartWebElements.
         * 
         * @param elements The WebElements to wrap
         * @return The wrapped elements
         */
        private List<WebElement> wrapElements(List<WebElement> elements) {
            if (elements == null) {
                return new ArrayList<>();
            }
            
            List<WebElement> wrappedElements = new ArrayList<>();
            for (WebElement element : elements) {
                wrappedElements.add(wrapElement(element));
            }
            
            return wrappedElements;
        }
    }
}



package com.cssmart.core.element;

import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Enhanced WebElement implementation with additional functionality,
 * error handling, and logging.
 */
public class CSSmartWebElement implements WebElement {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartWebElement.class);
    
    private final CSSmartDriver driver;
    private final By locator;
    private final WebElement element;
    private final Duration defaultTimeout;
    private final String description;
    
    /**
     * Constructs a new CSSmartWebElement.
     * 
     * @param driver The CSSmartDriver
     * @param locator The locator for this element
     * @param element The underlying WebElement
     * @param defaultTimeout The default timeout for operations
     * @param description Human-readable description of the element
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, WebElement element, 
                           Duration defaultTimeout, String description) {
        this.driver = driver;
        this.locator = locator;
        this.element = element;
        this.defaultTimeout = defaultTimeout;
        this.description = description;
    }
    
    /**
     * Constructs a new CSSmartWebElement.
     * 
     * @param driver The CSSmartDriver
     * @param locator The locator for this element
     * @param element The underlying WebElement
     * @param defaultTimeout The default timeout for operations
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, WebElement element, Duration defaultTimeout) {
        this(driver, locator, element, defaultTimeout, null);
    }
    
    /**
     * Constructs a new CSSmartWebElement.
     * 
     * @param driver The CSSmartDriver
     * @param locator The locator for this element
     * @param element The underlying WebElement
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, WebElement element) {
        this(driver, locator, element, Duration.ofSeconds(30), null);
    }
    
    /**
     * Gets the locator for this element.
     * 
     * @return The By locator
     */
    public By getLocator() {
        return locator;
    }
    
    /**
     * Gets the underlying WebElement.
     * 
     * @return The WebElement
     */
    public WebElement getElement() {
        return element;
    }
    
    /**
     * Gets the description of this element.
     * 
     * @return The element description, or null if none was provided
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Gets a descriptive string for this element, using the description if available.
     * 
     * @return A descriptive string for logging and reporting
     */
    public String getDescriptiveString() {
        if (description != null && !description.isEmpty()) {
            return description + (locator != null ? " (" + locator + ")" : "");
        } else if (locator != null) {
            return locator.toString();
        } else {
            return element.toString();
        }
    }
    
    /**
     * Clicks the element with retry logic.
     */
    @Override
    public void click() {
        LOGGER.debug("Clicking element: {}", locator);
        try {
            waitForElementToBeClickable();
            element.click();
            LOGGER.debug("Clicked element: {}", locator);
        } catch (ElementClickInterceptedException e) {
            LOGGER.warn("Element click intercepted, trying JavaScript click: {}", locator);
            jsClick();
        } catch (Exception e) {
            LOGGER.error("Failed to click element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Performs a JavaScript click on the element.
     */
    public void jsClick() {
        LOGGER.debug("Performing JavaScript click on element: {}", locator);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver.getDriver();
            js.executeScript("arguments[0].click();", element);
            LOGGER.debug("Performed JavaScript click on element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to perform JavaScript click on element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Submits a form.
     */
    @Override
    public void submit() {
        LOGGER.debug("Submitting form with element: {}", locator);
        try {
            element.submit();
            LOGGER.debug("Submitted form with element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to submit form with element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Sends keys to the element.
     * 
     * @param charSequences Text to send
     */
    @Override
    public void sendKeys(CharSequence... charSequences) {
        sendKeys(true, charSequences);
    }
    
    /**
     * Sends keys to the element with option to clear first.
     * 
     * @param clearFirst Whether to clear the field first
     * @param charSequences Text to send
     */
    public void sendKeys(boolean clearFirst, CharSequence... charSequences) {
        LOGGER.debug("Sending keys to element: {} text: {}", locator, charSequences);
        try {
            if (clearFirst) {
                clear();
            }
            element.sendKeys(charSequences);
            LOGGER.debug("Sent keys to element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to send keys to element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Types text slowly, character by character.
     * Useful for JS-heavy inputs that validate during typing.
     * 
     * @param text Text to type
     * @param delayMillis Delay between characters in milliseconds
     */
    public void typeSlowly(String text, long delayMillis) {
        LOGGER.debug("Typing slowly to element: {} text: {}", locator, text);
        try {
            clear();
            for (char c : text.toCharArray()) {
                element.sendKeys(String.valueOf(c));
                try {
                    Thread.sleep(delayMillis);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    LOGGER.warn("Slow typing interrupted", e);
                }
            }
            LOGGER.debug("Typed slowly to element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to type slowly to element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Clears the element content.
     */
    @Override
    public void clear() {
        LOGGER.debug("Clearing element: {}", locator);
        try {
            element.clear();
            LOGGER.debug("Cleared element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to clear element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the tag name of the element.
     * 
     * @return The tag name
     */
    @Override
    public String getTagName() {
        LOGGER.debug("Getting tag name for element: {}", locator);
        try {
            String tagName = element.getTagName();
            LOGGER.debug("Got tag name for element: {} tagName: {}", locator, tagName);
            return tagName;
        } catch (Exception e) {
            LOGGER.error("Failed to get tag name for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the attribute value of the element.
     * 
     * @param name The attribute name
     * @return The attribute value
     */
    @Override
    public String getAttribute(String name) {
        LOGGER.debug("Getting attribute '{}' for element: {}", name, locator);
        try {
            String value = element.getAttribute(name);
            LOGGER.debug("Got attribute '{}' for element: {} value: {}", name, locator, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute '{}' for element: {}", name, locator, e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is selected.
     * 
     * @return true if selected, false otherwise
     */
    @Override
    public boolean isSelected() {
        LOGGER.debug("Checking if element is selected: {}", locator);
        try {
            boolean selected = element.isSelected();
            LOGGER.debug("Element selected status: {} isSelected: {}", locator, selected);
            return selected;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element is selected: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is enabled.
     * 
     * @return true if enabled, false otherwise
     */
    @Override
    public boolean isEnabled() {
        LOGGER.debug("Checking if element is enabled: {}", locator);
        try {
            boolean enabled = element.isEnabled();
            LOGGER.debug("Element enabled status: {} isEnabled: {}", locator, enabled);
            return enabled;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element is enabled: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the text content of the element.
     * 
     * @return The text content
     */
    @Override
    public String getText() {
        LOGGER.debug("Getting text for element: {}", locator);
        try {
            String text = element.getText();
            LOGGER.debug("Got text for element: {} text: {}", locator, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get text for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Finds all child elements matching the given locator.
     * 
     * @param by The locator for child elements
     * @return List of child elements
     */
    @Override
    public List<WebElement> findElements(By by) {
        LOGGER.debug("Finding child elements {} within parent: {}", by, locator);
        try {
            List<WebElement> elements = element.findElements(by);
            LOGGER.debug("Found {} child elements within parent: {}", elements.size(), locator);
            
            // Wrap all WebElements in CSSmartWebElement
            return elements.stream()
                .map(webElement -> new CSSmartWebElement(driver, by, webElement, defaultTimeout))
                .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Failed to find child elements {} within parent: {}", by, locator, e);
            throw e;
        }
    }
    
    /**
     * Finds a child element matching the given locator.
     * 
     * @param by The locator for the child element
     * @return The child element
     */
    @Override
    public WebElement findElement(By by) {
        LOGGER.debug("Finding child element {} within parent: {}", by, locator);
        try {
            WebElement childElement = element.findElement(by);
            LOGGER.debug("Found child element within parent: {}", locator);
            return new CSSmartWebElement(driver, by, childElement, defaultTimeout);
        } catch (Exception e) {
            LOGGER.error("Failed to find child element {} within parent: {}", by, locator, e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is displayed.
     * 
     * @return true if displayed, false otherwise
     */
    @Override
    public boolean isDisplayed() {
        LOGGER.debug("Checking if element is displayed: {}", locator);
        try {
            boolean displayed = element.isDisplayed();
            LOGGER.debug("Element displayed status: {} isDisplayed: {}", locator, displayed);
            return displayed;
        } catch (Exception e) {
            LOGGER.debug("Element is not displayed: {} - {}", locator, e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets the element location.
     * 
     * @return The element location
     */
    @Override
    public Point getLocation() {
        LOGGER.debug("Getting location for element: {}", locator);
        try {
            Point location = element.getLocation();
            LOGGER.debug("Got location for element: {} location: {}", locator, location);
            return location;
        } catch (Exception e) {
            LOGGER.error("Failed to get location for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the element size.
     * 
     * @return The element size
     */
    @Override
    public Dimension getSize() {
        LOGGER.debug("Getting size for element: {}", locator);
        try {
            Dimension size = element.getSize();
            LOGGER.debug("Got size for element: {} size: {}", locator, size);
            return size;
        } catch (Exception e) {
            LOGGER.error("Failed to get size for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the element CSS value.
     * 
     * @param propertyName The CSS property name
     * @return The CSS value
     */
    @Override
    public String getCssValue(String propertyName) {
        LOGGER.debug("Getting CSS value '{}' for element: {}", propertyName, locator);
        try {
            String value = element.getCssValue(propertyName);
            LOGGER.debug("Got CSS value '{}' for element: {} value: {}", propertyName, locator, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get CSS value '{}' for element: {}", propertyName, locator, e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be clickable.
     * 
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeClickable() {
        return waitForElementToBeClickable(defaultTimeout);
    }
    
    /**
     * Waits for the element to be clickable with custom timeout.
     * 
     * @param timeout The timeout duration
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeClickable(Duration timeout) {
        LOGGER.debug("Waiting for element to be clickable: {}", locator);
        try {
            WebDriverWait wait = new WebDriverWait(driver.getDriver(), timeout);
            wait.until(ExpectedConditions.elementToBeClickable(element));
            LOGGER.debug("Element is now clickable: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Element not clickable within timeout: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be visible.
     * 
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeVisible() {
        return waitForElementToBeVisible(defaultTimeout);
    }
    
    /**
     * Waits for the element to be visible with custom timeout.
     * 
     * @param timeout The timeout duration
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeVisible(Duration timeout) {
        LOGGER.debug("Waiting for element to be visible: {}", locator);
        try {
            WebDriverWait wait = new WebDriverWait(driver.getDriver(), timeout);
            wait.until(ExpectedConditions.visibilityOf(element));
            LOGGER.debug("Element is now visible: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Element not visible within timeout: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to contain text.
     * 
     * @param text The text to wait for
     * @return This element
     */
    public CSSmartWebElement waitForTextToBe(String text) {
        return waitForTextToBe(text, defaultTimeout);
    }
    
    /**
     * Waits for the element to contain text with custom timeout.
     * 
     * @param text The text to wait for
     * @param timeout The timeout duration
     * @return This element
     */
    public CSSmartWebElement waitForTextToBe(String text, Duration timeout) {
        LOGGER.debug("Waiting for element text to be '{}': {}", text, locator);
        try {
            WebDriverWait wait = new WebDriverWait(driver.getDriver(), timeout);
            wait.until(ExpectedConditions.textToBePresentInElement(element, text));
            LOGGER.debug("Element text is now '{}': {}", text, locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Element text not '{}' within timeout: {}", text, locator, e);
            throw e;
        }
    }
    
    /**
     * Scrolls the element into view.
     * 
     * @return This element
     */
    public CSSmartWebElement scrollIntoView() {
        LOGGER.debug("Scrolling element into view: {}", locator);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver.getDriver();
            js.executeScript("arguments[0].scrollIntoView(true);", element);
            LOGGER.debug("Scrolled element into view: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to scroll element into view: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Hovers over the element.
     * 
     * @return This element
     */
    public CSSmartWebElement hover() {
        LOGGER.debug("Hovering over element: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.moveToElement(element).perform();
            LOGGER.debug("Hovered over element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Performs right-click on the element.
     * 
     * @return This element
     */
    public CSSmartWebElement rightClick() {
        LOGGER.debug("Right-clicking element: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.contextClick(element).perform();
            LOGGER.debug("Right-clicked element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to right-click element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Performs double-click on the element.
     * 
     * @return This element
     */
    public CSSmartWebElement doubleClick() {
        LOGGER.debug("Double-clicking element: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.doubleClick(element).perform();
            LOGGER.debug("Double-clicked element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to double-click element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Drags this element and drops it onto another element.
     * 
     * @param target The target element to drop onto
     * @return This element
     */
    public CSSmartWebElement dragAndDropTo(WebElement target) {
        LOGGER.debug("Dragging element to target: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.dragAndDrop(element, target).perform();
            LOGGER.debug("Dragged element to target: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to drag element to target: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Highlights the element temporarily for visual debugging.
     * 
     * @return This element
     */
    public CSSmartWebElement highlight() {
        return highlight(Duration.ofSeconds(2));
    }
    
    /**
     * Highlights the element for a specified duration.
     * 
     * @param duration The highlight duration
     * @return This element
     */
    public CSSmartWebElement highlight(Duration duration) {
        LOGGER.debug("Highlighting element: {}", locator);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver.getDriver();
            
            // Store original style
            String originalStyle = element.getAttribute("style");
            
            // Apply highlight
            js.executeScript(
                "arguments[0].setAttribute('style', 'border: 2px solid red; background-color: yellow;');",
                element);
            
            // Wait for specified duration
            try {
                Thread.sleep(duration.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            // Restore original style
            js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);",
                element, originalStyle);
            
            LOGGER.debug("Highlighted element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to highlight element: {}", locator, e);
            // Non-critical error, don't throw
            return this;
        }
    }
    
    /**
     * Takes a screenshot of this element.
     * 
     * @return The screenshot as bytes
     */
    public byte[] takeScreenshot() {
        LOGGER.debug("Taking screenshot of element: {}", locator);
        try {
            if (element instanceof TakesScreenshot) {
                byte[] screenshot = ((TakesScreenshot) element).getScreenshotAs(OutputType.BYTES);
                LOGGER.debug("Took screenshot of element: {}", locator);
                return screenshot;
            } else {
                LOGGER.warn("Element does not support taking screenshots: {}", locator);
                throw new UnsupportedOperationException("Element does not support taking screenshots");
            }
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot of element: {}", locator, e);
            throw e;
        }
    }

    @Override
    public <X> X getScreenshotAs(OutputType<X> outputType) throws WebDriverException {
        LOGGER.debug("Getting screenshot as {}: {}", outputType, locator);
        try {
            X screenshot = element.getScreenshotAs(outputType);
            LOGGER.debug("Got screenshot: {}", locator);
            return screenshot;
        } catch (Exception e) {
            LOGGER.error("Failed to get screenshot: {}", locator, e);
            throw e;
        }
    }

    @Override
    public Rectangle getRect() {
        LOGGER.debug("Getting rectangle for element: {}", locator);
        try {
            Rectangle rect = element.getRect();
            LOGGER.debug("Got rectangle for element: {} rect: {}", locator, rect);
            return rect;
        } catch (Exception e) {
            LOGGER.error("Failed to get rectangle for element: {}", locator, e);
            throw e;
        }
    }
}



package com.cssmart.core.element;

import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Enhanced WebElement implementation with additional functionality,
 * error handling, and logging.
 */
public class CSSmartWebElement implements WebElement {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartWebElement.class);
    
    private final CSSmartDriver driver;
    private final By locator;
    private final WebElement element;
    private final Duration defaultTimeout;
    private final String description;
    
    /**
     * Constructs a new CSSmartWebElement.
     * 
     * @param driver The CSSmartDriver
     * @param locator The locator for this element
     * @param element The underlying WebElement
     * @param defaultTimeout The default timeout for operations
     * @param description Human-readable description of the element
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, WebElement element, 
                           Duration defaultTimeout, String description) {
        this.driver = driver;
        this.locator = locator;
        this.element = element;
        this.defaultTimeout = defaultTimeout;
        this.description = description;
    }
    
    /**
     * Constructs a new CSSmartWebElement.
     * 
     * @param driver The CSSmartDriver
     * @param locator The locator for this element
     * @param element The underlying WebElement
     * @param defaultTimeout The default timeout for operations
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, WebElement element, Duration defaultTimeout) {
        this(driver, locator, element, defaultTimeout, null);
    }
    
    /**
     * Constructs a new CSSmartWebElement.
     * 
     * @param driver The CSSmartDriver
     * @param locator The locator for this element
     * @param element The underlying WebElement
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, WebElement element) {
        this(driver, locator, element, Duration.ofSeconds(30), null);
    }
    
    /**
     * Gets the locator for this element.
     * 
     * @return The By locator
     */
    public By getLocator() {
        return locator;
    }
    
    /**
     * Gets the underlying WebElement.
     * 
     * @return The WebElement
     */
    public WebElement getElement() {
        return element;
    }
    
    /**
     * Gets the description of this element.
     * 
     * @return The element description, or null if none was provided
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Gets a descriptive string for this element, using the description if available.
     * 
     * @return A descriptive string for logging and reporting
     */
    public String getDescriptiveString() {
        if (description != null && !description.isEmpty()) {
            return description + (locator != null ? " (" + locator + ")" : "");
        } else if (locator != null) {
            return locator.toString();
        } else {
            return element.toString();
        }
    }
    
    /**
     * Clicks the element with retry logic.
     */
    @Override
    public void click() {
        LOGGER.debug("Clicking element: {}", getDescriptiveString());
        try {
            waitForElementToBeClickable();
            
            // Log this action to the test report
            driver.logAction("Clicked element: " + getDescriptiveString());
            
            element.click();
            LOGGER.debug("Clicked element: {}", getDescriptiveString());
        } catch (ElementClickInterceptedException e) {
            LOGGER.warn("Element click intercepted, trying JavaScript click: {}", getDescriptiveString());
            jsClick();
        } catch (Exception e) {
            LOGGER.error("Failed to click element: {}", getDescriptiveString(), e);
            throw e;
        }
    }
    
    /**
     * Performs a JavaScript click on the element.
     */
    public void jsClick() {
        LOGGER.debug("Performing JavaScript click on element: {}", locator);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver.getDriver();
            js.executeScript("arguments[0].click();", element);
            LOGGER.debug("Performed JavaScript click on element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to perform JavaScript click on element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Submits a form.
     */
    @Override
    public void submit() {
        LOGGER.debug("Submitting form with element: {}", locator);
        try {
            element.submit();
            LOGGER.debug("Submitted form with element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to submit form with element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Sends keys to the element.
     * 
     * @param charSequences Text to send
     */
    @Override
    public void sendKeys(CharSequence... charSequences) {
        sendKeys(true, charSequences);
    }
    
    /**
     * Sends keys to the element with option to clear first.
     * 
     * @param clearFirst Whether to clear the field first
     * @param charSequences Text to send
     */
    public void sendKeys(boolean clearFirst, CharSequence... charSequences) {
        LOGGER.debug("Sending keys to element: {} text: {}", getDescriptiveString(), charSequences);
        try {
            if (clearFirst) {
                clear();
            }
            
            // Log this action to the test report
            StringBuilder textToLog = new StringBuilder();
            for (CharSequence cs : charSequences) {
                textToLog.append(cs);
            }
            
            // Check if it might be a password field
            boolean isPassword = isPasswordField();
            String maskedText = isPassword ? "********" : textToLog.toString();
            
            driver.logAction("Entered text: " + maskedText + " in " + getDescriptiveString());
            
            element.sendKeys(charSequences);
            LOGGER.debug("Sent keys to element: {}", getDescriptiveString());
        } catch (Exception e) {
            LOGGER.error("Failed to send keys to element: {}", getDescriptiveString(), e);
            throw e;
        }
    }
    
    /**
     * Checks if this element is likely a password field.
     * 
     * @return true if it's a password field, false otherwise
     */
    private boolean isPasswordField() {
        try {
            String type = element.getAttribute("type");
            return "password".equalsIgnoreCase(type);
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Types text slowly, character by character.
     * Useful for JS-heavy inputs that validate during typing.
     * 
     * @param text Text to type
     * @param delayMillis Delay between characters in milliseconds
     */
    public void typeSlowly(String text, long delayMillis) {
        LOGGER.debug("Typing slowly to element: {} text: {}", locator, text);
        try {
            clear();
            for (char c : text.toCharArray()) {
                element.sendKeys(String.valueOf(c));
                try {
                    Thread.sleep(delayMillis);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    LOGGER.warn("Slow typing interrupted", e);
                }
            }
            LOGGER.debug("Typed slowly to element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to type slowly to element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Clears the element content.
     */
    @Override
    public void clear() {
        LOGGER.debug("Clearing element: {}", locator);
        try {
            element.clear();
            LOGGER.debug("Cleared element: {}", locator);
        } catch (Exception e) {
            LOGGER.error("Failed to clear element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the tag name of the element.
     * 
     * @return The tag name
     */
    @Override
    public String getTagName() {
        LOGGER.debug("Getting tag name for element: {}", locator);
        try {
            String tagName = element.getTagName();
            LOGGER.debug("Got tag name for element: {} tagName: {}", locator, tagName);
            return tagName;
        } catch (Exception e) {
            LOGGER.error("Failed to get tag name for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the attribute value of the element.
     * 
     * @param name The attribute name
     * @return The attribute value
     */
    @Override
    public String getAttribute(String name) {
        LOGGER.debug("Getting attribute '{}' for element: {}", name, locator);
        try {
            String value = element.getAttribute(name);
            LOGGER.debug("Got attribute '{}' for element: {} value: {}", name, locator, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute '{}' for element: {}", name, locator, e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is selected.
     * 
     * @return true if selected, false otherwise
     */
    @Override
    public boolean isSelected() {
        LOGGER.debug("Checking if element is selected: {}", locator);
        try {
            boolean selected = element.isSelected();
            LOGGER.debug("Element selected status: {} isSelected: {}", locator, selected);
            return selected;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element is selected: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is enabled.
     * 
     * @return true if enabled, false otherwise
     */
    @Override
    public boolean isEnabled() {
        LOGGER.debug("Checking if element is enabled: {}", locator);
        try {
            boolean enabled = element.isEnabled();
            LOGGER.debug("Element enabled status: {} isEnabled: {}", locator, enabled);
            return enabled;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element is enabled: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the text content of the element.
     * 
     * @return The text content
     */
    @Override
    public String getText() {
        LOGGER.debug("Getting text for element: {}", locator);
        try {
            String text = element.getText();
            LOGGER.debug("Got text for element: {} text: {}", locator, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get text for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Finds all child elements matching the given locator.
     * 
     * @param by The locator for child elements
     * @return List of child elements
     */
    @Override
    public List<WebElement> findElements(By by) {
        LOGGER.debug("Finding child elements {} within parent: {}", by, locator);
        try {
            List<WebElement> elements = element.findElements(by);
            LOGGER.debug("Found {} child elements within parent: {}", elements.size(), locator);
            
            // Wrap all WebElements in CSSmartWebElement
            return elements.stream()
                .map(webElement -> new CSSmartWebElement(driver, by, webElement, defaultTimeout))
                .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Failed to find child elements {} within parent: {}", by, locator, e);
            throw e;
        }
    }
    
    /**
     * Finds a child element matching the given locator.
     * 
     * @param by The locator for the child element
     * @return The child element
     */
    @Override
    public WebElement findElement(By by) {
        LOGGER.debug("Finding child element {} within parent: {}", by, locator);
        try {
            WebElement childElement = element.findElement(by);
            LOGGER.debug("Found child element within parent: {}", locator);
            return new CSSmartWebElement(driver, by, childElement, defaultTimeout);
        } catch (Exception e) {
            LOGGER.error("Failed to find child element {} within parent: {}", by, locator, e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is displayed.
     * 
     * @return true if displayed, false otherwise
     */
    @Override
    public boolean isDisplayed() {
        LOGGER.debug("Checking if element is displayed: {}", locator);
        try {
            boolean displayed = element.isDisplayed();
            LOGGER.debug("Element displayed status: {} isDisplayed: {}", locator, displayed);
            return displayed;
        } catch (Exception e) {
            LOGGER.debug("Element is not displayed: {} - {}", locator, e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets the element location.
     * 
     * @return The element location
     */
    @Override
    public Point getLocation() {
        LOGGER.debug("Getting location for element: {}", locator);
        try {
            Point location = element.getLocation();
            LOGGER.debug("Got location for element: {} location: {}", locator, location);
            return location;
        } catch (Exception e) {
            LOGGER.error("Failed to get location for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the element size.
     * 
     * @return The element size
     */
    @Override
    public Dimension getSize() {
        LOGGER.debug("Getting size for element: {}", locator);
        try {
            Dimension size = element.getSize();
            LOGGER.debug("Got size for element: {} size: {}", locator, size);
            return size;
        } catch (Exception e) {
            LOGGER.error("Failed to get size for element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Gets the element CSS value.
     * 
     * @param propertyName The CSS property name
     * @return The CSS value
     */
    @Override
    public String getCssValue(String propertyName) {
        LOGGER.debug("Getting CSS value '{}' for element: {}", propertyName, locator);
        try {
            String value = element.getCssValue(propertyName);
            LOGGER.debug("Got CSS value '{}' for element: {} value: {}", propertyName, locator, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get CSS value '{}' for element: {}", propertyName, locator, e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be clickable.
     * 
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeClickable() {
        return waitForElementToBeClickable(defaultTimeout);
    }
    
    /**
     * Waits for the element to be clickable with custom timeout.
     * 
     * @param timeout The timeout duration
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeClickable(Duration timeout) {
        LOGGER.debug("Waiting for element to be clickable: {}", locator);
        try {
            WebDriverWait wait = new WebDriverWait(driver.getDriver(), timeout);
            wait.until(ExpectedConditions.elementToBeClickable(element));
            LOGGER.debug("Element is now clickable: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Element not clickable within timeout: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be visible.
     * 
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeVisible() {
        return waitForElementToBeVisible(defaultTimeout);
    }
    
    /**
     * Waits for the element to be visible with custom timeout.
     * 
     * @param timeout The timeout duration
     * @return This element
     */
    public CSSmartWebElement waitForElementToBeVisible(Duration timeout) {
        LOGGER.debug("Waiting for element to be visible: {}", locator);
        try {
            WebDriverWait wait = new WebDriverWait(driver.getDriver(), timeout);
            wait.until(ExpectedConditions.visibilityOf(element));
            LOGGER.debug("Element is now visible: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Element not visible within timeout: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to contain text.
     * 
     * @param text The text to wait for
     * @return This element
     */
    public CSSmartWebElement waitForTextToBe(String text) {
        return waitForTextToBe(text, defaultTimeout);
    }
    
    /**
     * Waits for the element to contain text with custom timeout.
     * 
     * @param text The text to wait for
     * @param timeout The timeout duration
     * @return This element
     */
    public CSSmartWebElement waitForTextToBe(String text, Duration timeout) {
        LOGGER.debug("Waiting for element text to be '{}': {}", text, locator);
        try {
            WebDriverWait wait = new WebDriverWait(driver.getDriver(), timeout);
            wait.until(ExpectedConditions.textToBePresentInElement(element, text));
            LOGGER.debug("Element text is now '{}': {}", text, locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Element text not '{}' within timeout: {}", text, locator, e);
            throw e;
        }
    }
    
    /**
     * Scrolls the element into view.
     * 
     * @return This element
     */
    public CSSmartWebElement scrollIntoView() {
        LOGGER.debug("Scrolling element into view: {}", locator);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver.getDriver();
            js.executeScript("arguments[0].scrollIntoView(true);", element);
            LOGGER.debug("Scrolled element into view: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to scroll element into view: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Hovers over the element.
     * 
     * @return This element
     */
    public CSSmartWebElement hover() {
        LOGGER.debug("Hovering over element: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.moveToElement(element).perform();
            LOGGER.debug("Hovered over element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Performs right-click on the element.
     * 
     * @return This element
     */
    public CSSmartWebElement rightClick() {
        LOGGER.debug("Right-clicking element: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.contextClick(element).perform();
            LOGGER.debug("Right-clicked element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to right-click element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Performs double-click on the element.
     * 
     * @return This element
     */
    public CSSmartWebElement doubleClick() {
        LOGGER.debug("Double-clicking element: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.doubleClick(element).perform();
            LOGGER.debug("Double-clicked element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to double-click element: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Drags this element and drops it onto another element.
     * 
     * @param target The target element to drop onto
     * @return This element
     */
    public CSSmartWebElement dragAndDropTo(WebElement target) {
        LOGGER.debug("Dragging element to target: {}", locator);
        try {
            Actions actions = new Actions(driver.getDriver());
            actions.dragAndDrop(element, target).perform();
            LOGGER.debug("Dragged element to target: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to drag element to target: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Highlights the element temporarily for visual debugging.
     * 
     * @return This element
     */
    public CSSmartWebElement highlight() {
        return highlight(Duration.ofSeconds(2));
    }
    
    /**
     * Highlights the element for a specified duration.
     * 
     * @param duration The highlight duration
     * @return This element
     */
    public CSSmartWebElement highlight(Duration duration) {
        LOGGER.debug("Highlighting element: {}", locator);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver.getDriver();
            
            // Store original style
            String originalStyle = element.getAttribute("style");
            
            // Apply highlight
            js.executeScript(
                "arguments[0].setAttribute('style', 'border: 2px solid red; background-color: yellow;');",
                element);
            
            // Wait for specified duration
            try {
                Thread.sleep(duration.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            // Restore original style
            js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);",
                element, originalStyle);
            
            LOGGER.debug("Highlighted element: {}", locator);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to highlight element: {}", locator, e);
            // Non-critical error, don't throw
            return this;
        }
    }
    
    /**
     * Takes a screenshot of this element.
     * 
     * @return The screenshot as bytes
     */
    public byte[] takeScreenshot() {
        LOGGER.debug("Taking screenshot of element: {}", locator);
        try {
            if (element instanceof TakesScreenshot) {
                byte[] screenshot = ((TakesScreenshot) element).getScreenshotAs(OutputType.BYTES);
                LOGGER.debug("Took screenshot of element: {}", locator);
                return screenshot;
            } else {
                LOGGER.warn("Element does not support taking screenshots: {}", locator);
                throw new UnsupportedOperationException("Element does not support taking screenshots");
            }
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot of element: {}", locator, e);
            throw e;
        }
    }

    @Override
    public <X> X getScreenshotAs(OutputType<X> outputType) throws WebDriverException {
        LOGGER.debug("Getting screenshot as {}: {}", outputType, locator);
        try {
            X screenshot = element.getScreenshotAs(outputType);
            LOGGER.debug("Got screenshot: {}", locator);
            return screenshot;
        } catch (Exception e) {
            LOGGER.error("Failed to get screenshot: {}", locator, e);
            throw e;
        }
    }

    @Override
    public Rectangle getRect() {
        LOGGER.debug("Getting rectangle for element: {}", locator);
        try {
            Rectangle rect = element.getRect();
            LOGGER.debug("Got rectangle for element: {} rect: {}", locator, rect);
            return rect;
        } catch (Exception e) {
            LOGGER.error("Failed to get rectangle for element: {}", locator, e);
            throw e;
        }
    }
}



package com.cssmart.core.driver;

import com.cssmart.core.ai.CSSmartAIElementFinder;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.WaitUtils;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Thread-safe WebDriver wrapper with enhanced driving capabilities.
 * Provides centralized driver management with advanced navigation,
 * interaction, and synchronization features.
 */
public class CSSmartDriver {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartDriver.class);
    private static final ThreadLocal<WebDriver> DRIVER_THREAD_LOCAL = new ThreadLocal<>();
    private static final Map<Long, WebDriver> ALL_DRIVERS = new ConcurrentHashMap<>();
    
    // Map of failed locators to their successful alternatives for self-healing
    private final Map<By, By> healedLocators = new HashMap<>();
    
    // Current test result for logging actions
    private ThreadLocal<CSSmartTestResult> currentTestResult = new ThreadLocal<>();
    
    // AI element finder for self-healing
    private CSSmartAIElementFinder aiFinder;
    
    protected final CSSmartConfig config;
    private final Duration defaultTimeout;
    private final Duration pollingInterval;
    private final boolean enableSelfHealing;
    
    /**
     * Constructs a new CSSmartDriver with the specified configuration.
     * 
     * @param config The framework configuration
     */
    public CSSmartDriver(CSSmartConfig config) {
        this.config = config;
        this.defaultTimeout = Duration.ofSeconds(config.getLong("driver.timeout.default", 30));
        this.pollingInterval = Duration.ofMillis(config.getLong("driver.polling.interval", 500));
        this.enableSelfHealing = config.getBoolean("driver.selfHealing.enabled", true);
    }
    
    /**
     * Sets the current test result for action logging.
     * 
     * @param testResult The test result to use for logging
     * @return This driver instance for method chaining
     */
    public CSSmartDriver setCurrentTestResult(CSSmartTestResult testResult) {
        currentTestResult.set(testResult);
        return this;
    }
    
    /**
     * Gets the current test result.
     * 
     * @return The current test result, or null if not set
     */
    public CSSmartTestResult getCurrentTestResult() {
        return currentTestResult.get();
    }
    
    /**
     * Logs an action to the current test result.
     * 
     * @param actionDescription The action description
     */
    public void logAction(String actionDescription) {
        CSSmartTestResult testResult = getCurrentTestResult();
        if (testResult != null) {
            testResult.addInfoStep(actionDescription);
        }
    }
    
    /**
     * Gets the CSSmartAIElementFinder instance, creating it if necessary.
     * 
     * @return The CSSmartAIElementFinder instance
     */
    public CSSmartAIElementFinder getAIFinder() {
        if (aiFinder == null) {
            aiFinder = new CSSmartAIElementFinder(this, config);
        }
        return aiFinder;
    }
    
    /**
     * Gets the current WebDriver instance for this thread or creates a new one if none exists.
     * 
     * @return The WebDriver instance for the current thread
     */
    public WebDriver getDriver() {
        WebDriver driver = DRIVER_THREAD_LOCAL.get();
        if (driver == null) {
            LOGGER.info("No WebDriver found for current thread. Initializing new driver.");
            driver = initializeDriver();
            DRIVER_THREAD_LOCAL.set(driver);
            ALL_DRIVERS.put(Thread.currentThread().getId(), driver);
        }
        return driver;
    }
    
    /**
     * Initializes a new WebDriver based on configuration.
     * This method should be extended to support different browser types.
     * 
     * @return A new WebDriver instance
     */
    protected WebDriver initializeDriver() {
        // This will be implemented by specific browser driver classes
        // For now, we'll throw an exception as this is meant to be extended
        throw new UnsupportedOperationException(
            "CSSmartDriver is an abstract driver manager. Please use a specific browser driver implementation.");
    }
    
    /**
     * Navigates to the specified URL with logging and error handling.
     * 
     * @param url The URL to navigate to
     */
    public void navigateTo(String url) {
        LOGGER.info("Navigating to: {}", url);
        try {
            getDriver().get(url);
            LOGGER.debug("Successfully navigated to: {}", url);
        } catch (WebDriverException e) {
            LOGGER.error("Failed to navigate to URL: {}", url, e);
            throw e;
        }
    }
    
    /**
     * Finds an element with wait and logging.
     * 
     * @param by The locator to find the element
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by) {
        return findElement(by, defaultTimeout);
    }
    
    /**
     * Finds an element with a custom timeout.
     * 
     * @param by The locator to find the element
     * @param timeout The timeout duration
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by, Duration timeout) {
        LOGGER.debug("Finding element: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            return wait.until(ExpectedConditions.presenceOfElementLocated(by));
        } catch (TimeoutException e) {
            LOGGER.error("Element not found within timeout: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Finds all elements matching the locator.
     * 
     * @param by The locator to find elements
     * @return List of found WebElements
     */
    public List<WebElement> findElements(By by) {
        return findElements(by, defaultTimeout);
    }
    
    /**
     * Finds all elements matching the locator with custom timeout.
     * 
     * @param by The locator to find elements
     * @param timeout The timeout duration
     * @return List of found WebElements
     */
    public List<WebElement> findElements(By by, Duration timeout) {
        LOGGER.debug("Finding elements: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            return wait.until(driver -> {
                List<WebElement> elements = driver.findElements(by);
                return elements.isEmpty() ? null : elements;
            });
        } catch (TimeoutException e) {
            LOGGER.debug("No elements found within timeout: {}", by);
            return List.of();
        }
    }
    
    /**
     * Checks if an element exists on the page.
     * 
     * @param by The locator to check
     * @return true if element exists, false otherwise
     */
    public boolean elementExists(By by) {
        return elementExists(by, Duration.ofSeconds(5));
    }
    
    /**
     * Checks if an element exists on the page with custom timeout.
     * 
     * @param by The locator to check
     * @param timeout The timeout duration
     * @return true if element exists, false otherwise
     */
    public boolean elementExists(By by, Duration timeout) {
        try {
            findElement(by, timeout);
            return true;
        } catch (TimeoutException e) {
            return false;
        }
    }
    
    /**
     * Waits for an element to be clickable then clicks it.
     * 
     * @param by The locator of the element to click
     */
    public void click(By by) {
        click(by, defaultTimeout);
    }
    
    /**
     * Waits for an element to be clickable then clicks it with custom timeout.
     * 
     * @param by The locator of the element to click
     * @param timeout The timeout duration
     */
    public void click(By by, Duration timeout) {
        LOGGER.debug("Clicking on element: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            WebElement element = wait.until(ExpectedConditions.elementToBeClickable(by));
            element.click();
            LOGGER.debug("Clicked element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to click element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Performs JavaScript click on an element when standard click might not work.
     * 
     * @param by The locator of the element to click
     */
    public void jsClick(By by) {
        LOGGER.debug("Performing JavaScript click on element: {}", by);
        try {
            WebElement element = findElement(by);
            JavascriptExecutor js = (JavascriptExecutor) getDriver();
            js.executeScript("arguments[0].click();", element);
            LOGGER.debug("Performed JavaScript click on element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to perform JavaScript click on element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Types text into an input element after clearing its existing value.
     * 
     * @param by The locator of the input element
     * @param text The text to type
     */
    public void sendKeys(By by, String text) {
        sendKeys(by, text, true);
    }
    
    /**
     * Types text into an input element with option to clear first.
     * 
     * @param by The locator of the input element
     * @param text The text to type
     * @param clearFirst Whether to clear the field first
     */
    public void sendKeys(By by, String text, boolean clearFirst) {
        LOGGER.debug("Sending keys to element: {} text: {}", by, text);
        try {
            WebElement element = findElement(by);
            if (clearFirst) {
                element.clear();
            }
            element.sendKeys(text);
            LOGGER.debug("Sent keys to element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to send keys to element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Selects an option from dropdown by visible text.
     * 
     * @param by The locator of the select element
     * @param visibleText The visible text of the option to select
     */
    public void selectByVisibleText(By by, String visibleText) {
        LOGGER.debug("Selecting option with text '{}' from dropdown: {}", visibleText, by);
        try {
            WebElement element = findElement(by);
            org.openqa.selenium.support.ui.Select select = 
                new org.openqa.selenium.support.ui.Select(element);
            select.selectByVisibleText(visibleText);
            LOGGER.debug("Selected option with text: {}", visibleText);
        } catch (Exception e) {
            LOGGER.error("Failed to select option with text '{}' from dropdown: {}", 
                visibleText, by, e);
            throw e;
        }
    }
    
    /**
     * Gets text from an element.
     * 
     * @param by The locator of the element
     * @return The text content of the element
     */
    public String getText(By by) {
        LOGGER.debug("Getting text from element: {}", by);
        try {
            WebElement element = findElement(by);
            String text = element.getText();
            LOGGER.debug("Got text from element: {} text: {}", by, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get text from element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Gets attribute value from an element.
     * 
     * @param by The locator of the element
     * @param attributeName The name of the attribute
     * @return The value of the attribute
     */
    public String getAttribute(By by, String attributeName) {
        LOGGER.debug("Getting attribute '{}' from element: {}", attributeName, by);
        try {
            WebElement element = findElement(by);
            String value = element.getAttribute(attributeName);
            LOGGER.debug("Got attribute '{}' from element: {} value: {}", 
                attributeName, by, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute '{}' from element: {}", 
                attributeName, by, e);
            throw e;
        }
    }
    
    /**
     * Hovers over an element.
     * 
     * @param by The locator of the element to hover over
     */
    public void hover(By by) {
        LOGGER.debug("Hovering over element: {}", by);
        try {
            WebElement element = findElement(by);
            Actions actions = new Actions(getDriver());
            actions.moveToElement(element).perform();
            LOGGER.debug("Hovered over element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Executes JavaScript code.
     * 
     * @param script The JavaScript code to execute
     * @param args The arguments to pass to the script
     * @return The result of script execution
     */
    public Object executeScript(String script, Object... args) {
        LOGGER.debug("Executing JavaScript: {}", script);
        try {
            JavascriptExecutor js = (JavascriptExecutor) getDriver();
            Object result = js.executeScript(script, args);
            LOGGER.debug("Executed JavaScript successfully");
            return result;
        } catch (Exception e) {
            LOGGER.error("Failed to execute JavaScript: {}", script, e);
            throw e;
        }
    }
    
    /**
     * Takes a screenshot and returns it as bytes.
     * 
     * @return The screenshot as byte array
     */
    public byte[] takeScreenshot() {
        LOGGER.debug("Taking screenshot");
        try {
            TakesScreenshot screenshotDriver = (TakesScreenshot) getDriver();
            byte[] screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
            LOGGER.debug("Screenshot taken successfully");
            return screenshot;
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot", e);
            throw e;
        }
    }
    
    /**
     * Refreshes the current page.
     */
    public void refresh() {
        LOGGER.debug("Refreshing page");
        try {
            getDriver().navigate().refresh();
            LOGGER.debug("Page refreshed successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to refresh page", e);
            throw e;
        }
    }
    
    /**
     * Navigates back in browser history.
     */
    public void back() {
        LOGGER.debug("Navigating back");
        try {
            getDriver().navigate().back();
            LOGGER.debug("Navigated back successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to navigate back", e);
            throw e;
        }
    }
    
    /**
     * Navigates forward in browser history.
     */
    public void forward() {
        LOGGER.debug("Navigating forward");
        try {
            getDriver().navigate().forward();
            LOGGER.debug("Navigated forward successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to navigate forward", e);
            throw e;
        }
    }
    
    /**
     * Gets the current URL.
     * 
     * @return The current URL
     */
    public String getCurrentUrl() {
        LOGGER.debug("Getting current URL");
        return getDriver().getCurrentUrl();
    }
    
    /**
     * Gets the page title.
     * 
     * @return The page title
     */
    public String getTitle() {
        LOGGER.debug("Getting page title");
        return getDriver().getTitle();
    }
    
    /**
     * Waits for page to load completely.
     */
    public void waitForPageLoad() {
        LOGGER.debug("Waiting for page to load");
        try {
            WaitUtils.waitForCondition(
                driver -> executeScript("return document.readyState").equals("complete"),
                defaultTimeout,
                "Page did not load completely"
            );
            LOGGER.debug("Page loaded successfully");
        } catch (Exception e) {
            LOGGER.error("Page load wait timed out", e);
            throw e;
        }
    }
    
    /**
     * Switches to a frame by locator.
     * 
     * @param by The locator of the frame
     */
    public void switchToFrame(By by) {
        LOGGER.debug("Switching to frame: {}", by);
        try {
            WebElement frameElement = findElement(by);
            getDriver().switchTo().frame(frameElement);
            LOGGER.debug("Switched to frame: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to switch to frame: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Switches back to the main document from a frame.
     */
    public void switchToDefaultContent() {
        LOGGER.debug("Switching to default content");
        try {
            getDriver().switchTo().defaultContent();
            LOGGER.debug("Switched to default content");
        } catch (Exception e) {
            LOGGER.error("Failed to switch to default content", e);
            throw e;
        }
    }
    
    /**
     * Switches to a window/tab by its handle.
     * 
     * @param windowHandle The window handle to switch to
     */
    public void switchToWindow(String windowHandle) {
        LOGGER.debug("Switching to window: {}", windowHandle);
        try {
            getDriver().switchTo().window(windowHandle);
            LOGGER.debug("Switched to window: {}", windowHandle);
        } catch (Exception e) {
            LOGGER.error("Failed to switch to window: {}", windowHandle, e);
            throw e;
        }
    }
    
    /**
     * Gets all window handles.
     * 
     * @return Set of all window handles
     */
    public Set<String> getWindowHandles() {
        LOGGER.debug("Getting all window handles");
        return getDriver().getWindowHandles();
    }
    
    /**
     * Gets the current window handle.
     * 
     * @return The current window handle
     */
    public String getWindowHandle() {
        LOGGER.debug("Getting current window handle");
        return getDriver().getWindowHandle();
    }
    
    /**
     * Accepts an alert if present.
     */
    public void acceptAlert() {
        LOGGER.debug("Accepting alert");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            getDriver().switchTo().alert().accept();
            LOGGER.debug("Alert accepted");
        } catch (Exception e) {
            LOGGER.error("Failed to accept alert", e);
            throw e;
        }
    }
    
    /**
     * Dismisses an alert if present.
     */
    public void dismissAlert() {
        LOGGER.debug("Dismissing alert");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            getDriver().switchTo().alert().dismiss();
            LOGGER.debug("Alert dismissed");
        } catch (Exception e) {
            LOGGER.error("Failed to dismiss alert", e);
            throw e;
        }
    }
    
    /**
     * Gets text from an alert if present.
     * 
     * @return The alert text
     */
    public String getAlertText() {
        LOGGER.debug("Getting alert text");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            String text = getDriver().switchTo().alert().getText();
            LOGGER.debug("Got alert text: {}", text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get alert text", e);
            throw e;
        }
    }
    
    /**
     * Sets browser window size.
     * 
     * @param width The window width
     * @param height The window height
     */
    public void setWindowSize(int width, int height) {
        LOGGER.debug("Setting window size: {}x{}", width, height);
        try {
            getDriver().manage().window().setSize(new Dimension(width, height));
            LOGGER.debug("Window size set to: {}x{}", width, height);
        } catch (Exception e) {
            LOGGER.error("Failed to set window size: {}x{}", width, height, e);
            throw e;
        }
    }
    
    /**
     * Maximizes the browser window.
     */
    public void maximizeWindow() {
        LOGGER.debug("Maximizing window");
        try {
            getDriver().manage().window().maximize();
            LOGGER.debug("Window maximized");
        } catch (Exception e) {
            LOGGER.error("Failed to maximize window", e);
            throw e;
        }
    }
    
    /**
     * Quits the WebDriver for the current thread.
     */
    public void quit() {
        WebDriver driver = DRIVER_THREAD_LOCAL.get();
        if (driver != null) {
            LOGGER.info("Quitting WebDriver for current thread");
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.error("Error while quitting WebDriver", e);
            } finally {
                DRIVER_THREAD_LOCAL.remove();
                ALL_DRIVERS.remove(Thread.currentThread().getId());
            }
        }
    }
    
    /**
     * Quits all WebDriver instances across all threads.
     * Useful for cleanup before test suite completion.
     */
    public static void quitAll() {
        LOGGER.info("Quitting all WebDriver instances");
        ALL_DRIVERS.values().forEach(driver -> {
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.error("Error while quitting WebDriver instance", e);
            }
        });
        
        ALL_DRIVERS.clear();
        DRIVER_THREAD_LOCAL.remove();
    }
}



package com.cssmart.core.driver;

import com.cssmart.core.ai.CSSmartAIElementFinder;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.WaitUtils;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Thread-safe WebDriver wrapper with enhanced driving capabilities.
 * Provides centralized driver management with advanced navigation,
 * interaction, and synchronization features.
 */
public class CSSmartDriver {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartDriver.class);
    private static final ThreadLocal<WebDriver> DRIVER_THREAD_LOCAL = new ThreadLocal<>();
    private static final Map<Long, WebDriver> ALL_DRIVERS = new ConcurrentHashMap<>();
    
    // Map of failed locators to their successful alternatives for self-healing
    private final Map<By, By> healedLocators = new HashMap<>();
    
    // Current test result for logging actions
    private ThreadLocal<CSSmartTestResult> currentTestResult = new ThreadLocal<>();
    
    // AI element finder for self-healing
    private CSSmartAIElementFinder aiFinder;
    
    protected final CSSmartConfig config;
    private final Duration defaultTimeout;
    private final Duration pollingInterval;
    private final boolean enableSelfHealing;
    
    /**
     * Constructs a new CSSmartDriver with the specified configuration.
     * 
     * @param config The framework configuration
     */
    public CSSmartDriver(CSSmartConfig config) {
        this.config = config;
        this.defaultTimeout = Duration.ofSeconds(config.getLong("driver.timeout.default", 30));
        this.pollingInterval = Duration.ofMillis(config.getLong("driver.polling.interval", 500));
        this.enableSelfHealing = config.getBoolean("driver.selfHealing.enabled", true);
    }
    
    /**
     * Sets the current test result for action logging.
     * 
     * @param testResult The test result to use for logging
     * @return This driver instance for method chaining
     */
    public CSSmartDriver setCurrentTestResult(CSSmartTestResult testResult) {
        currentTestResult.set(testResult);
        return this;
    }
    
    /**
     * Gets the current test result.
     * 
     * @return The current test result, or null if not set
     */
    public CSSmartTestResult getCurrentTestResult() {
        return currentTestResult.get();
    }
    
    /**
     * Logs an action to the current test result.
     * 
     * @param actionDescription The action description
     */
    public void logAction(String actionDescription) {
        CSSmartTestResult testResult = getCurrentTestResult();
        if (testResult != null) {
            testResult.addInfoStep(actionDescription);
        }
    }
    
    /**
     * Gets the CSSmartAIElementFinder instance, creating it if necessary.
     * 
     * @return The CSSmartAIElementFinder instance
     */
    public CSSmartAIElementFinder getAIFinder() {
        if (aiFinder == null) {
            aiFinder = new CSSmartAIElementFinder(this, config);
        }
        return aiFinder;
    }
    
    /**
     * Gets the current WebDriver instance for this thread or creates a new one if none exists.
     * 
     * @return The WebDriver instance for the current thread
     */
    public WebDriver getDriver() {
        WebDriver driver = DRIVER_THREAD_LOCAL.get();
        if (driver == null) {
            LOGGER.info("No WebDriver found for current thread. Initializing new driver.");
            driver = initializeDriver();
            DRIVER_THREAD_LOCAL.set(driver);
            ALL_DRIVERS.put(Thread.currentThread().getId(), driver);
        }
        return driver;
    }
    
    /**
     * Initializes a new WebDriver based on configuration.
     * This method should be extended to support different browser types.
     * 
     * @return A new WebDriver instance
     */
    protected WebDriver initializeDriver() {
        // This will be implemented by specific browser driver classes
        // For now, we'll throw an exception as this is meant to be extended
        throw new UnsupportedOperationException(
            "CSSmartDriver is an abstract driver manager. Please use a specific browser driver implementation.");
    }
    
    /**
     * Navigates to the specified URL with logging and error handling.
     * 
     * @param url The URL to navigate to
     */
    public void navigateTo(String url) {
        LOGGER.info("Navigating to: {}", url);
        try {
            getDriver().get(url);
            LOGGER.debug("Successfully navigated to: {}", url);
        } catch (WebDriverException e) {
            LOGGER.error("Failed to navigate to URL: {}", url, e);
            throw e;
        }
    }
    
    /**
     * Finds an element with wait and logging.
     * 
     * @param by The locator to find the element
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by) {
        return findElement(by, defaultTimeout);
    }
    
    /**
     * Finds an element with a custom timeout.
     * 
     * @param by The locator to find the element
     * @param timeout The timeout duration
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by, Duration timeout) {
        return findElement(by, timeout, null);
    }
    
    /**
     * Finds an element with a custom timeout and description.
     * 
     * @param by The locator to find the element
     * @param timeout The timeout duration
     * @param description Human-readable description of the element
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by, Duration timeout, String description) {
        LOGGER.debug("Finding element: {}{}", by, 
                   description != null ? " (" + description + ")" : "");
        
        try {
            // First check if we already have a healed locator for this
            if (enableSelfHealing && healedLocators.containsKey(by)) {
                By healedLocator = healedLocators.get(by);
                LOGGER.debug("Using previously healed locator: {}", healedLocator);
                
                try {
                    WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
                    WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(healedLocator));
                    return new com.cssmart.core.element.CSSmartWebElement(this, healedLocator, element, timeout, description);
                } catch (Exception e) {
                    // If healed locator fails, remove it and try original path
                    LOGGER.debug("Healed locator failed, will try original: {}", by);
                    healedLocators.remove(by);
                }
            }
            
            // Try the original locator
            try {
                WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
                WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
                return new com.cssmart.core.element.CSSmartWebElement(this, by, element, timeout, description);
            } catch (TimeoutException originalException) {
                // If self-healing is enabled and we have a description, try AI-based recovery
                if (enableSelfHealing && description != null && !description.isEmpty()) {
                    LOGGER.info("Attempting self-healing for element: {}", description);
                    
                    try {
                        // Try to find the element by description using AI
                        WebElement element = getAIFinder().findElementByDescription(description);
                        
                        // If found, get its locator for future use
                        String elementId = element.getAttribute("id");
                        if (elementId != null && !elementId.isEmpty()) {
                            By newLocator = By.id(elementId);
                            healedLocators.put(by, newLocator);
                            LOGGER.info("Self-healing successful. Original: {}, New: {}", by, newLocator);
                            return new com.cssmart.core.element.CSSmartWebElement(this, newLocator, element, timeout, description);
                        }
                        
                        // If id is not available, try other attributes
                        String elementClass = element.getAttribute("class");
                        if (elementClass != null && !elementClass.isEmpty()) {
                            // Create a more specific locator using class and tag
                            String tagName = element.getTagName();
                            By newLocator = By.cssSelector(tagName + "." + elementClass.replace(" ", "."));
                            healedLocators.put(by, newLocator);
                            LOGGER.info("Self-healing successful. Original: {}, New: {}", by, newLocator);
                            return new com.cssmart.core.element.CSSmartWebElement(this, newLocator, element, timeout, description);
                        }
                        
                        // If no better locator found, just use the element directly
                        LOGGER.info("Self-healing partially successful but couldn't create reliable locator");
                        return new com.cssmart.core.element.CSSmartWebElement(this, by, element, timeout, description);
                        
                    } catch (Exception aiException) {
                        LOGGER.error("Self-healing failed: {}", aiException.getMessage());
                        // Throw the original exception
                        throw originalException;
                    }
                } else {
                    throw originalException;
                }
            }
        } catch (TimeoutException e) {
            LOGGER.error("Element not found within timeout: {}{}", by, 
                       description != null ? " (" + description + ")" : "", e);
            throw e;
        }
    }
    
    /**
     * Finds all elements matching the locator.
     * 
     * @param by The locator to find elements
     * @return List of found WebElements
     */
    public List<WebElement> findElements(By by) {
        return findElements(by, defaultTimeout);
    }
    
    /**
     * Finds all elements matching the locator with custom timeout.
     * 
     * @param by The locator to find elements
     * @param timeout The timeout duration
     * @return List of found WebElements
     */
    public List<WebElement> findElements(By by, Duration timeout) {
        LOGGER.debug("Finding elements: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            return wait.until(driver -> {
                List<WebElement> elements = driver.findElements(by);
                return elements.isEmpty() ? null : elements;
            });
        } catch (TimeoutException e) {
            LOGGER.debug("No elements found within timeout: {}", by);
            return List.of();
        }
    }
    
    /**
     * Checks if an element exists on the page.
     * 
     * @param by The locator to check
     * @return true if element exists, false otherwise
     */
    public boolean elementExists(By by) {
        return elementExists(by, Duration.ofSeconds(5));
    }
    
    /**
     * Checks if an element exists on the page with custom timeout.
     * 
     * @param by The locator to check
     * @param timeout The timeout duration
     * @return true if element exists, false otherwise
     */
    public boolean elementExists(By by, Duration timeout) {
        try {
            findElement(by, timeout);
            return true;
        } catch (TimeoutException e) {
            return false;
        }
    }
    
    /**
     * Waits for an element to be clickable then clicks it.
     * 
     * @param by The locator of the element to click
     */
    public void click(By by) {
        click(by, defaultTimeout);
    }
    
    /**
     * Waits for an element to be clickable then clicks it with custom timeout.
     * 
     * @param by The locator of the element to click
     * @param timeout The timeout duration
     */
    public void click(By by, Duration timeout) {
        LOGGER.debug("Clicking on element: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            WebElement element = wait.until(ExpectedConditions.elementToBeClickable(by));
            element.click();
            LOGGER.debug("Clicked element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to click element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Performs JavaScript click on an element when standard click might not work.
     * 
     * @param by The locator of the element to click
     */
    public void jsClick(By by) {
        LOGGER.debug("Performing JavaScript click on element: {}", by);
        try {
            WebElement element = findElement(by);
            JavascriptExecutor js = (JavascriptExecutor) getDriver();
            js.executeScript("arguments[0].click();", element);
            LOGGER.debug("Performed JavaScript click on element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to perform JavaScript click on element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Types text into an input element after clearing its existing value.
     * 
     * @param by The locator of the input element
     * @param text The text to type
     */
    public void sendKeys(By by, String text) {
        sendKeys(by, text, true);
    }
    
    /**
     * Types text into an input element with option to clear first.
     * 
     * @param by The locator of the input element
     * @param text The text to type
     * @param clearFirst Whether to clear the field first
     */
    public void sendKeys(By by, String text, boolean clearFirst) {
        LOGGER.debug("Sending keys to element: {} text: {}", by, text);
        try {
            WebElement element = findElement(by);
            if (clearFirst) {
                element.clear();
            }
            element.sendKeys(text);
            LOGGER.debug("Sent keys to element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to send keys to element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Selects an option from dropdown by visible text.
     * 
     * @param by The locator of the select element
     * @param visibleText The visible text of the option to select
     */
    public void selectByVisibleText(By by, String visibleText) {
        LOGGER.debug("Selecting option with text '{}' from dropdown: {}", visibleText, by);
        try {
            WebElement element = findElement(by);
            org.openqa.selenium.support.ui.Select select = 
                new org.openqa.selenium.support.ui.Select(element);
            select.selectByVisibleText(visibleText);
            LOGGER.debug("Selected option with text: {}", visibleText);
        } catch (Exception e) {
            LOGGER.error("Failed to select option with text '{}' from dropdown: {}", 
                visibleText, by, e);
            throw e;
        }
    }
    
    /**
     * Gets text from an element.
     * 
     * @param by The locator of the element
     * @return The text content of the element
     */
    public String getText(By by) {
        LOGGER.debug("Getting text from element: {}", by);
        try {
            WebElement element = findElement(by);
            String text = element.getText();
            LOGGER.debug("Got text from element: {} text: {}", by, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get text from element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Gets attribute value from an element.
     * 
     * @param by The locator of the element
     * @param attributeName The name of the attribute
     * @return The value of the attribute
     */
    public String getAttribute(By by, String attributeName) {
        LOGGER.debug("Getting attribute '{}' from element: {}", attributeName, by);
        try {
            WebElement element = findElement(by);
            String value = element.getAttribute(attributeName);
            LOGGER.debug("Got attribute '{}' from element: {} value: {}", 
                attributeName, by, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute '{}' from element: {}", 
                attributeName, by, e);
            throw e;
        }
    }
    
    /**
     * Hovers over an element.
     * 
     * @param by The locator of the element to hover over
     */
    public void hover(By by) {
        LOGGER.debug("Hovering over element: {}", by);
        try {
            WebElement element = findElement(by);
            Actions actions = new Actions(getDriver());
            actions.moveToElement(element).perform();
            LOGGER.debug("Hovered over element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Executes JavaScript code.
     * 
     * @param script The JavaScript code to execute
     * @param args The arguments to pass to the script
     * @return The result of script execution
     */
    public Object executeScript(String script, Object... args) {
        LOGGER.debug("Executing JavaScript: {}", script);
        try {
            JavascriptExecutor js = (JavascriptExecutor) getDriver();
            Object result = js.executeScript(script, args);
            LOGGER.debug("Executed JavaScript successfully");
            return result;
        } catch (Exception e) {
            LOGGER.error("Failed to execute JavaScript: {}", script, e);
            throw e;
        }
    }
    
    /**
     * Takes a screenshot and returns it as bytes.
     * 
     * @return The screenshot as byte array
     */
    public byte[] takeScreenshot() {
        LOGGER.debug("Taking screenshot");
        try {
            TakesScreenshot screenshotDriver = (TakesScreenshot) getDriver();
            byte[] screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
            LOGGER.debug("Screenshot taken successfully");
            return screenshot;
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot", e);
            throw e;
        }
    }
    
    /**
     * Refreshes the current page.
     */
    public void refresh() {
        LOGGER.debug("Refreshing page");
        try {
            getDriver().navigate().refresh();
            LOGGER.debug("Page refreshed successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to refresh page", e);
            throw e;
        }
    }
    
    /**
     * Navigates back in browser history.
     */
    public void back() {
        LOGGER.debug("Navigating back");
        try {
            getDriver().navigate().back();
            LOGGER.debug("Navigated back successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to navigate back", e);
            throw e;
        }
    }
    
    /**
     * Navigates forward in browser history.
     */
    public void forward() {
        LOGGER.debug("Navigating forward");
        try {
            getDriver().navigate().forward();
            LOGGER.debug("Navigated forward successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to navigate forward", e);
            throw e;
        }
    }
    
    /**
     * Gets the current URL.
     * 
     * @return The current URL
     */
    public String getCurrentUrl() {
        LOGGER.debug("Getting current URL");
        return getDriver().getCurrentUrl();
    }
    
    /**
     * Gets the page title.
     * 
     * @return The page title
     */
    public String getTitle() {
        LOGGER.debug("Getting page title");
        return getDriver().getTitle();
    }
    
    /**
     * Waits for page to load completely.
     */
    public void waitForPageLoad() {
        LOGGER.debug("Waiting for page to load");
        try {
            WaitUtils.waitForCondition(
                driver -> executeScript("return document.readyState").equals("complete"),
                defaultTimeout,
                "Page did not load completely"
            );
            LOGGER.debug("Page loaded successfully");
        } catch (Exception e) {
            LOGGER.error("Page load wait timed out", e);
            throw e;
        }
    }
    
    /**
     * Switches to a frame by locator.
     * 
     * @param by The locator of the frame
     */
    public void switchToFrame(By by) {
        LOGGER.debug("Switching to frame: {}", by);
        try {
            WebElement frameElement = findElement(by);
            getDriver().switchTo().frame(frameElement);
            LOGGER.debug("Switched to frame: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to switch to frame: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Switches back to the main document from a frame.
     */
    public void switchToDefaultContent() {
        LOGGER.debug("Switching to default content");
        try {
            getDriver().switchTo().defaultContent();
            LOGGER.debug("Switched to default content");
        } catch (Exception e) {
            LOGGER.error("Failed to switch to default content", e);
            throw e;
        }
    }
    
    /**
     * Switches to a window/tab by its handle.
     * 
     * @param windowHandle The window handle to switch to
     */
    public void switchToWindow(String windowHandle) {
        LOGGER.debug("Switching to window: {}", windowHandle);
        try {
            getDriver().switchTo().window(windowHandle);
            LOGGER.debug("Switched to window: {}", windowHandle);
        } catch (Exception e) {
            LOGGER.error("Failed to switch to window: {}", windowHandle, e);
            throw e;
        }
    }
    
    /**
     * Gets all window handles.
     * 
     * @return Set of all window handles
     */
    public Set<String> getWindowHandles() {
        LOGGER.debug("Getting all window handles");
        return getDriver().getWindowHandles();
    }
    
    /**
     * Gets the current window handle.
     * 
     * @return The current window handle
     */
    public String getWindowHandle() {
        LOGGER.debug("Getting current window handle");
        return getDriver().getWindowHandle();
    }
    
    /**
     * Accepts an alert if present.
     */
    public void acceptAlert() {
        LOGGER.debug("Accepting alert");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            getDriver().switchTo().alert().accept();
            LOGGER.debug("Alert accepted");
        } catch (Exception e) {
            LOGGER.error("Failed to accept alert", e);
            throw e;
        }
    }
    
    /**
     * Dismisses an alert if present.
     */
    public void dismissAlert() {
        LOGGER.debug("Dismissing alert");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            getDriver().switchTo().alert().dismiss();
            LOGGER.debug("Alert dismissed");
        } catch (Exception e) {
            LOGGER.error("Failed to dismiss alert", e);
            throw e;
        }
    }
    
    /**
     * Gets text from an alert if present.
     * 
     * @return The alert text
     */
    public String getAlertText() {
        LOGGER.debug("Getting alert text");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            String text = getDriver().switchTo().alert().getText();
            LOGGER.debug("Got alert text: {}", text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get alert text", e);
            throw e;
        }
    }
    
    /**
     * Sets browser window size.
     * 
     * @param width The window width
     * @param height The window height
     */
    public void setWindowSize(int width, int height) {
        LOGGER.debug("Setting window size: {}x{}", width, height);
        try {
            getDriver().manage().window().setSize(new Dimension(width, height));
            LOGGER.debug("Window size set to: {}x{}", width, height);
        } catch (Exception e) {
            LOGGER.error("Failed to set window size: {}x{}", width, height, e);
            throw e;
        }
    }
    
    /**
     * Maximizes the browser window.
     */
    public void maximizeWindow() {
        LOGGER.debug("Maximizing window");
        try {
            getDriver().manage().window().maximize();
            LOGGER.debug("Window maximized");
        } catch (Exception e) {
            LOGGER.error("Failed to maximize window", e);
            throw e;
        }
    }
    
    /**
     * Quits the WebDriver for the current thread.
     */
    public void quit() {
        WebDriver driver = DRIVER_THREAD_LOCAL.get();
        if (driver != null) {
            LOGGER.info("Quitting WebDriver for current thread");
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.error("Error while quitting WebDriver", e);
            } finally {
                DRIVER_THREAD_LOCAL.remove();
                ALL_DRIVERS.remove(Thread.currentThread().getId());
            }
        }
    }
    
    /**
     * Quits all WebDriver instances across all threads.
     * Useful for cleanup before test suite completion.
     */
    public static void quitAll() {
        LOGGER.info("Quitting all WebDriver instances");
        ALL_DRIVERS.values().forEach(driver -> {
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.error("Error while quitting WebDriver instance", e);
            }
        });
        
        ALL_DRIVERS.clear();
        DRIVER_THREAD_LOCAL.remove();
    }
}


package com.cssmart.core.exception;

import org.openqa.selenium.By;

import java.util.List;

/**
 * Exception thrown when an element is not found on the page.
 */
public class CSSmartElementNotFoundException extends CSSmartException {
    
    private final By locator;
    private final String description;
    private final List<By> attemptedLocators;
    
    /**
     * Constructs a new CSSmartElementNotFoundException with the specified locator.
     * 
     * @param locator The locator that was used to find the element
     */
    public CSSmartElementNotFoundException(By locator) {
        super("Element not found with locator: " + locator);
        this.locator = locator;
        this.description = null;
        this.attemptedLocators = null;
    }
    
    /**
     * Constructs a new CSSmartElementNotFoundException with the specified locator and cause.
     * 
     * @param locator The locator that was used to find the element
     * @param cause The cause
     */
    public CSSmartElementNotFoundException(By locator, Throwable cause) {
        super("Element not found with locator: " + locator, cause);
        this.locator = locator;
        this.description = null;
        this.attemptedLocators = null;
    }
    
    /**
     * Constructs a new CSSmartElementNotFoundException with additional information.
     * 
     * @param message The custom message
     * @param locator The primary locator that was used
     * @param description The element description if available
     */
    public CSSmartElementNotFoundException(String message, By locator, String description) {
        super(message + (description != null ? " Description: " + description : ""));
        this.locator = locator;
        this.description = description;
        this.attemptedLocators = null;
    }
    
    /**
     * Constructs a new CSSmartElementNotFoundException with all attempted locators.
     * 
     * @param message The custom message
     * @param locator The primary locator that was used
     * @param cause The cause of the exception
     */
    public CSSmartElementNotFoundException(String message, By locator, Throwable cause) {
        super(message, cause);
        this.locator = locator;
        this.description = null;
        this.attemptedLocators = null;
    }
    
    /**
     * Constructs a new CSSmartElementNotFoundException with all attempted locators.
     * 
     * @param message The custom message
     * @param locator The primary locator that was used
     * @param attemptedLocators List of all locators that were attempted
     */
    public CSSmartElementNotFoundException(String message, By locator, List<By> attemptedLocators) {
        super(message);
        this.locator = locator;
        this.description = null;
        this.attemptedLocators = attemptedLocators;
    }
    
    /**
     * Gets the locator that was used to find the element.
     * 
     * @return The locator
     */
    public By getLocator() {
        return locator;
    }
    
    /**
     * Gets the element description.
     * 
     * @return The element description, or null if not available
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Gets the list of all locators that were attempted.
     * 
     * @return The attempted locators, or null if not available
     */
    public List<By> getAttemptedLocators() {
        return attemptedLocators;
    }
}


package com.cssmart.core.test;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.config.PropertyManager;
import com.cssmart.core.driver.BrowserManager;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartReport;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.CSSmartScreenshot;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Base class for all test classes.
 * Provides common setup, teardown, and reporting functionality.
 */
public abstract class CSSmartTestBase {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartTestBase.class);
    private static final CSSmartReport REPORT = new CSSmartReport();
    private static final Map<Long, CSSmartTestResult> TEST_RESULTS = new ConcurrentHashMap<>();
    
    protected CSSmartConfig config;
    protected CSSmartDriver driver;
    protected CSSmartScreenshot screenshot;
    
    /**
     * Setup operations before the test suite runs.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetUp() {
        LOGGER.info("Setting up test suite");
        
        // Initialize configuration
        config = new PropertyManager().initialize();
        
        // Add environment info to report
        REPORT.addEnvironmentInfo("Browser", config.getString("browser.type", "chrome"))
              .addEnvironmentInfo("Environment", config.getString("env", "test"))
              .addEnvironmentInfo("Base URL", config.getString("base.url", ""));
        
        LOGGER.info("Test suite setup complete");
    }
    
    /**
     * Cleanup operations after the test suite runs.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down test suite");
        
        // Quit all browser instances
        BrowserManager.quitAllDrivers();
        
        // Generate the test report
        String reportPath = REPORT.generateReport();
        LOGGER.info("Test report generated: {}", reportPath);
    }
    
    /**
     * Setup operations before each test method.
     * 
     * @param method The test method
     */
    @BeforeMethod(alwaysRun = true)
    public void setUp(Method method) {
        String testName = method.getName();
        String testClass = method.getDeclaringClass().getSimpleName();
        
        LOGGER.info("Setting up test: {}.{}", testClass, testName);
        
        // Create driver if not already created
        if (driver == null) {
            driver = new BrowserManager(config).createDriver();
        }
        
        // Initialize screenshot utility
        screenshot = new CSSmartScreenshot(driver);
        
        // Create test result and store it
        CSSmartTestResult testResult = REPORT.createTestResult(testName, testClass, CSSmartTestStatus.PASS);
        TEST_RESULTS.put(Thread.currentThread().getId(), testResult);
        
        // Set the test result for action logging in the driver
        driver.setCurrentTestResult(testResult);
        
        LOGGER.info("Test setup complete: {}.{}", testClass, testName);
    }
    
    /**
     * Cleanup operations after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDown(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String testClass = result.getTestClass().getName();
        
        LOGGER.info("Tearing down test: {}.{}", testClass, testName);
        
        CSSmartTestResult testResult = TEST_RESULTS.get(Thread.currentThread().getId());
        
        if (testResult != null) {
            // Update test status based on TestNG result
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testResult.setStatus(CSSmartTestStatus.PASS);
                    break;
                case ITestResult.FAILURE:
                    testResult.setStatus(CSSmartTestStatus.FAIL);
                    
                    // Capture failure details
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage(result.getThrowable().getMessage());
                        
                        StringWriter sw = new StringWriter();
                        PrintWriter pw = new PrintWriter(sw);
                        result.getThrowable().printStackTrace(pw);
                        testResult.setStackTrace(sw.toString());
                        
                        // Take screenshot on failure
                        if (driver != null) {
                            String screenshotPath = screenshot.takeScreenshot("failure_" + testName);
                            testResult.addFailStep("Test failed: " + result.getThrowable().getMessage())
                                      .getSteps().get(testResult.getSteps().size() - 1)
                                      .setScreenshotPath(screenshotPath);
                        }
                    }
                    break;
                case ITestResult.SKIP:
                    testResult.setStatus(CSSmartTestStatus.SKIP);
                    
                    if (result.getThrowable() != null) {
                        testResult.setErrorMessage("Test skipped: " + result.getThrowable().getMessage());
                        testResult.addSkipStep("Test skipped: " + result.getThrowable().getMessage());
                    } else {
                        testResult.addSkipStep("Test skipped");
                    }
                    break;
            }
            
            // Mark test as complete
            testResult.markComplete();
        }
        
        LOGGER.info("Test complete: {}.{} with status {}", testClass, testName, 
            result.getStatus() == ITestResult.SUCCESS ? "PASS" : 
            result.getStatus() == ITestResult.FAILURE ? "FAIL" : "SKIP");
    }
    
    /**
     * Gets the current test result for the executing thread.
     * 
     * @return The test result
     */
    protected CSSmartTestResult getCurrentTestResult() {
        return TEST_RESULTS.get(Thread.currentThread().getId());
    }
    
    /**
     * Logs a test step.
     * 
     * @param description The step description
     * @param status The step status
     * @param takeScreenshot Whether to take a screenshot
     * @return The current test result
     */
    protected CSSmartTestResult logStep(String description, CSSmartTestStatus status, boolean takeScreenshot) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            switch (status) {
                case PASS:
                    testResult.addPassStep(description);
                    break;
                case FAIL:
                    testResult.addFailStep(description);
                    break;
                case SKIP:
                    testResult.addSkipStep(description);
                    break;
                case INFO:
                    testResult.addInfoStep(description);
                    break;
                case WARNING:
                    testResult.addWarningStep(description);
                    break;
            }
            
            if (takeScreenshot && driver != null) {
                String screenshotPath = screenshot.takeScreenshot("step_" + testResult.getSteps().size());
                testResult.getSteps().get(testResult.getSteps().size() - 1).setScreenshotPath(screenshotPath);
            }
        }
        
        return testResult;
    }
    
    /**
     * Logs a passed test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logPass(String description) {
        return logStep(description, CSSmartTestStatus.PASS, false);
    }
    
    /**
     * Logs a passed test step with screenshot.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logPassWithScreenshot(String description) {
        return logStep(description, CSSmartTestStatus.PASS, true);
    }
    
    /**
     * Logs a failed test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logFail(String description) {
        return logStep(description, CSSmartTestStatus.FAIL, true);
    }
    
    /**
     * Logs a failed test step with error details.
     * 
     * @param description The step description
     * @param error The error that occurred
     * @return The current test result
     */
    protected CSSmartTestResult logFail(String description, Throwable error) {
        CSSmartTestResult testResult = getCurrentTestResult();
        
        if (testResult != null) {
            testResult.addFailStep(description, error);
            
            if (driver != null) {
                String screenshotPath = screenshot.takeScreenshot("error_" + testResult.getSteps().size());
                testResult.getSteps().get(testResult.getSteps().size() - 1).setScreenshotPath(screenshotPath);
            }
        }
        
        return testResult;
    }
    
    /**
     * Logs an info test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logInfo(String description) {
        return logStep(description, CSSmartTestStatus.INFO, false);
    }
    
    /**
     * Logs a warning test step.
     * 
     * @param description The step description
     * @return The current test result
     */
    protected CSSmartTestResult logWarning(String description) {
        return logStep(description, CSSmartTestStatus.WARNING, false);
    }
}



package com.cssmart.core.annotation;

import com.cssmart.core.ai.CSSmartAIElementFinder;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.element.CSSmartWebElement;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.pagefactory.ElementLocator;
import org.openqa.selenium.support.pagefactory.ElementLocatorFactory;

import java.lang.reflect.Field;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * Processor for CSSmartFindBy annotation.
 * Handles enhanced element location with self-healing capabilities.
 */
public class CSSmartFindByProcessor {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartFindByProcessor.class);
    
    private final ElementLocatorFactory factory;
    private final CSSmartDriver driver;
    private final CSSmartAIElementFinder aiFinder;
    
    /**
     * Constructs a new CSSmartFindByProcessor.
     * 
     * @param factory The element locator factory
     * @param driver The CSSmartDriver instance
     */
    public CSSmartFindByProcessor(ElementLocatorFactory factory, CSSmartDriver driver) {
        this.factory = factory;
        this.driver = driver;
        this.aiFinder = new CSSmartAIElementFinder(driver, driver.getConfig());
    }
    
    /**
     * Creates an element locator for a field with CSSmartFindBy annotation.
     * 
     * @param field The field to create a locator for
     * @return The element locator
     */
    public ElementLocator createLocator(Field field) {
        CSSmartFindBy annotation = field.getAnnotation(CSSmartFindBy.class);
        
        if (annotation == null) {
            // If no CSSmartFindBy annotation, delegate to the factory
            return factory.createLocator(field);
        }
        
        return new CSSmartElementLocator(field, annotation, driver, aiFinder);
    }
    
    /**
     * Custom element locator for CSSmartFindBy annotation.
     */
    private static class CSSmartElementLocator implements ElementLocator {
        private final Field field;
        private final CSSmartFindBy annotation;
        private final CSSmartDriver driver;
        private final CSSmartAIElementFinder aiFinder;
        private final List<By> locators = new ArrayList<>();
        private final String description;
        private final boolean optional;
        private final Duration timeout;
        private final CSSmartFindBy.AIAssistance aiAssistance;
        
        /**
         * Constructs a new CSSmartElementLocator.
         * 
         * @param field The field to create a locator for
         * @param annotation The CSSmartFindBy annotation
         * @param driver The CSSmartDriver instance
         * @param aiFinder The CSSmartAIElementFinder instance
         */
        public CSSmartElementLocator(Field field, CSSmartFindBy annotation, 
                                     CSSmartDriver driver, CSSmartAIElementFinder aiFinder) {
            this.field = field;
            this.annotation = annotation;
            this.driver = driver;
            this.aiFinder = aiFinder;
            this.description = annotation.description();
            this.optional = annotation.optional();
            this.timeout = Duration.ofSeconds(annotation.timeoutInSeconds());
            this.aiAssistance = annotation.aiAssistance();
            
            // Process primary locator
            By primaryLocator = processLocatorAnnotation(annotation);
            if (primaryLocator != null) {
                locators.add(primaryLocator);
            }
            
            // Process explicit alternate locators
            for (String alternateLocatorStr : annotation.alternateLocators()) {
                By alternateLocator = parseLocatorString(alternateLocatorStr);
                if (alternateLocator != null) {
                    locators.add(alternateLocator);
                }
            }
            
            // Auto-generate smart alternate locators if we have a primary locator
            if (primaryLocator != null) {
                generateSmartAlternateLocators(primaryLocator);
            }
            
            if (locators.isEmpty() && aiAssistance == CSSmartFindBy.AIAssistance.NONE && 
                (description == null || description.isEmpty())) {
                LOGGER.error("No locators defined for element: {}", field.getName());
                throw new IllegalArgumentException("No locators defined for element: " + field.getName());
            }
        }
        
        /**
         * Generates smart alternate locators based on the primary locator.
         * This allows the framework to automatically try different strategies
         * even when the user hasn't explicitly provided alternatives.
         * 
         * @param primaryLocator The primary locator
         */
        private void generateSmartAlternateLocators(By primaryLocator) {
            String locatorString = primaryLocator.toString();
            
            // Extract the locator type and value
            int colonIndex = locatorString.indexOf(':');
            if (colonIndex <= 0 || colonIndex >= locatorString.length() - 1) {
                return;
            }
            
            String locatorType = locatorString.substring(3, colonIndex).toLowerCase();
            String locatorValue = locatorString.substring(colonIndex + 1).trim();
            
            switch (locatorType) {
                case "id":
                    // For ID, generate CSS and XPath alternatives
                    locators.add(By.cssSelector("#" + locatorValue));
                    locators.add(By.xpath("//*[@id='" + locatorValue + "']"));
                    
                    // Also try name if the name might match the ID
                    locators.add(By.name(locatorValue));
                    break;
                    
                case "name":
                    // For name, generate XPath alternative and try ID
                    locators.add(By.xpath("//*[@name='" + locatorValue + "']"));
                    locators.add(By.id(locatorValue));
                    break;
                    
                case "classname":
                    // For class name, generate CSS and XPath alternatives
                    locators.add(By.cssSelector("." + locatorValue.replace(" ", ".")));
                    locators.add(By.xpath("//*[contains(@class, '" + locatorValue + "')]"));
                    break;
                    
                case "css": 
                    // For CSS, try to convert to XPath if possible
                    if (locatorValue.startsWith("#")) {
                        // ID-based CSS
                        String id = locatorValue.substring(1);
                        locators.add(By.id(id));
                        locators.add(By.xpath("//*[@id='" + id + "']"));
                    } else if (locatorValue.startsWith(".")) {
                        // Class-based CSS
                        String className = locatorValue.substring(1);
                        locators.add(By.className(className));
                        locators.add(By.xpath("//*[contains(@class, '" + className + "')]"));
                    }
                    break;
                    
                case "xpath":
                    // For XPath, try to convert to CSS or direct locators if it's a simple pattern
                    if (locatorValue.matches("//*\\[@id='([^']+)'\\]")) {
                        String id = locatorValue.replaceAll("//*\\[@id='([^']+)'\\]", "$1");
                        locators.add(By.id(id));
                        locators.add(By.cssSelector("#" + id));
                    } else if (locatorValue.matches("//*\\[@name='([^']+)'\\]")) {
                        String name = locatorValue.replaceAll("//*\\[@name='([^']+)'\\]", "$1");
                        locators.add(By.name(name));
                    } else if (locatorValue.matches("//*\\[contains\\(@class, '([^']+)'\\)\\]")) {
                        String className = locatorValue.replaceAll("//*\\[contains\\(@class, '([^']+)'\\)\\]", "$1");
                        locators.add(By.className(className));
                        locators.add(By.cssSelector("." + className));
                    }
                    break;
                    
                case "tagname":
                    // For tag name, combine with common attributes if we have a description
                    if (description != null && !description.isEmpty()) {
                        // Generate smarter locators based on tag type
                        if ("input".equalsIgnoreCase(locatorValue)) {
                            locators.add(By.xpath("//input[@type='text']"));
                            locators.add(By.xpath("//input[@type='email']"));
                            locators.add(By.xpath("//input[@type='password']"));
                        } else if ("button".equalsIgnoreCase(locatorValue)) {
                            // For buttons, try to find by text if we have a description
                            locators.add(By.xpath("//button[contains(text(), '" + description + "')]"));
                            locators.add(By.xpath("//input[@type='button' or @type='submit']"));
                        } else if ("a".equalsIgnoreCase(locatorValue)) {
                            // For links, try to find by text
                            locators.add(By.xpath("//a[contains(text(), '" + description + "')]"));
                            // Try partial link text if we have a description
                            locators.add(By.partialLinkText(description));
                        }
                    }
                    break;
                    
                case "linktext":
                    // For link text, add partial link text and XPath alternatives
                    locators.add(By.partialLinkText(locatorValue));
                    locators.add(By.xpath("//a[contains(text(), '" + locatorValue + "')]"));
                    locators.add(By.xpath("//a[text()='" + locatorValue + "']"));
                    break;
                    
                case "partiallinktext":
                    // For partial link text, add XPath alternatives
                    locators.add(By.xpath("//a[contains(text(), '" + locatorValue + "')]"));
                    break;
            }
            
            // If we have description, add more semantic locators
            if (description != null && !description.isEmpty()) {
                // Add common label-based locators
                locators.add(By.xpath("//label[contains(text(), '" + description + "')]/following::input[1]"));
                locators.add(By.xpath("//label[contains(text(), '" + description + "')]/..//input"));
                locators.add(By.xpath("//*[contains(text(), '" + description + "')]"));
                
                // Add aria attribute locators
                locators.add(By.xpath("//*[@aria-label='" + description + "']"));
                locators.add(By.xpath("//*[contains(@aria-label, '" + description + "')]"));
                locators.add(By.xpath("//*[@placeholder='" + description + "']"));
                locators.add(By.xpath("//*[contains(@placeholder, '" + description + "')]"));
                locators.add(By.xpath("//*[@title='" + description + "']"));
                locators.add(By.xpath("//*[contains(@title, '" + description + "')]"));
            }
            
            // Remove any duplicates
            Set<String> locatorStrings = new HashSet<>();
            List<By> uniqueLocators = new ArrayList<>();
            
            for (By locator : locators) {
                String locStr = locator.toString();
                if (locatorStrings.add(locStr)) {
                    uniqueLocators.add(locator);
                }
            }
            
            locators.clear();
            locators.addAll(uniqueLocators);
            
            LOGGER.debug("Generated {} smart alternate locators for {}", locators.size() - 1, field.getName());
        }
        
        /**
         * Creates a By locator from the CSSmartFindBy annotation.
         * 
         * @param annotation The CSSmartFindBy annotation
         * @return The By locator
         */
        private By processLocatorAnnotation(CSSmartFindBy annotation) {
            if (!annotation.id().isEmpty()) {
                return By.id(annotation.id());
            } else if (!annotation.name().isEmpty()) {
                return By.name(annotation.name());
            } else if (!annotation.className().isEmpty()) {
                return By.className(annotation.className());
            } else if (!annotation.css().isEmpty()) {
                return By.cssSelector(annotation.css());
            } else if (!annotation.tagName().isEmpty()) {
                return By.tagName(annotation.tagName());
            } else if (!annotation.linkText().isEmpty()) {
                return By.linkText(annotation.linkText());
            } else if (!annotation.partialLinkText().isEmpty()) {
                return By.partialLinkText(annotation.partialLinkText());
            } else if (!annotation.xpath().isEmpty()) {
                return By.xpath(annotation.xpath());
            }
            
            return null;
        }
        
        /**
         * Parses a locator string in the format "strategy=expression".
         * 
         * @param locatorStr The locator string
         * @return The By locator
         */
        private By parseLocatorString(String locatorStr) {
            String[] parts = locatorStr.split("=", 2);
            if (parts.length != 2) {
                LOGGER.warn("Invalid locator format: {}", locatorStr);
                return null;
            }
            
            String strategy = parts[0].trim().toLowerCase();
            String expression = parts[1].trim();
            
            switch (strategy) {
                case "id":
                    return By.id(expression);
                case "name":
                    return By.name(expression);
                case "classname":
                case "class":
                    return By.className(expression);
                case "css":
                case "cssselector":
                    return By.cssSelector(expression);
                case "tagname":
                case "tag":
                    return By.tagName(expression);
                case "linktext":
                case "link":
                    return By.linkText(expression);
                case "partiallinktext":
                case "partiallink":
                    return By.partialLinkText(expression);
                case "xpath":
                    return By.xpath(expression);
                default:
                    LOGGER.warn("Unknown locator strategy: {}", strategy);
                    return null;
            }
        }
        
        @Override
        public WebElement findElement() {
            LOGGER.debug("Finding element for field: {}", field.getName());
            
            // Check if AI should be prioritized
            if (aiAssistance == CSSmartFindBy.AIAssistance.PRIORITIZE && 
                description != null && !description.isEmpty()) {
                try {
                    WebElement element = aiFinder.findElementByDescription(description);
                    return wrapElement(element);
                } catch (Exception e) {
                    LOGGER.debug("AI-based element finding failed, trying explicit locators");
                }
            }
            
            // Try all explicit locators
            List<Exception> exceptions = new ArrayList<>();
            for (By locator : locators) {
                try {
                    WebElement element = driver.findElement(locator, timeout);
                    return wrapElement(element);
                } catch (Exception e) {
                    exceptions.add(e);
                    LOGGER.debug("Failed to find element with locator: {}", locator, e);
                }
            }
            
            // If explicit locators failed, try AI as fallback
            if ((aiAssistance == CSSmartFindBy.AIAssistance.FALLBACK || 
                 aiAssistance == CSSmartFindBy.AIAssistance.AUTO) && 
                description != null && !description.isEmpty()) {
                try {
                    WebElement element = aiFinder.findElementByDescription(description);
                    return wrapElement(element);
                } catch (Exception e) {
                    exceptions.add(e);
                    LOGGER.debug("AI-based fallback element finding failed", e);
                }
            }
            
            // If optional, return null instead of throwing an exception
            if (optional) {
                LOGGER.info("Optional element not found for field: {}", field.getName());
                return null;
            }
            
            // If all attempts failed, throw an exception with combined info
            throw new CSSmartElementNotFoundException(
                "Failed to find element for field: " + field.getName() + 
                " using " + locators.size() + " locators. " + 
                (description != null && !description.isEmpty() ? 
                 "Description: " + description : ""), 
                locators.isEmpty() ? null : locators.get(0),
                exceptions.isEmpty() ? null : exceptions.get(0)
            );
        }
        
        @Override
        public List<WebElement> findElements() {
            LOGGER.debug("Finding elements for field: {}", field.getName());
            
            // For collections, use only the first locator for simplicity
            if (!locators.isEmpty()) {
                try {
                    List<WebElement> elements = driver.findElements(locators.get(0), timeout);
                    return wrapElements(elements);
                } catch (Exception e) {
                    LOGGER.debug("Failed to find elements with locator: {}", locators.get(0), e);
                }
            }
            
            // Return empty list for optional elements
            if (optional) {
                LOGGER.info("Optional elements not found for field: {}", field.getName());
                return new ArrayList<>();
            }
            
            throw new CSSmartElementNotFoundException(
                "Failed to find elements for field: " + field.getName(),
                locators.isEmpty() ? null : locators.get(0));
        }
        
        /**
         * Wraps a WebElement in a CSSmartWebElement.
         * 
         * @param element The WebElement to wrap
         * @return The wrapped element
         */
        private WebElement wrapElement(WebElement element) {
            if (element == null) {
                return null;
            }
            
            return new CSSmartWebElement(
                driver, 
                locators.isEmpty() ? null : locators.get(0),
                element,
                timeout,
                description
            );
        }
        
        /**
         * Wraps a list of WebElements in CSSmartWebElements.
         * 
         * @param elements The WebElements to wrap
         * @return The wrapped elements
         */
        private List<WebElement> wrapElements(List<WebElement> elements) {
            if (elements == null) {
                return new ArrayList<>();
            }
            
            List<WebElement> wrappedElements = new ArrayList<>();
            for (WebElement element : elements) {
                wrappedElements.add(wrapElement(element));
            }
            
            return wrappedElements;
        }
    }
}


package com.cssmart.core.ai;

import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.regex.Pattern;

/**
 * Intelligent element finder that uses natural language descriptions to locate elements.
 */
public class CSSmartAIElementFinder {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartAIElementFinder.class);
    
    private final CSSmartDriver driver;
    private final CSSmartConfig config;
    private final CSSmartAIAnalyzer analyzer;
    
    /**
     * Constructs a new CSSmartAIElementFinder with the specified driver and configuration.
     * 
     * @param driver The CSSmartDriver
     * @param config The framework configuration
     */
    public CSSmartAIElementFinder(CSSmartDriver driver, CSSmartConfig config) {
        this.driver = driver;
        this.config = config;
        this.analyzer = new CSSmartAIAnalyzer(config);
    }
    
    /**
     * Finds an element by natural language description.
     * 
     * @param description The element description
     * @return The found web element
     * @throws CSSmartElementNotFoundException if element cannot be found
     */
    public WebElement findElementByDescription(String description) {
        LOGGER.info("Finding element by description: {}", description);
        
        // Get all visible elements on the page
        List<WebElement> candidates = driver.findElements(By.xpath("//*[not(self::script) and not(self::style)]"));
        
        // Filter only visible elements
        List<WebElement> visibleElements = new ArrayList<>();
        for (WebElement element : candidates) {
            try {
                if (element.isDisplayed()) {
                    visibleElements.add(element);
                }
            } catch (Exception e) {
                // Ignore errors when checking visibility
            }
        }
        
        // Score elements based on relevance to description
        WebElement bestMatch = null;
        double bestScore = 0.0;
        
        for (WebElement element : visibleElements) {
            double score = scoreElementMatch(element, description);
            
            if (score > bestScore) {
                bestScore = score;
                bestMatch = element;
            }
        }
        
        // Require a minimum score to consider it a match
        double threshold = config.getDouble("ai.element.finder.threshold", 0.4);
        if (bestScore < threshold) {
            LOGGER.warn("No element found matching description: {}", description);
            throw new CSSmartElementNotFoundException(
                "No element found matching description: " + description, By.xpath("*"));
        }
        
        LOGGER.info("Found element matching description with score {}: {}", 
                  bestScore, elementToString(bestMatch));
        
        return bestMatch;
    }
    
    /**
     * Scores an element's match against a natural language description.
     * 
     * @param element The web element
     * @param description The element description
     * @return Score (0.0 to 1.0) indicating match quality
     */
    private double scoreElementMatch(WebElement element, String description) {
        double score = 0.0;
        String normalizedDescription = description.toLowerCase();
        
        try {
            // Get element attributes
            String tagName = element.getTagName().toLowerCase();
            String id = element.getAttribute("id");
            String className = element.getAttribute("class");
            String name = element.getAttribute("name");
            String type = element.getAttribute("type");
            String placeholder = element.getAttribute("placeholder");
            String value = element.getAttribute("value");
            String href = element.getAttribute("href");
            String text = element.getText();
            String ariaLabel = element.getAttribute("aria-label");
            
            // Element type matching
            if (normalizedDescription.contains("button")) {
                if ("button".equals(tagName) || 
                    ("input".equals(tagName) && ("submit".equals(type) || "button".equals(type)))) {
                    score += 0.3;
                } else if ((className != null && (className.contains("btn") || className.contains("button"))) ||
                           (id != null && (id.contains("btn") || id.contains("button")))) {
                    score += 0.2;
                }
            }
            
            if (normalizedDescription.contains("link")) {
                if ("a".equals(tagName) || (href != null && !href.isEmpty())) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("input") || 
                normalizedDescription.contains("field") || 
                normalizedDescription.contains("text") || 
                normalizedDescription.contains("box")) {
                if ("input".equals(tagName) || "textarea".equals(tagName)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("image")) {
                if ("img".equals(tagName)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("dropdown") || 
                normalizedDescription.contains("select")) {
                if ("select".equals(tagName)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("checkbox")) {
                if ("input".equals(tagName) && "checkbox".equals(type)) {
                    score += 0.3;
                }
            }
            
            if (normalizedDescription.contains("radio")) {
                if ("input".equals(tagName) && "radio".equals(type)) {
                    score += 0.3;
                }
            }
            
            // Text content matching
            if (text != null && !text.isEmpty()) {
                // Exact text match gets highest score
                if (text.equalsIgnoreCase(description)) {
                    score += 0.8;
                }
                // Text contains description
                else if (text.toLowerCase().contains(normalizedDescription)) {
                    score += 0.6;
                }
                // Description contains text (partial)
                else if (normalizedDescription.contains(text.toLowerCase())) {
                    score += 0.4;
                }
                // Words in description match words in text
                else {
                    Set<String> descWords = new HashSet<>(
                        Arrays.asList(normalizedDescription.split("\\s+")));
                    Set<String> textWords = new HashSet<>(
                        Arrays.asList(text.toLowerCase().split("\\s+")));
                    
                    // Count matching words
                    int matchCount = 0;
                    for (String word : descWords) {
                        if (word.length() > 2 && textWords.contains(word)) {
                            matchCount++;
                        }
                    }
                    
                    if (matchCount > 0) {
                        score += 0.2 * Math.min(1.0, (double) matchCount / descWords.size());
                    }
                }
            }
            
            // Attribute matching (ID, name, placeholder, aria-label)
            if (id != null && !id.isEmpty()) {
                if (id.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (containsWords(id.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (name != null && !name.isEmpty()) {
                if (name.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (containsWords(name.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (placeholder != null && !placeholder.isEmpty()) {
                if (placeholder.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (placeholder.toLowerCase().contains(normalizedDescription)) {
                    score += 0.4;
                } else if (containsWords(placeholder.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (ariaLabel != null && !ariaLabel.isEmpty()) {
                if (ariaLabel.equalsIgnoreCase(description)) {
                    score += 0.5;
                } else if (ariaLabel.toLowerCase().contains(normalizedDescription)) {
                    score += 0.4;
                } else if (containsWords(ariaLabel.toLowerCase(), normalizedDescription)) {
                    score += 0.3;
                }
            }
            
            if (value != null && !value.isEmpty()) {
                if (value.equalsIgnoreCase(description)) {
                    score += 0.4;
                } else if (containsWords(value.toLowerCase(), normalizedDescription)) {
                    score += 0.2;
                }
            }
            
            // Additional context matching for buttons
            if ("button".equals(tagName) || 
                ("input".equals(tagName) && ("submit".equals(type) || "button".equals(type)))) {
                
                // Button descriptions often contain action words
                String[] actionWords = {"click", "press", "submit", "save", "cancel", "ok", "next", "previous"};
                for (String action : actionWords) {
                    if (normalizedDescription.contains(action)) {
                        score += 0.1;
                        break;
                    }
                }
            }
            
        } catch (Exception e) {
            // Ignore errors when checking element properties
            return 0.0;
        }
        
        return Math.min(1.0, score);
    }
    
    /**
     * Finds elements that match a specified semantic concept or category.
     * 
     * @param concept The semantic concept (e.g., "navigation", "main content", "footer")
     * @return List of matching elements
     */
    public List<WebElement> findElementsByCategory(String concept) {
        LOGGER.info("Finding elements by category: {}", concept);
        
        List<WebElement> results = new ArrayList<>();
        String normalizedConcept = concept.toLowerCase();
        
        // Define common patterns for different semantic categories
        if (normalizedConcept.contains("navigation") || normalizedConcept.contains("menu")) {
            results.addAll(driver.findElements(By.xpath(
                "//nav | //ul[contains(@class, 'nav') or contains(@class, 'menu')] | " +
                "//div[contains(@class, 'nav') or contains(@class, 'menu')] | " +
                "//header//ul | //header//ol | //*[@role='navigation']")));
        }
        else if (normalizedConcept.contains("header") || normalizedConcept.contains("banner")) {
            results.addAll(driver.findElements(By.xpath(
                "//header | //div[contains(@class, 'header') or contains(@id, 'header')] | " +
                "//*[@role='banner']")));
        }
        else if (normalizedConcept.contains("footer")) {
            results.addAll(driver.findElements(By.xpath(
                "//footer | //div[contains(@class, 'footer') or contains(@id, 'footer')] | " +
                "//*[@role='contentinfo']")));
        }
        else if (normalizedConcept.contains("main") || normalizedConcept.contains("content")) {
            results.addAll(driver.findElements(By.xpath(
                "//main | //div[contains(@class, 'main') or contains(@class, 'content') or " +
                "contains(@id, 'main') or contains(@id, 'content')] | //*[@role='main']")));
        }
        else if (normalizedConcept.contains("sidebar") || normalizedConcept.contains("aside")) {
            results.addAll(driver.findElements(By.xpath(
                "//aside | //div[contains(@class, 'sidebar') or contains(@class, 'aside') or " +
                "contains(@id, 'sidebar')] | //*[@role='complementary']")));
        }
        else if (normalizedConcept.contains("form")) {
            results.addAll(driver.findElements(By.xpath(
                "//form | //div[contains(@class, 'form')] | //*[@role='form']")));
        }
        else if (normalizedConcept.contains("search")) {
            results.addAll(driver.findElements(By.xpath(
                "//input[@type='search'] | //form[contains(@class, 'search') or " +
                "contains(@id, 'search')] | //*[@role='search']")));
        }
        else if (normalizedConcept.contains("button") || normalizedConcept.contains("action")) {
            results.addAll(driver.findElements(By.xpath(
                "//button | //input[@type='button' or @type='submit'] | " +
                "//a[contains(@class, 'btn') or contains(@class, 'button')] | " +
                "//div[contains(@class, 'btn') or contains(@class, 'button')] | " +
                "//*[@role='button']")));
        }
        else if (normalizedConcept.contains("image") || normalizedConcept.contains("picture")) {
            results.addAll(driver.findElements(By.xpath("//img | //picture | //*[@role='img']")));
        }
        else if (normalizedConcept.contains("video") || normalizedConcept.contains("media")) {
            results.addAll(driver.findElements(By.xpath(
                "//video | //audio | //*[contains(@class, 'video') or " +
                "contains(@class, 'media')] | //*[@role='video']")));
        }
        else if (normalizedConcept.contains("table") || normalizedConcept.contains("data")) {
            results.addAll(driver.findElements(By.xpath("//table | //*[@role='table' or @role='grid']")));
        }
        else if (normalizedConcept.contains("link")) {
            results.addAll(driver.findElements(By.xpath("//a")));
        }
        else if (normalizedConcept.contains("input") || normalizedConcept.contains("field")) {
            results.addAll(driver.findElements(By.xpath(
                "//input | //textarea | //select | //button | " +
                "//*[@role='textbox' or @role='combobox' or @role='checkbox' or @role='radio']")));
        }
        else {
            // If no specific category is matched, try to find elements with matching text
            results.addAll(driver.findElements(By.xpath(
                "//*[contains(text(), '" + concept + "') or contains(@class, '" + concept + "') or " +
                "contains(@id, '" + concept + "')]")));
        }
        
        // Filter to only displayed elements
        results.removeIf(element -> {
            try {
                return !element.isDisplayed();
            } catch (Exception e) {
                return true;
            }
        });
        
        LOGGER.info("Found {} elements matching category: {}", results.size(), concept);
        return results;
    }
    
    /**
     * Checks if a string contains words from a space-separated phrase.
     * 
     * @param str The string to check
     * @param phrase The phrase with words to find
     * @return true if any word is found, false otherwise
     */
    private boolean containsWords(String str, String phrase) {
        String[] words = phrase.split("\\s+");
        for (String word : words) {
            if (word.length() > 2 && (str.contains(word) || 
                Pattern.compile("\\b" + word + "\\b").matcher(str).find())) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Converts an element to a readable string representation.
     * 
     * @param element The web element
     * @return String representation
     */
    private String elementToString(WebElement element) {
        if (element == null) {
            return "null";
        }
        
        StringBuilder sb = new StringBuilder();
        try {
            sb.append(element.getTagName());
            
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                sb.append("#").append(id);
            }
            
            String className = element.getAttribute("class");
            if (className != null && !className.isEmpty()) {
                sb.append(".").append(className.replace(" ", "."));
            }
            
            String text = element.getText();
            if (text != null && !text.isEmpty()) {
                if (text.length() > 20) {
                    text = text.substring(0, 17) + "...";
                }
                sb.append("[text='").append(text).append("']");
            }
        } catch (Exception e) {
            return element.toString();
        }
        
        return sb.toString();
    }
}


package com.cssmart.core.driver;

import com.cssmart.core.ai.CSSmartAIElementFinder;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.exception.CSSmartElementNotFoundException;
import com.cssmart.core.logging.CSSmartLogger;
import com.cssmart.core.reporting.CSSmartTestResult;
import com.cssmart.core.reporting.CSSmartTestStatus;
import com.cssmart.core.util.WaitUtils;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Thread-safe WebDriver wrapper with enhanced driving capabilities.
 * Provides centralized driver management with advanced navigation,
 * interaction, and synchronization features.
 */
public class CSSmartDriver {
    private static final CSSmartLogger LOGGER = CSSmartLogger.getLogger(CSSmartDriver.class);
    private static final ThreadLocal<WebDriver> DRIVER_THREAD_LOCAL = new ThreadLocal<>();
    private static final Map<Long, WebDriver> ALL_DRIVERS = new ConcurrentHashMap<>();
    
    // Map of failed locators to their successful alternatives for self-healing
    private final Map<By, By> healedLocators = new HashMap<>();
    
    // Current test result for logging actions
    private ThreadLocal<CSSmartTestResult> currentTestResult = new ThreadLocal<>();
    
    // AI element finder for self-healing
    private CSSmartAIElementFinder aiFinder;
    
    protected final CSSmartConfig config;
    private final Duration defaultTimeout;
    private final Duration pollingInterval;
    private final boolean enableSelfHealing;
    
    /**
     * Constructs a new CSSmartDriver with the specified configuration.
     * 
     * @param config The framework configuration
     */
    public CSSmartDriver(CSSmartConfig config) {
        this.config = config;
        this.defaultTimeout = Duration.ofSeconds(config.getLong("driver.timeout.default", 30));
        this.pollingInterval = Duration.ofMillis(config.getLong("driver.polling.interval", 500));
        this.enableSelfHealing = config.getBoolean("driver.selfHealing.enabled", true);
    }
    
    /**
     * Sets the current test result for action logging.
     * 
     * @param testResult The test result to use for logging
     * @return This driver instance for method chaining
     */
    public CSSmartDriver setCurrentTestResult(CSSmartTestResult testResult) {
        currentTestResult.set(testResult);
        return this;
    }
    
    /**
     * Gets the current test result.
     * 
     * @return The current test result, or null if not set
     */
    public CSSmartTestResult getCurrentTestResult() {
        return currentTestResult.get();
    }
    
    /**
     * Logs an action to the current test result.
     * 
     * @param actionDescription The action description
     */
    public void logAction(String actionDescription) {
        CSSmartTestResult testResult = getCurrentTestResult();
        if (testResult != null) {
            testResult.addInfoStep(actionDescription);
        }
    }
    
    /**
     * Gets the CSSmartAIElementFinder instance, creating it if necessary.
     * 
     * @return The CSSmartAIElementFinder instance
     */
    public CSSmartAIElementFinder getAIFinder() {
        if (aiFinder == null) {
            aiFinder = new CSSmartAIElementFinder(this, config);
        }
        return aiFinder;
    }
    
    /**
     * Gets the current WebDriver instance for this thread or creates a new one if none exists.
     * 
     * @return The WebDriver instance for the current thread
     */
    public WebDriver getDriver() {
        WebDriver driver = DRIVER_THREAD_LOCAL.get();
        if (driver == null) {
            LOGGER.info("No WebDriver found for current thread. Initializing new driver.");
            driver = initializeDriver();
            DRIVER_THREAD_LOCAL.set(driver);
            ALL_DRIVERS.put(Thread.currentThread().getId(), driver);
        }
        return driver;
    }
    
    /**
     * Initializes a new WebDriver based on configuration.
     * This method should be extended to support different browser types.
     * 
     * @return A new WebDriver instance
     */
    protected WebDriver initializeDriver() {
        // This will be implemented by specific browser driver classes
        // For now, we'll throw an exception as this is meant to be extended
        throw new UnsupportedOperationException(
            "CSSmartDriver is an abstract driver manager. Please use a specific browser driver implementation.");
    }
    
    /**
     * Navigates to the specified URL with logging and error handling.
     * 
     * @param url The URL to navigate to
     */
    public void navigateTo(String url) {
        LOGGER.info("Navigating to: {}", url);
        try {
            getDriver().get(url);
            LOGGER.debug("Successfully navigated to: {}", url);
        } catch (WebDriverException e) {
            LOGGER.error("Failed to navigate to URL: {}", url, e);
            throw e;
        }
    }
    
    /**
     * Finds an element with wait and logging.
     * 
     * @param by The locator to find the element
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by) {
        return findElement(by, defaultTimeout);
    }
    
    /**
     * Finds an element with a custom timeout.
     * 
     * @param by The locator to find the element
     * @param timeout The timeout duration
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by, Duration timeout) {
        return findElement(by, timeout, null);
    }
    
    /**
     * Finds an element with a custom timeout and description.
     * 
     * @param by The locator to find the element
     * @param timeout The timeout duration
     * @param description Human-readable description of the element
     * @return The found WebElement
     * @throws TimeoutException if element is not found within the timeout period
     */
    public WebElement findElement(By by, Duration timeout, String description) {
        LOGGER.debug("Finding element: {}{}", by, 
                   description != null ? " (" + description + ")" : "");
        
        try {
            // First check if we already have a healed locator for this
            if (enableSelfHealing && healedLocators.containsKey(by)) {
                By healedLocator = healedLocators.get(by);
                LOGGER.debug("Using previously healed locator: {}", healedLocator);
                
                try {
                    WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
                    WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(healedLocator));
                    return new com.cssmart.core.element.CSSmartWebElement(this, healedLocator, element, timeout, description);
                } catch (Exception e) {
                    // If healed locator fails, remove it and try original path
                    LOGGER.debug("Healed locator failed, will try original: {}", by);
                    healedLocators.remove(by);
                }
            }
            
            // Try the original locator
            try {
                WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
                WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
                return new com.cssmart.core.element.CSSmartWebElement(this, by, element, timeout, description);
            } catch (TimeoutException originalException) {
                // If self-healing is enabled, try AI-based recovery
                if (enableSelfHealing) {
                    LOGGER.info("Attempting self-healing for element: {}", 
                              description != null ? description : by.toString());
                    
                    // Use our enhanced AI element finder for healing
                    By healedLocator = getAIFinder().healLocator(by, description);
                    
                    if (healedLocator != null) {
                        try {
                            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
                            WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(healedLocator));
                            
                            // Remember this healing for future use
                            healedLocators.put(by, healedLocator);
                            
                            // Log the successful healing
                            logAction("Self-healed locator: " + by + " → " + healedLocator);
                            LOGGER.info("Self-healing successful: {} → {}", by, healedLocator);
                            
                            return new com.cssmart.core.element.CSSmartWebElement(this, healedLocator, element, timeout, description);
                        } catch (Exception e) {
                            LOGGER.error("Failed to use healed locator: {}", healedLocator, e);
                        }
                    }
                    
                    // If we have a description, try direct AI finding as last resort
                    if (description != null && !description.isEmpty()) {
                        try {
                            WebElement element = getAIFinder().findElementByDescription(description);
                            
                            // Log the successful finding
                            logAction("Found element using AI with description: " + description);
                            LOGGER.info("Direct AI finding successful using description: {}", description);
                            
                            return new com.cssmart.core.element.CSSmartWebElement(this, by, element, timeout, description);
                        } catch (Exception e) {
                            LOGGER.error("Failed to find element by description: {}", description, e);
                        }
                    }
                }
                
                // If all recovery attempts failed, throw the original exception
                throw originalException;
            }
        } catch (TimeoutException e) {
            LOGGER.error("Element not found within timeout: {}{}", by, 
                       description != null ? " (" + description + ")" : "", e);
            throw e;
        }
    }
    
    /**
     * Finds all elements matching the locator.
     * 
     * @param by The locator to find elements
     * @return List of found WebElements
     */
    public List<WebElement> findElements(By by) {
        return findElements(by, defaultTimeout);
    }
    
    /**
     * Finds all elements matching the locator with custom timeout.
     * 
     * @param by The locator to find elements
     * @param timeout The timeout duration
     * @return List of found WebElements
     */
    public List<WebElement> findElements(By by, Duration timeout) {
        LOGGER.debug("Finding elements: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            return wait.until(driver -> {
                List<WebElement> elements = driver.findElements(by);
                return elements.isEmpty() ? null : elements;
            });
        } catch (TimeoutException e) {
            LOGGER.debug("No elements found within timeout: {}", by);
            return List.of();
        }
    }
    
    /**
     * Checks if an element exists on the page.
     * 
     * @param by The locator to check
     * @return true if element exists, false otherwise
     */
    public boolean elementExists(By by) {
        return elementExists(by, Duration.ofSeconds(5));
    }
    
    /**
     * Checks if an element exists on the page with custom timeout.
     * 
     * @param by The locator to check
     * @param timeout The timeout duration
     * @return true if element exists, false otherwise
     */
    public boolean elementExists(By by, Duration timeout) {
        try {
            findElement(by, timeout);
            return true;
        } catch (TimeoutException e) {
            return false;
        }
    }
    
    /**
     * Waits for an element to be clickable then clicks it.
     * 
     * @param by The locator of the element to click
     */
    public void click(By by) {
        click(by, defaultTimeout);
    }
    
    /**
     * Waits for an element to be clickable then clicks it with custom timeout.
     * 
     * @param by The locator of the element to click
     * @param timeout The timeout duration
     */
    public void click(By by, Duration timeout) {
        LOGGER.debug("Clicking on element: {}", by);
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), timeout, pollingInterval);
            WebElement element = wait.until(ExpectedConditions.elementToBeClickable(by));
            element.click();
            LOGGER.debug("Clicked element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to click element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Performs JavaScript click on an element when standard click might not work.
     * 
     * @param by The locator of the element to click
     */
    public void jsClick(By by) {
        LOGGER.debug("Performing JavaScript click on element: {}", by);
        try {
            WebElement element = findElement(by);
            JavascriptExecutor js = (JavascriptExecutor) getDriver();
            js.executeScript("arguments[0].click();", element);
            LOGGER.debug("Performed JavaScript click on element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to perform JavaScript click on element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Types text into an input element after clearing its existing value.
     * 
     * @param by The locator of the input element
     * @param text The text to type
     */
    public void sendKeys(By by, String text) {
        sendKeys(by, text, true);
    }
    
    /**
     * Types text into an input element with option to clear first.
     * 
     * @param by The locator of the input element
     * @param text The text to type
     * @param clearFirst Whether to clear the field first
     */
    public void sendKeys(By by, String text, boolean clearFirst) {
        LOGGER.debug("Sending keys to element: {} text: {}", by, text);
        try {
            WebElement element = findElement(by);
            if (clearFirst) {
                element.clear();
            }
            element.sendKeys(text);
            LOGGER.debug("Sent keys to element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to send keys to element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Selects an option from dropdown by visible text.
     * 
     * @param by The locator of the select element
     * @param visibleText The visible text of the option to select
     */
    public void selectByVisibleText(By by, String visibleText) {
        LOGGER.debug("Selecting option with text '{}' from dropdown: {}", visibleText, by);
        try {
            WebElement element = findElement(by);
            org.openqa.selenium.support.ui.Select select = 
                new org.openqa.selenium.support.ui.Select(element);
            select.selectByVisibleText(visibleText);
            LOGGER.debug("Selected option with text: {}", visibleText);
        } catch (Exception e) {
            LOGGER.error("Failed to select option with text '{}' from dropdown: {}", 
                visibleText, by, e);
            throw e;
        }
    }
    
    /**
     * Gets text from an element.
     * 
     * @param by The locator of the element
     * @return The text content of the element
     */
    public String getText(By by) {
        LOGGER.debug("Getting text from element: {}", by);
        try {
            WebElement element = findElement(by);
            String text = element.getText();
            LOGGER.debug("Got text from element: {} text: {}", by, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get text from element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Gets attribute value from an element.
     * 
     * @param by The locator of the element
     * @param attributeName The name of the attribute
     * @return The value of the attribute
     */
    public String getAttribute(By by, String attributeName) {
        LOGGER.debug("Getting attribute '{}' from element: {}", attributeName, by);
        try {
            WebElement element = findElement(by);
            String value = element.getAttribute(attributeName);
            LOGGER.debug("Got attribute '{}' from element: {} value: {}", 
                attributeName, by, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute '{}' from element: {}", 
                attributeName, by, e);
            throw e;
        }
    }
    
    /**
     * Hovers over an element.
     * 
     * @param by The locator of the element to hover over
     */
    public void hover(By by) {
        LOGGER.debug("Hovering over element: {}", by);
        try {
            WebElement element = findElement(by);
            Actions actions = new Actions(getDriver());
            actions.moveToElement(element).perform();
            LOGGER.debug("Hovered over element: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Executes JavaScript code.
     * 
     * @param script The JavaScript code to execute
     * @param args The arguments to pass to the script
     * @return The result of script execution
     */
    public Object executeScript(String script, Object... args) {
        LOGGER.debug("Executing JavaScript: {}", script);
        try {
            JavascriptExecutor js = (JavascriptExecutor) getDriver();
            Object result = js.executeScript(script, args);
            LOGGER.debug("Executed JavaScript successfully");
            return result;
        } catch (Exception e) {
            LOGGER.error("Failed to execute JavaScript: {}", script, e);
            throw e;
        }
    }
    
    /**
     * Takes a screenshot and returns it as bytes.
     * 
     * @return The screenshot as byte array
     */
    public byte[] takeScreenshot() {
        LOGGER.debug("Taking screenshot");
        try {
            TakesScreenshot screenshotDriver = (TakesScreenshot) getDriver();
            byte[] screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
            LOGGER.debug("Screenshot taken successfully");
            return screenshot;
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot", e);
            throw e;
        }
    }
    
    /**
     * Refreshes the current page.
     */
    public void refresh() {
        LOGGER.debug("Refreshing page");
        try {
            getDriver().navigate().refresh();
            LOGGER.debug("Page refreshed successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to refresh page", e);
            throw e;
        }
    }
    
    /**
     * Navigates back in browser history.
     */
    public void back() {
        LOGGER.debug("Navigating back");
        try {
            getDriver().navigate().back();
            LOGGER.debug("Navigated back successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to navigate back", e);
            throw e;
        }
    }
    
    /**
     * Navigates forward in browser history.
     */
    public void forward() {
        LOGGER.debug("Navigating forward");
        try {
            getDriver().navigate().forward();
            LOGGER.debug("Navigated forward successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to navigate forward", e);
            throw e;
        }
    }
    
    /**
     * Gets the current URL.
     * 
     * @return The current URL
     */
    public String getCurrentUrl() {
        LOGGER.debug("Getting current URL");
        return getDriver().getCurrentUrl();
    }
    
    /**
     * Gets the page title.
     * 
     * @return The page title
     */
    public String getTitle() {
        LOGGER.debug("Getting page title");
        return getDriver().getTitle();
    }
    
    /**
     * Waits for page to load completely.
     */
    public void waitForPageLoad() {
        LOGGER.debug("Waiting for page to load");
        try {
            WaitUtils.waitForCondition(
                driver -> executeScript("return document.readyState").equals("complete"),
                defaultTimeout,
                "Page did not load completely"
            );
            LOGGER.debug("Page loaded successfully");
        } catch (Exception e) {
            LOGGER.error("Page load wait timed out", e);
            throw e;
        }
    }
    
    /**
     * Switches to a frame by locator.
     * 
     * @param by The locator of the frame
     */
    public void switchToFrame(By by) {
        LOGGER.debug("Switching to frame: {}", by);
        try {
            WebElement frameElement = findElement(by);
            getDriver().switchTo().frame(frameElement);
            LOGGER.debug("Switched to frame: {}", by);
        } catch (Exception e) {
            LOGGER.error("Failed to switch to frame: {}", by, e);
            throw e;
        }
    }
    
    /**
     * Switches back to the main document from a frame.
     */
    public void switchToDefaultContent() {
        LOGGER.debug("Switching to default content");
        try {
            getDriver().switchTo().defaultContent();
            LOGGER.debug("Switched to default content");
        } catch (Exception e) {
            LOGGER.error("Failed to switch to default content", e);
            throw e;
        }
    }
    
    /**
     * Switches to a window/tab by its handle.
     * 
     * @param windowHandle The window handle to switch to
     */
    public void switchToWindow(String windowHandle) {
        LOGGER.debug("Switching to window: {}", windowHandle);
        try {
            getDriver().switchTo().window(windowHandle);
            LOGGER.debug("Switched to window: {}", windowHandle);
        } catch (Exception e) {
            LOGGER.error("Failed to switch to window: {}", windowHandle, e);
            throw e;
        }
    }
    
    /**
     * Gets all window handles.
     * 
     * @return Set of all window handles
     */
    public Set<String> getWindowHandles() {
        LOGGER.debug("Getting all window handles");
        return getDriver().getWindowHandles();
    }
    
    /**
     * Gets the current window handle.
     * 
     * @return The current window handle
     */
    public String getWindowHandle() {
        LOGGER.debug("Getting current window handle");
        return getDriver().getWindowHandle();
    }
    
    /**
     * Accepts an alert if present.
     */
    public void acceptAlert() {
        LOGGER.debug("Accepting alert");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            getDriver().switchTo().alert().accept();
            LOGGER.debug("Alert accepted");
        } catch (Exception e) {
            LOGGER.error("Failed to accept alert", e);
            throw e;
        }
    }
    
    /**
     * Dismisses an alert if present.
     */
    public void dismissAlert() {
        LOGGER.debug("Dismissing alert");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            getDriver().switchTo().alert().dismiss();
            LOGGER.debug("Alert dismissed");
        } catch (Exception e) {
            LOGGER.error("Failed to dismiss alert", e);
            throw e;
        }
    }
    
    /**
     * Gets text from an alert if present.
     * 
     * @return The alert text
     */
    public String getAlertText() {
        LOGGER.debug("Getting alert text");
        try {
            WebDriverWait wait = new WebDriverWait(getDriver(), defaultTimeout);
            wait.until(ExpectedConditions.alertIsPresent());
            String text = getDriver().switchTo().alert().getText();
            LOGGER.debug("Got alert text: {}", text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get alert text", e);
            throw e;
        }
    }
    
    /**
     * Sets browser window size.
     * 
     * @param width The window width
     * @param height The window height
     */
    public void setWindowSize(int width, int height) {
        LOGGER.debug("Setting window size: {}x{}", width, height);
        try {
            getDriver().manage().window().setSize(new Dimension(width, height));
            LOGGER.debug("Window size set to: {}x{}", width, height);
        } catch (Exception e) {
            LOGGER.error("Failed to set window size: {}x{}", width, height, e);
            throw e;
        }
    }
    
    /**
     * Maximizes the browser window.
     */
    public void maximizeWindow() {
        LOGGER.debug("Maximizing window");
        try {
            getDriver().manage().window().maximize();
            LOGGER.debug("Window maximized");
        } catch (Exception e) {
            LOGGER.error("Failed to maximize window", e);
            throw e;
        }
    }
    
    /**
     * Quits the WebDriver for the current thread.
     */
    public void quit() {
        WebDriver driver = DRIVER_THREAD_LOCAL.get();
        if (driver != null) {
            LOGGER.info("Quitting WebDriver for current thread");
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.error("Error while quitting WebDriver", e);
            } finally {
                DRIVER_THREAD_LOCAL.remove();
                ALL_DRIVERS.remove(Thread.currentThread().getId());
            }
        }
    }
    
    /**
     * Quits all WebDriver instances across all threads.
     * Useful for cleanup before test suite completion.
     */
    public static void quitAll() {
        LOGGER.info("Quitting all WebDriver instances");
        ALL_DRIVERS.values().forEach(driver -> {
            try {
                driver.quit();
            } catch (Exception e) {
                LOGGER.error("Error while quitting WebDriver instance", e);
            }
        });
        
        ALL_DRIVERS.clear();
        DRIVER_THREAD_LOCAL.remove();
    }
}


package com.cssmart.example.tests;

import com.cssmart.core.ai.CSSmartSentiment;
import com.cssmart.core.annotation.CSSmartFindBy;
import com.cssmart.core.config.CSSmartConfig;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.element.CSSmartWebElement;
import com.cssmart.core.page.CSSmartBasePage;
import com.cssmart.core.test.CSSmartTestBase;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.util.Map;

/**
 * Demo test showing the AI-powered self-healing and smart locator capabilities.
 */
public class SelfHealingDemoTest extends CSSmartTestBase {
    
    /**
     * Tests the self-healing capability with a page where elements have changed.
     */
    @Test(description = "Demonstrates self-healing when elements change")
    public void testSelfHealing() {
        // Create a page with deliberately incorrect locators
        BrokenLocatorsPage page = new BrokenLocatorsPage(driver, config);
        
        // This should work despite the locators being wrong, thanks to self-healing
        page.open();
        
        // The first call will trigger self-healing
        page.enterUsername("testuser");
        page.enterPassword("password123");
        page.clickLoginButton();
        
        // Verify results
        Assert.assertEquals(page.getWelcomeMessage(), "Welcome, testuser!");
        
        // Get healing statistics
        Map<String, Object> healingStats = driver.getAIFinder().getHealingStats();
        logInfo("Self-healing stats: " + healingStats);
        
        // Demonstrate that future calls use the healed locators (faster)
        driver.navigateTo("https://example.com/logout");
        page.open();
        
        // These calls should use cached healed locators
        long startTime = System.currentTimeMillis();
        page.enterUsername("testuser2");
        page.enterPassword("password456");
        page.clickLoginButton();
        long endTime = System.currentTimeMillis();
        
        logInfo("Time taken with healed locators: " + (endTime - startTime) + " ms");
        logPassWithScreenshot("Successfully demonstrated self-healing capability");
    }
    
    /**
     * Tests the smart locator strategy with minimal locator information.
     */
    @Test(description = "Demonstrates smart locator strategy with minimal info")
    public void testSmartLocators() {
        // Create a page with minimal locator information
        MinimalLocatorsPage page = new MinimalLocatorsPage(driver, config);
        
        // This should work despite having minimal locator info
        page.open();
        page.searchFor("test automation");
        
        // Verify search results using AI text analysis
        String resultsText = page.getSearchResultsText();
        boolean containsRelevantInfo = aiAnalyzer.areTextsSemanticallySimilar(
            "Results related to test automation", resultsText, 0.6);
        
        Assert.assertTrue(containsRelevantInfo, 
                        "Search results should be semantically relevant to the search term");
        
        // Analyze sentiment of a review
        String reviewText = page.getFirstReviewText();
        CSSmartSentiment sentiment = aiAnalyzer.analyzeSentiment(reviewText);
        
        logInfo("Review sentiment: " + sentiment);
        logPassWithScreenshot("Successfully demonstrated smart locator strategy");
    }
    
    /**
     * Tests dynamic element creation with AI-assisted finding.
     */
    @Test(description = "Demonstrates dynamic element creation with AI assistance")
    public void testDynamicElements() {
        // Navigate to a page directly
        driver.navigateTo("https://example.com/products");
        
        // Create a dynamic element based on description only - extreme self-healing
        WebElement addToCartButton = new CSSmartWebElement(
            driver, 
            null,  // No locator provided at all!
            driver.getAIFinder().findElementByDescription("Add to cart button"),
            java.time.Duration.ofSeconds(10),
            "Add to cart button"
        );
        
        // This should work despite having no explicit locator
        addToCartButton.click();
        
        // Verify cart was updated
        WebElement cartCount = driver.getAIFinder().findElementByDescription("Shopping cart count");
        Assert.assertEquals(cartCount.getText(), "1", "Cart should be updated with 1 item");
        
        logPassWithScreenshot("Successfully demonstrated AI-assisted dynamic element creation");
    }
    
    /**
     * Example page with broken locators that will be self-healed.
     */
    private static class BrokenLocatorsPage extends CSSmartBasePage {
        // All these locators are deliberately wrong to demonstrate self-healing
        @CSSmartFindBy(
            id = "wrong_username_id",
            description = "Username input field"
        )
        private WebElement usernameInput;
        
        @CSSmartFindBy(
            id = "wrong_password_id",
            description = "Password input field"
        )
        private WebElement passwordInput;
        
        @CSSmartFindBy(
            id = "wrong_login_button_id",
            description = "Login submit button"
        )
        private WebElement loginButton;
        
        @CSSmartFindBy(
            id = "wrong_welcome_id",
            description = "Welcome message after login",
            optional = true
        )
        private WebElement welcomeMessage;
        
        /**
         * Constructs a new BrokenLocatorsPage.
         */
        public BrokenLocatorsPage(CSSmartDriver driver, CSSmartConfig config) {
            super(driver, config);
        }
        
        /**
         * Opens the login page.
         */
        public void open() {
            driver.navigateTo("https://example.com/login");
            driver.waitForPageLoad();
        }
        
        /**
         * Enters the username.
         */
        public void enterUsername(String username) {
            usernameInput.sendKeys(username);
        }
        
        /**
         * Enters the password.
         */
        public void enterPassword(String password) {
            passwordInput.sendKeys(password);
        }
        
        /**
         * Clicks the login button.
         */
        public void clickLoginButton() {
            loginButton.click();
            driver.waitForPageLoad();
        }
        
        /**
         * Gets the welcome message.
         */
        public String getWelcomeMessage() {
            return welcomeMessage.getText();
        }
    }
    
    /**
     * Example page with minimal locator information.
     */
    private static class MinimalLocatorsPage extends CSSmartBasePage {
        // Only ID locator, framework will auto-generate alternatives
        @CSSmartFindBy(
            id = "searchBox"
        )
        private WebElement searchBox;
        
        // Only a description, pure AI-based element finding
        @CSSmartFindBy(
            description = "Search button"
        )
        private WebElement searchButton;
        
        // Tag name only, AI will enhance with description
        @CSSmartFindBy(
            tagName = "div",
            description = "Search results container"
        )
        private WebElement resultsContainer;
        
        // Using description with higher AI assistance level
        @CSSmartFindBy(
            description = "First user review",
            aiAssistance = CSSmartFindBy.AIAssistance.PRIORITIZE
        )
        private WebElement firstReview;
        
        /**
         * Constructs a new MinimalLocatorsPage.
         */
        public MinimalLocatorsPage(CSSmartDriver driver, CSSmartConfig config) {
            super(driver, config);
        }
        
        /**
         * Opens the search page.
         */
        public void open() {
            driver.navigateTo("https://example.com/search");
            driver.waitForPageLoad();
        }
        
        /**
         * Searches for the given term.
         */
        public void searchFor(String searchTerm) {
            searchBox.clear();
            searchBox.sendKeys(searchTerm);
            searchButton.click();
            driver.waitForPageLoad();
        }
        
        /**
         * Gets the search results text.
         */
        public String getSearchResultsText() {
            return resultsContainer.getText();
        }
        
        /**
         * Gets the text of the first review.
         */
        public String getFirstReviewText() {
            return firstReview.getText();
        }
    }
}


