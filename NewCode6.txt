package com.cssmart.framework.healing.impl;

import com.cssmart.framework.healing.HealingContext;
import com.cssmart.framework.healing.HealingResult;
import com.cssmart.framework.healing.HealingStrategy;
import com.cssmart.framework.logging.CSSmartLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Semantic healing strategy uses natural language processing principles
 * to locate elements based on their textual description and semantic meaning.
 */
public class SemanticHealingStrategy implements HealingStrategy {
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(SemanticHealingStrategy.class);
    
    // Description used for semantic matching
    private final String elementDescription;
    
    // Cache of common terms and synonyms
    private static final Map<String, List<String>> synonymDictionary = initializeSynonymDictionary();
    
    // Common button text patterns
    private static final List<Pattern> buttonPatterns = initializeButtonPatterns();
    
    // Common form field patterns
    private static final List<Pattern> formFieldPatterns = initializeFormFieldPatterns();
    
    public SemanticHealingStrategy(String elementDescription) {
        this.elementDescription = elementDescription != null ? elementDescription : "";
    }
    
    @Override
    public HealingResult heal(HealingContext context) {
        if (elementDescription.isEmpty()) {
            return new HealingResult(false, "SEMANTIC", "No element description available for semantic healing", null);
        }
        
        logger.info("Attempting semantic healing for: " + elementDescription);
        
        WebDriver driver = context.getDriver();
        if (driver == null) {
            return new HealingResult(false, "SEMANTIC", "WebDriver is null", null);
        }
        
        // Parse the description to extract key information
        Map<String, String> semanticInfo = parseDescription(elementDescription);
        String elementType = semanticInfo.getOrDefault("elementType", "");
        String elementPurpose = semanticInfo.getOrDefault("elementPurpose", "");
        String elementLocation = semanticInfo.getOrDefault("elementLocation", "");
        
        // Choose search strategy based on extracted information
        if (!elementType.isEmpty()) {
            // Try to find by element type and other extracted information
            WebElement element = findByTypeAndPurpose(driver, elementType, elementPurpose, elementLocation);
            
            if (element != null) {
                return new HealingResult(true, "SEMANTIC", 
                    "Element found by semantic type '" + elementType + "' and purpose '" + elementPurpose + "'", element);
            }
        }
        
        // If no specific type extracted or type-based search failed, try keyword-based search
        List<String> keywords = extractKeywords(elementDescription);
        WebElement element = findByKeywords(driver, keywords);
        
        if (element != null) {
            return new HealingResult(true, "SEMANTIC", 
                "Element found by semantic keywords: " + String.join(", ", keywords), element);
        }
        
        // Try finding by expanded synonyms if direct keywords failed
        List<String> expandedKeywords = expandWithSynonyms(keywords);
        element = findByKeywords(driver, expandedKeywords);
        
        if (element != null) {
            return new HealingResult(true, "SEMANTIC", 
                "Element found by expanded semantic keywords with synonyms", element);
        }
        
        // All semantic approaches failed
        return new HealingResult(false, "SEMANTIC", 
            "Semantic healing failed to locate element matching '" + elementDescription + "'", null);
    }
    
    /**
     * Parses a natural language description to extract semantic information
     */
    private Map<String, String> parseDescription(String description) {
        Map<String, String> result = new HashMap<>();
        description = description.toLowerCase();
        
        // Extract element type
        if (description.contains("button") || description.contains("btn")) {
            result.put("elementType", "button");
        } else if (description.contains("input") || description.contains("field") || 
                  description.contains("textbox") || description.contains("text box")) {
            result.put("elementType", "input");
        } else if (description.contains("checkbox") || description.contains("check box")) {
            result.put("elementType", "checkbox");
        } else if (description.contains("radio") || description.contains("option")) {
            result.put("elementType", "radio");
        } else if (description.contains("dropdown") || description.contains("drop down") || 
                  description.contains("select") || description.contains("combobox")) {
            result.put("elementType", "select");
        } else if (description.contains("link")) {
            result.put("elementType", "link");
        } else if (description.contains("image") || description.contains("img") || 
                  description.contains("icon")) {
            result.put("elementType", "image");
        } else if (description.contains("header") || description.contains("heading") || 
                  description.matches(".*(h1|h2|h3|h4|h5|h6).*")) {
            result.put("elementType", "heading");
        }
        
        // Extract element purpose (e.g., "login", "submit", "search")
        List<String> commonPurposes = Arrays.asList(
            "login", "logout", "sign in", "signup", "sign up", "register", 
            "submit", "save", "cancel", "delete", "remove", "add", "create", 
            "edit", "update", "search", "find", "filter", "sort", "download", 
            "upload", "send", "share", "like", "follow", "comment", "accept", 
            "confirm", "ok", "agree", "disagree", "next", "previous", "back"
        );
        
        for (String purpose : commonPurposes) {
            if (description.contains(purpose)) {
                result.put("elementPurpose", purpose);
                break;
            }
        }
        
        // Extract position/location references
        if (description.contains("top") || description.contains("upper") || 
            description.contains("above") || description.contains("header")) {
            result.put("elementLocation", "top");
        } else if (description.contains("bottom") || description.contains("lower") || 
                  description.contains("below") || description.contains("footer")) {
            result.put("elementLocation", "bottom");
        } else if (description.contains("left") || description.contains("beginning") || 
                  description.contains("start")) {
            result.put("elementLocation", "left");
        } else if (description.contains("right") || description.contains("end")) {
            result.put("elementLocation", "right");
        } else if (description.contains("middle") || description.contains("center")) {
            result.put("elementLocation", "center");
        }
        
        return result;
    }
    
    /**
     * Extracts relevant keywords from the description
     */
    private List<String> extractKeywords(String description) {
        // Convert to lowercase and tokenize
        String normalized = description.toLowerCase();
        String[] words = normalized.split("\\s+");
        
        // Remove stop words and keep important keywords
        Set<String> stopWords = new HashSet<>(Arrays.asList(
            "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", 
            "with", "by", "about", "of", "from", "as", "this", "that", "these", 
            "those", "is", "are", "was", "were", "be", "been", "being"
        ));
        
        List<String> keywords = new ArrayList<>();
        for (String word : words) {
            // Clean word of punctuation
            word = word.replaceAll("[^a-zA-Z0-9]", "");
            if (!word.isEmpty() && !stopWords.contains(word) && word.length() > 2) {
                keywords.add(word);
            }
        }
        
        return keywords;
    }
    
    /**
     * Expand keywords with synonyms
     */
    private List<String> expandWithSynonyms(List<String> keywords) {
        Set<String> expanded = new HashSet<>(keywords);
        
        for (String keyword : keywords) {
            List<String> synonyms = synonymDictionary.getOrDefault(keyword, Collections.emptyList());
            expanded.addAll(synonyms);
        }
        
        return new ArrayList<>(expanded);
    }
    
    /**
     * Finds an element by its type and purpose
     */
    private WebElement findByTypeAndPurpose(WebDriver driver, String elementType, String elementPurpose, 
                                          String elementLocation) {
        try {
            switch (elementType) {
                case "button":
                    return findButton(driver, elementPurpose, elementLocation);
                    
                case "input":
                    return findInput(driver, elementPurpose, elementLocation);
                    
                case "checkbox":
                    return findCheckbox(driver, elementPurpose, elementLocation);
                    
                case "radio":
                    return findRadio(driver, elementPurpose, elementLocation);
                    
                case "select":
                    return findSelect(driver, elementPurpose, elementLocation);
                    
                case "link":
                    return findLink(driver, elementPurpose, elementLocation);
                    
                case "image":
                    return findImage(driver, elementPurpose, elementLocation);
                    
                case "heading":
                    return findHeading(driver, elementPurpose, elementLocation);
                    
                default:
                    return null;
            }
        } catch (Exception e) {
            logger.error("Error in findByTypeAndPurpose", e);
            return null;
        }
    }
    
    /**
     * Finds a button element based on purpose and location
     */
    private WebElement findButton(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for button elements
            candidates.addAll(driver.findElements(By.tagName("button")));
            
            // Look for input elements of type button or submit
            candidates.addAll(driver.findElements(By.cssSelector("input[type='button'], input[type='submit']")));
            
            // Look for anchor tags that look like buttons
            candidates.addAll(driver.findElements(By.cssSelector("a.btn, a.button")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                // Create expanded purpose keywords
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                // Filter by text content, value, or other attributes
                candidates = candidates.stream()
                    .filter(e -> {
                        String text = e.getText().toLowerCase();
                        String value = e.getAttribute("value");
                        value = (value != null) ? value.toLowerCase() : "";
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            text.contains(keyword) || value.contains(keyword) || 
                            ariaLabel.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding button", e);
            return null;
        }
    }
    
    /**
     * Finds an input field based on purpose and location
     */
    private WebElement findInput(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for input elements of type text, email, password, etc.
            candidates.addAll(driver.findElements(By.cssSelector(
                "input[type='text'], input[type='email'], input[type='password'], " +
                "input[type='search'], input[type='tel'], input[type='url'], " +
                "input[type='number'], input:not([type]), textarea")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                // Create expanded purpose keywords
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Check various attributes that might indicate purpose
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        String placeholder = e.getAttribute("placeholder");
                        placeholder = (placeholder != null) ? placeholder.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        // Check nearby label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            name.contains(keyword) || id.contains(keyword) || 
                            placeholder.contains(keyword) || ariaLabel.contains(keyword) ||
                            labelText.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding input", e);
            return null;
        }
    }
    
    /**
     * Finds a checkbox based on purpose and location
     */
    private WebElement findCheckbox(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for checkbox inputs
            candidates.addAll(driver.findElements(By.cssSelector("input[type='checkbox']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Look for associated label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        // Check attributes
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            labelText.contains(keyword) || name.contains(keyword) || id.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding checkbox", e);
            return null;
        }
    }
    
    /**
     * Finds a radio button based on purpose and location
     */
    private WebElement findRadio(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for radio inputs
            candidates.addAll(driver.findElements(By.cssSelector("input[type='radio']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Look for associated label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        // Check attributes
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        String value = e.getAttribute("value");
                        value = (value != null) ? value.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            labelText.contains(keyword) || name.contains(keyword) || 
                            id.contains(keyword) || value.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding radio button", e);
            return null;
        }
    }
    
    /**
     * Finds a select/dropdown element based on purpose and location
     */
    private WebElement findSelect(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for select elements
            candidates.addAll(driver.findElements(By.tagName("select")));
            
            // Also look for div elements that might be custom dropdowns
            candidates.addAll(driver.findElements(By.cssSelector(
                "div[role='listbox'], div[class*='dropdown'], div[class*='select'], " + 
                "div[class*='combobox'], div[aria-haspopup='listbox']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        // Look for associated label text
                        String labelText = findAssociatedLabelText(driver, e);
                        
                        // Check attributes
                        String name = e.getAttribute("name");
                        name = (name != null) ? name.toLowerCase() : "";
                        
                        String id = e.getAttribute("id");
                        id = (id != null) ? id.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        // For select elements, check option values
                        boolean hasMatchingOption = false;
                        if ("select".equals(e.getTagName().toLowerCase())) {
                            List<WebElement> options = e.findElements(By.tagName("option"));
                            for (WebElement option : options) {
                                String optionText = option.getText().toLowerCase();
                                if (purposeKeywords.stream().anyMatch(optionText::contains)) {
                                    hasMatchingOption = true;
                                    break;
                                }
                            }
                        }
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            labelText.contains(keyword) || name.contains(keyword) || 
                            id.contains(keyword) || ariaLabel.contains(keyword)) || 
                            hasMatchingOption;
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding select/dropdown", e);
            return null;
        }
    }
    
    /**
     * Finds a link element based on purpose and location
     */
    private WebElement findLink(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for anchor tags
            candidates.addAll(driver.findElements(By.tagName("a")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        String text = e.getText().toLowerCase();
                        String href = e.getAttribute("href");
                        href = (href != null) ? href.toLowerCase() : "";
                        
                        String title = e.getAttribute("title");
                        title = (title != null) ? title.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            text.contains(keyword) || title.contains(keyword) || 
                            ariaLabel.contains(keyword) || href.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding link", e);
            return null;
        }
    }
    
    /**
     * Finds an image element based on purpose and location
     */
    private WebElement findImage(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for image elements
            candidates.addAll(driver.findElements(By.tagName("img")));
            
            // Also look for SVG elements
            candidates.addAll(driver.findElements(By.tagName("svg")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        String alt = e.getAttribute("alt");
                        alt = (alt != null) ? alt.toLowerCase() : "";
                        
                        String title = e.getAttribute("title");
                        title = (title != null) ? title.toLowerCase() : "";
                        
                        String src = e.getAttribute("src");
                        src = (src != null) ? src.toLowerCase() : "";
                        
                        String ariaLabel = e.getAttribute("aria-label");
                        ariaLabel = (ariaLabel != null) ? ariaLabel.toLowerCase() : "";
                        
                        return purposeKeywords.stream().anyMatch(keyword -> 
                            alt.contains(keyword) || title.contains(keyword) || 
                            src.contains(keyword) || ariaLabel.contains(keyword));
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding image", e);
            return null;
        }
    }
    
    /**
     * Finds a heading element based on purpose and location
     */
    private WebElement findHeading(WebDriver driver, String purpose, String location) {
        List<WebElement> candidates = new ArrayList<>();
        
        try {
            // Look for heading elements h1 through h6
            candidates.addAll(driver.findElements(By.cssSelector("h1, h2, h3, h4, h5, h6")));
            
            // Also look for elements with heading roles
            candidates.addAll(driver.findElements(By.cssSelector("[role='heading']")));
            
            // Filter candidates by purpose if specified
            if (!purpose.isEmpty()) {
                List<String> purposeKeywords = new ArrayList<>();
                purposeKeywords.add(purpose);
                purposeKeywords.addAll(expandWithSynonyms(Collections.singletonList(purpose)));
                
                candidates = candidates.stream()
                    .filter(e -> {
                        String text = e.getText().toLowerCase();
                        
                        return purposeKeywords.stream().anyMatch(text::contains);
                    })
                    .collect(Collectors.toList());
            }
            
            // If we have multiple candidates, try to filter by location
            if (candidates.size() > 1 && !location.isEmpty()) {
                candidates = filterByLocation(candidates, location);
            }
            
            // Return the first (or only) match
            return candidates.isEmpty() ? null : candidates.get(0);
            
        } catch (Exception e) {
            logger.error("Error finding heading", e);
            return null;
        }
    }
    
    /**
     * Finds the text of a label associated with an element
     */
    private String findAssociatedLabelText(WebDriver driver, WebElement element) {
        try {
            // Check for the id attribute
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                // Look for a label with a matching 'for' attribute
                try {
                    WebElement label = driver.findElement(By.cssSelector("label[for='" + id + "']"));
                    if (label != null) {
                        return label.getText().toLowerCase();
                    }
                } catch (Exception e) {
                    // No label found, continue with other methods
                }
            }
            
            // Look for a parent label element
            try {
                WebElement parent = element.findElement(By.xpath("./ancestor::label"));
                if (parent != null) {
                    String labelText = parent.getText().toLowerCase();
                    // Remove the text of the element itself if it's a text input
                    String elementValue = element.getAttribute("value");
                    if (elementValue != null && !elementValue.isEmpty()) {
                        labelText = labelText.replace(elementValue.toLowerCase(), "").trim();
                    }
                    return labelText;
                }
            } catch (Exception e) {
                // No parent label found, continue with other methods
            }
            
            // Look for a label element immediately preceding the element
            try {
                WebElement previousLabel = element.findElement(By.xpath("./preceding::label[1]"));
                if (previousLabel != null && isNearby(element, previousLabel)) {
                    return previousLabel.getText().toLowerCase();
                }
            } catch (Exception e) {
                // No preceding label found or not nearby
            }
            
            // Look for any text node nearby that might serve as a label
            try {
                List<WebElement> nearbyTexts = driver.findElements(By.xpath(
                    "//*[not(self::script or self::style)][text()[normalize-space()]]"));
                
                for (WebElement textElement : nearbyTexts) {
                    if (isNearby(element, textElement)) {
                        return textElement.getText().toLowerCase();
                    }
                }
            } catch (Exception e) {
                // Error finding nearby text
            }
            
            // If no label found, return empty string
            return "";
        } catch (Exception e) {
            logger.error("Error finding associated label", e);
            return "";
        }
    }
    
    /**
     * Checks if two elements are physically near each other on the page
     */
    private boolean isNearby(WebElement element1, WebElement element2) {
        try {
            // Get the locations of both elements
            org.openqa.selenium.Rectangle rect1 = element1.getRect();
            org.openqa.selenium.Rectangle rect2 = element2.getRect();
            
            // Define a proximity threshold (in pixels)
            int threshold = 150;
            
            // Calculate distances
            int horizontalDistance = Math.min(
                Math.abs(rect1.x - (rect2.x + rect2.width)),
                Math.abs(rect2.x - (rect1.x + rect1.width))
            );
            
            int verticalDistance = Math.min(
                Math.abs(rect1.y - (rect2.y + rect2.height)),
                Math.abs(rect2.y - (rect1.y + rect1.height))
            );
            
            // If distance is negative, the elements overlap
            horizontalDistance = Math.max(0, horizontalDistance);
            verticalDistance = Math.max(0, verticalDistance);
            
            // Elements are nearby if they're close either horizontally or vertically
            return horizontalDistance < threshold || verticalDistance < threshold;
            
        } catch (Exception e) {
            // If we can't determine positions, assume they're not nearby
            return false;
        }
    }
    
    /**
     * Filters a list of elements by their location on the page
     */
    private List<WebElement> filterByLocation(List<WebElement> elements, String location) {
        if (elements.isEmpty() || location.isEmpty()) {
            return elements;
        }
        
        List<WebElement> filtered = new ArrayList<>();
        
        try {
            // Get the dimensions of the viewport
            WebElement html = elements.get(0).findElement(By.tagName("html"));
            Dimension viewportSize = html.getSize();
            int viewportWidth = viewportSize.getWidth();
            int viewportHeight = viewportSize.getHeight();
            
            // Define regions of the page
            int topThreshold = viewportHeight / 3;
            int bottomThreshold = viewportHeight * 2 / 3;
            int leftThreshold = viewportWidth / 3;
            int rightThreshold = viewportWidth * 2 / 3;
            
            for (WebElement element : elements) {
                org.openqa.selenium.Rectangle rect = element.getRect();
                
                // Calculate the center point of the element
                int centerX = rect.x + rect.width / 2;
                int centerY = rect.y + rect.height / 2;
                
                boolean matches = false;
                
                switch (location.toLowerCase()) {
                    case "top":
                        matches = centerY < topThreshold;
                        break;
                    case "bottom":
                        matches = centerY > bottomThreshold;
                        break;
                    case "left":
                        matches = centerX < leftThreshold;
                        break;
                    case "right":
                        matches = centerX > rightThreshold;
                        break;
                    case "center":
                        matches = centerY >= topThreshold && centerY <= bottomThreshold &&
                                  centerX >= leftThreshold && centerX <= rightThreshold;
                        break;
                }
                
                if (matches) {
                    filtered.add(element);
                }
            }
            
            if (!filtered.isEmpty()) {
                return filtered;
            }
            
        } catch (Exception e) {
            logger.error("Error filtering elements by location", e);
        }
        
        // If filtering failed or no elements matched, return the original list
        return elements;
    }
    
    /**
     * Finds an element by keyword matching against all elements on the page
     */
    private WebElement findByKeywords(WebDriver driver, List<String> keywords) {
        if (keywords.isEmpty()) {
            return null;
        }
        
        Map<WebElement, Integer> scores = new HashMap<>();
        
        try {
            // Find all visible elements that might be interactive
            List<WebElement> allElements = driver.findElements(By.cssSelector(
                "button, input, select, textarea, a, [role='button'], [role='link'], " +
                "[role='checkbox'], [role='radio'], [role='menuitem'], [role='tab'], " +
                "[tabindex], [class*='btn'], [class*='button']"));
            
            for (WebElement element : allElements) {
                int score = calculateKeywordMatchScore(element, keywords);
                if (score > 0) {
                    scores.put(element, score);
                }
            }
            
            // Find the element with the highest score
            WebElement bestMatch = null;
            int highestScore = 0;
            
            for (Map.Entry<WebElement, Integer> entry : scores.entrySet()) {
                if (entry.getValue() > highestScore) {
                    highestScore = entry.getValue();
                    bestMatch = entry.getKey();
                }
            }
            
            // Only return if the score is above a minimum threshold
            if (highestScore >= 2) {
                return bestMatch;
            }
            
        } catch (Exception e) {
            logger.error("Error in findByKeywords", e);
        }
        
        return null;
    }
    
    /**
     * Calculates a match score between an element and a list of keywords
     */
    private int calculateKeywordMatchScore(WebElement element, List<String> keywords) {
        int score = 0;
        
        try {
            // Check text content
            String text = element.getText().toLowerCase();
            for (String keyword : keywords) {
                if (text.contains(keyword.toLowerCase())) {
                    score += 3; // Text content is highly relevant
                }
            }
            
            // Check various attributes
            String[] attributes = {"id", "name", "class", "placeholder", "value", 
                                  "title", "aria-label", "alt", "data-testid"};
            
            for (String attribute : attributes) {
                String value = element.getAttribute(attribute);
                if (value != null && !value.isEmpty()) {
                    value = value.toLowerCase();
                    for (String keyword : keywords) {
                        if (value.contains(keyword.toLowerCase())) {
                            score += 2; // Attribute matches are relevant
                        }
                    }
                }
            }
            
            // Check for associated label text
            String labelText = findAssociatedLabelText(element.findElement(By.xpath("ancestor::body[1]")).getWrappedDriver(), element);
            for (String keyword : keywords) {
                if (labelText.contains(keyword.toLowerCase())) {
                    score += 3; // Label matches are highly relevant
                }
            }
            
        } catch (Exception e) {
            // Ignore errors and return current score
        }
        
        return score;
    }
    
    /**
     * Initialize a dictionary of common synonyms for UI terms
     */
    private static Map<String, List<String>> initializeSynonymDictionary() {
        Map<String, List<String>> synonyms = new HashMap<>();
        
        // Button-related terms
        synonyms.put("button", Arrays.asList("btn", "submit", "cancel", "ok", "confirm"));
        synonyms.put("submit", Arrays.asList("save", "confirm", "ok", "apply", "send"));
        synonyms.put("cancel", Arrays.asList("close", "exit", "back", "return"));
        
        // Login-related terms
        synonyms.put("login", Arrays.asList("signin", "sign-in", "log-in", "authenticate"));
        synonyms.put("logout", Arrays.asList("signout", "sign-out", "log-out", "exit"));
        synonyms.put("register", Arrays.asList("signup", "sign-up", "create account", "join"));
        
        // Navigation terms
        synonyms.put("next", Arrays.asList("continue", "forward", "proceed"));
        synonyms.put("previous", Arrays.asList("back", "prev", "return"));
        
        // Form field terms
        synonyms.put("email", Arrays.asList("e-mail", "mail", "email address"));
        synonyms.put("password", Arrays.asList("pwd", "pass", "passphrase"));
        synonyms.put("username", Arrays.asList("user", "login", "userid", "user id"));
        synonyms.put("firstname", Arrays.asList("first name", "given name", "forename"));
        synonyms.put("lastname", Arrays.asList("last name", "surname", "family name"));
        
        // Common action terms
        synonyms.put("search", Arrays.asList("find", "lookup", "query"));
        synonyms.put("add", Arrays.asList("create", "new", "insert", "plus"));
        synonyms.put("remove", Arrays.asList("delete", "erase", "trash", "minus"));
        synonyms.put("edit", Arrays.asList("modify", "change", "update"));
        
        return synonyms;
    }
    
    /**
     * Initialize common button text patterns
     */
    private static List<Pattern> initializeButtonPatterns() {
        List<Pattern> patterns = new ArrayList<>();
        
        // Common button text patterns
        patterns.add(Pattern.compile("(?i)log[ -]?in|sign[ -]?in|authenticate"));
        patterns.add(Pattern.compile("(?i)log[ -]?out|sign[ -]?out"));
        patterns.add(Pattern.compile("(?i)register|sign[ -]?up|create account"));
        patterns.add(Pattern.compile("(?i)submit|save|confirm|ok|apply|send"));
        patterns.add(Pattern.compile("(?i)cancel|close|exit|back|return"));
        patterns.add(Pattern.compile("(?i)search|find|lookup|query"));
        patterns.add(Pattern.compile("(?i)add|create|new|insert"));
        patterns.add(Pattern.compile("(?i)remove|delete|erase|trash"));
        patterns.add(Pattern.compile("(?i)edit|modify|change|update"));
        patterns.add(Pattern.compile("(?i)next|continue|forward|proceed"));
        patterns.add(Pattern.compile("(?i)previous|prev|back|return"));
        
        return patterns;
    }
    
    /**
     * Initialize common form field patterns
     */
    private static List<Pattern> initializeFormFieldPatterns() {
        List<Pattern> patterns = new ArrayList<>();
        
        // Common form field patterns
        patterns.add(Pattern.compile("(?i)email|e-mail|mail"));
        patterns.add(Pattern.compile("(?i)password|pwd|pass"));
        patterns.add(Pattern.compile("(?i)username|user|userid|login"));
        patterns.add(Pattern.compile("(?i)first[ -]?name|given[ -]?name|forename"));
        patterns.add(Pattern.compile("(?i)last[ -]?name|surname|family[ -]?name"));
        patterns.add(Pattern.compile("(?i)address|street|location"));
        patterns.add(Pattern.compile("(?i)city|town"));
        patterns.add(Pattern.compile("(?i)state|province|region"));
        patterns.add(Pattern.compile("(?i)zip|zipcode|postal[ -]?code"));
        patterns.add(Pattern.compile("(?i)country|nation"));
        patterns.add(Pattern.compile("(?i)phone|telephone|mobile"));
        
        return patterns;
    }
}



public class TestPlanDetails {
    private final String id;
    private final String name;
    private final String description;
    private final String state;
    
    public TestPlanDetails(String id, String name, String description, String state) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.state = state;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public String getState() { return state; }
}

public class TestSuite {
    private final String id;
    private final String name;
    private final String parentId;
    
    public TestSuite(String id, String name, String parentId) {
        this.id = id;
        this.name = name;
        this.parentId = parentId;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public String getParentId() { return parentId; }
}

public class TestCase {
    private final String id;
    private final String name;
    private final int priority;/**
 * Create a GET HTTP request with proper headers
 */
private HttpRequest createGetRequest(String url) {
    return HttpRequest.newBuilder()
        .uri(URI.create(url))
        .header("Accept", "application/json")
        .header("Authorization", getAuthHeader())
        .GET()
        .build();
}

/**
 * Create a POST HTTP request with proper headers and body
 */
private HttpRequest createPostRequest(String url, String body) {
    return HttpRequest.newBuilder()
        .uri(URI.create(url))
        .header("Content-Type", "application/json")
        .header("Accept", "application/json")
        .header("Authorization", getAuthHeader())
        .POST(HttpRequest.BodyPublishers.ofString(body))
        .build();
}

/**
 * Get the Authorization header value for ADO API
 */
private String getAuthHeader() {
    String pat = config.getProperty("ado.pat");
    if (pat == null) {
        throw new CSSmartException("ADO Personal Access Token not configured in application.properties");
    }
    
    String auth = ":" + pat;
    return "Basic " + Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
}



    
    public TestCase(String id, String name, int priority) {
        this.id = id;
        this.name = name;
        this.priority = priority;
    }
    
    public String getId() { return id; }
    public String getName() { return name; }
    public int getPriority() { return priority; }
}



package com.cssmart.framework.driver;

import com.cssmart.framework.exceptions.CSSmartElementException;
import com.cssmart.framework.logging.CSSmartLogger;
import com.cssmart.framework.reporting.CSSmartReport;
import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.Point;
import org.openqa.selenium.Rectangle;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriverException;
import org.openqa.selenium.WebElement;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Enhanced WebElement with detailed reporting
 */
public class CSSmartWebElement implements WebElement, TakesScreenshot {
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartWebElement.class);
    private static final CSSmartReport report = CSSmartReport.getInstance();
    
    private final CSSmartDriver driver;
    private WebElement element;
    private final By locator;
    private final String elementName;
    
    /**
     * Constructor with CSSmartDriver and locator
     * @param driver the CSSmartDriver
     * @param locator the locator
     * @param elementName the element name for reporting
     */
    public CSSmartWebElement(CSSmartDriver driver, By locator, String elementName) {
        this.driver = driver;
        this.locator = locator;
        this.elementName = elementName;
        
        // Find the element
        try {
            this.element = driver.getWrappedDriver().findElement(locator);
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to find element: " + elementName, e);
        }
    }
    
    /**
     * Constructor with CSSmartDriver and WebElement
     * @param driver the CSSmartDriver
     * @param element the WebElement
     * @param locator the locator
     * @param elementName the element name for reporting
     */
    public CSSmartWebElement(CSSmartDriver driver, WebElement element, By locator, String elementName) {
        this.driver = driver;
        this.element = element;
        this.locator = locator;
        this.elementName = elementName;
    }
    
    /**
     * Get the wrapped WebElement
     * @return the WebElement
     */
    public WebElement getWrappedElement() {
        return element;
    }
    
    /**
     * Get the element locator
     * @return the locator
     */
    public By getLocator() {
        return locator;
    }
    
    /**
     * Get the original locator (alias for getLocator)
     * @return the locator
     */
    public By getOriginalLocator() {
        return locator;
    }
    
    /**
     * Get the element name
     * @return the element name
     */
    public String getElementName() {
        return elementName;
    }
    
    /**
     * Attempt to heal a stale element
     */
    private void healElement() {
        try {
            logger.info("Attempting to heal stale element: " + elementName);
            this.element = driver.getWrappedDriver().findElement(locator);
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to heal stale element: " + elementName, e);
        }
    }
    
    // Enhanced WebElement methods
    
    @Override
    public void click() {
        try {
            logger.debug("Clicking on element: " + elementName);
            report.logInfo("Clicking on element: " + elementName);
            element.click();
        } catch (Exception e) {
            // Try to heal stale element
            try {
                healElement();
                logger.debug("Retrying click after healing element: " + elementName);
                element.click();
            } catch (Exception ex) {
                report.logError("Failed to click on element: " + elementName);
                throw new CSSmartElementException("Failed to click on element: " + elementName, e);
            }
        }
    }
    
    @Override
    public void submit() {
        try {
            logger.debug("Submitting form with element: " + elementName);
            report.logInfo("Submitting form with element: " + elementName);
            element.submit();
        } catch (Exception e) {
            // Try to heal stale element
            try {
                healElement();
                logger.debug("Retrying submit after healing element: " + elementName);
                element.submit();
            } catch (Exception ex) {
                report.logError("Failed to submit form with element: " + elementName);
                throw new CSSmartElementException("Failed to submit form with element: " + elementName, e);
            }
        }
    }
    
    @Override
    public void sendKeys(CharSequence... keysToSend) {
        try {
            String text = String.join("", keysToSend);
            logger.debug("Sending keys to element: " + elementName + " - " + text);
            report.logInfo("Sending keys to element: " + elementName + " - " + text);
            element.sendKeys(keysToSend);
        } catch (Exception e) {
            // Try to heal stale element
            try {
                healElement();
                logger.debug("Retrying sendKeys after healing element: " + elementName);
                element.sendKeys(keysToSend);
            } catch (Exception ex) {
                report.logError("Failed to send keys to element: " + elementName);
                throw new CSSmartElementException("Failed to send keys to element: " + elementName, e);
            }
        }
    }
    
    @Override
    public void clear() {
        try {
            logger.debug("Clearing element: " + elementName);
            report.logInfo("Clearing element: " + elementName);
            element.clear();
        } catch (Exception e) {
            // Try to heal stale element
            try {
                healElement();
                logger.debug("Retrying clear after healing element: " + elementName);
                element.clear();
            } catch (Exception ex) {
                report.logError("Failed to clear element: " + elementName);
                throw new CSSmartElementException("Failed to clear element: " + elementName, e);
            }
        }
    }
    
    @Override
    public String getTagName() {
        try {
            return element.getTagName();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getTagName();
        }
    }
    
    @Override
    public String getAttribute(String name) {
        try {
            return element.getAttribute(name);
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getAttribute(name);
        }
    }
    
    @Override
    public boolean isSelected() {
        try {
            return element.isSelected();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.isSelected();
        }
    }
    
    @Override
    public boolean isEnabled() {
        try {
            return element.isEnabled();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.isEnabled();
        }
    }
    
    @Override
    public String getText() {
        try {
            return element.getText();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getText();
        }
    }
    
    @Override
    public List<WebElement> findElements(By by) {
        try {
            List<WebElement> elements = element.findElements(by);
            
            // Convert to CSSmartWebElement
            return elements.stream()
                .map(e -> new CSSmartWebElement(driver, e, by, elementName + "." + by))
                .collect(Collectors.toList());
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            List<WebElement> elements = element.findElements(by);
            
            // Convert to CSSmartWebElement
            return elements.stream()
                .map(e -> new CSSmartWebElement(driver, e, by, elementName + "." + by))
                .collect(Collectors.toList());
        }
    }
    
    @Override
    public CSSmartWebElement findElement(By by) {
        try {
            WebElement foundElement = element.findElement(by);
            return new CSSmartWebElement(driver, foundElement, by, elementName + "." + by);
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            WebElement foundElement = element.findElement(by);
            return new CSSmartWebElement(driver, foundElement, by, elementName + "." + by);
        }
    }
    
    @Override
    public boolean isDisplayed() {
        try {
            return element.isDisplayed();
        } catch (Exception e) {
            // Try to heal stale element
            try {
                healElement();
                return element.isDisplayed();
            } catch (Exception ex) {
                // If healing fails, assume element is not displayed
                return false;
            }
        }
    }
    
    @Override
    public Point getLocation() {
        try {
            return element.getLocation();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getLocation();
        }
    }
    
    @Override
    public Dimension getSize() {
        try {
            return element.getSize();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getSize();
        }
    }
    
    @Override
    public Rectangle getRect() {
        try {
            return element.getRect();
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getRect();
        }
    }
    
    @Override
    public String getCssValue(String propertyName) {
        try {
            return element.getCssValue(propertyName);
        } catch (Exception e) {
            // Try to heal stale element
            healElement();
            return element.getCssValue(propertyName);
        }
    }
    
    @Override
    public <X> X getScreenshotAs(OutputType<X> target) throws WebDriverException {
        try {
            return this.element.getScreenshotAs(target);
        } catch (Exception e) {
            // Try to heal stale element
            try {
                this.healElement();
                return this.element.getScreenshotAs(target);
            } catch (Exception ex) {
                throw new WebDriverException("Failed to get screenshot after healing attempt", ex);
            }
        }
    }
    
    /**
     * Wait for element to be visible
     * @param timeoutSeconds timeout in seconds
     * @return this element
     */
    public CSSmartWebElement waitForVisible(int timeoutSeconds) {
        long startTime = System.currentTimeMillis();
        long endTime = startTime + (timeoutSeconds * 1000);
        
        while (System.currentTimeMillis() < endTime) {
            try {
                if (isDisplayed()) {
                    return this;
                }
                
                // Short pause between checks
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                // Ignore and continue waiting
            }
        }
        
        throw new CSSmartElementException("Timeout waiting for element to be visible: " + elementName);
    }
    
    /**
     * Wait for element to be clickable (visible and enabled)
     * @param timeoutSeconds timeout in seconds
     * @return this element
     */
    public CSSmartWebElement waitForClickable(int timeoutSeconds) {
        long startTime = System.currentTimeMillis();
        long endTime = startTime + (timeoutSeconds * 1000);
        
        while (System.currentTimeMillis() < endTime) {
            try {
                if (isDisplayed() && isEnabled()) {
                    return this;
                }
                
                // Short pause between checks
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                // Ignore and continue waiting
            }
        }
        
        throw new CSSmartElementException("Timeout waiting for element to be clickable: " + elementName);
    }
    
    /**
     * Smart click with automatic waiting
     * @return this element
     */
    public CSSmartWebElement smartClick() {
        try {
            waitForClickable(10);
            click();
            return this;
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to smart click on element: " + elementName, e);
        }
    }
    
    /**
     * Smart send keys with automatic waiting and clearing
     * @param text the text to send
     * @return this element
     */
    public CSSmartWebElement smartSendKeys(String text) {
        try {
            waitForVisible(10);
            clear();
            sendKeys(text);
            return this;
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to smart send keys to element: " + elementName, e);
        }
    }
    
    /**
     * Smart wait then get text
     * @return the element text
     */
    public String smartGetText() {
        try {
            waitForVisible(10);
            return getText();
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to smart get text from element: " + elementName, e);
        }
    }
    
    /**
     * Take a screenshot of this element
     * @param screenshotName the name of the screenshot
     * @return the path to the saved screenshot
     */
    public String takeScreenshot(String screenshotName) {
        try {
            return report.takeElementScreenshot(this, screenshotName);
        } catch (Exception e) {
            throw new CSSmartElementException("Failed to take screenshot of element: " + elementName, e);
        }
    }
}




package com.cssmart.framework.utils;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

/**
 * Utility class for cryptographic operations
 */
public class CSSmartCryptoUtils {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartCryptoUtils.class);
    
    /**
     * Computes the SHA-256 hash of a string
     * 
     * @param input the string to hash
     * @return the SHA-256 hash as a hex string
     */
    public static String sha256Hash(String input) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (NoSuchAlgorithmException e) {
            logger.error("SHA-256 algorithm not available", e);
            // Fallback to simple hashing if SHA-256 is not available
            return String.valueOf(input.hashCode());
        }
    }
    
    /**
     * Converts bytes to a hexadecimal string
     * 
     * @param bytes the bytes to convert
     * @return a hexadecimal string
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder builder = new StringBuilder();
        for (byte b : bytes) {
            builder.append(String.format("%02x", b));
        }
        return builder.toString();
    }
    
    /**
     * Encodes a string to Base64
     * 
     * @param input the string to encode
     * @return the Base64 encoded string
     */
    public static String base64Encode(String input) {
        return Base64.getEncoder().encodeToString(input.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * Decodes a Base64 string
     * 
     * @param encoded the Base64 encoded string
     * @return the decoded string
     */
    public static String base64Decode(String encoded) {
        try {
            byte[] decodedBytes = Base64.getDecoder().decode(encoded);
            return new String(decodedBytes, StandardCharsets.UTF_8);
        } catch (IllegalArgumentException e) {
            logger.error("Invalid Base64 string: " + encoded, e);
            return encoded; // Return original string if decoding fails
        }
    }
}





package com.cssmart.framework.utils;

import java.util.List;

/**
 * Utility class for statistical operations
 */
public class CSSmartStatisticsUtil {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartStatisticsUtil.class);
    
    /**
     * Calculates the mean (average) of a list of doubles
     * 
     * @param values the list of values
     * @return the mean value
     */
    public static double calculateMean(List<Double> values) {
        if (values == null || values.isEmpty()) {
            return 0.0;
        }
        
        double sum = 0.0;
        for (Double value : values) {
            sum += value;
        }
        
        return sum / values.size();
    }
    
    /**
     * Calculates the standard deviation of a list of doubles
     * 
     * @param values the list of values
     * @return the standard deviation
     */
    public static double calculateStandardDeviation(List<Double> values) {
        if (values == null || values.size() <= 1) {
            return 0.0;
        }
        
        double mean = calculateMean(values);
        double sumSquaredDiff = 0.0;
        
        for (Double value : values) {
            double diff = value - mean;
            sumSquaredDiff += diff * diff;
        }
        
        return Math.sqrt(sumSquaredDiff / values.size());
    }
    
    /**
     * Calculates the correlation coefficient between two lists of doubles
     * 
     * @param xValues the first list of values
     * @param yValues the second list of values
     * @return the correlation coefficient (-1.0 to 1.0), or 0.0 if calculation fails
     */
    public static double calculateCorrelation(List<Double> xValues, List<Double> yValues) {
        if (xValues == null || yValues == null || xValues.size() != yValues.size() || xValues.isEmpty()) {
            logger.warning("Cannot calculate correlation with invalid inputs");
            return 0.0;
        }
        
        try {
            int n = xValues.size();
            
            // Calculate means
            double xMean = calculateMean(xValues);
            double yMean = calculateMean(yValues);
            
            // Calculate sums for the formulas
            double sumXY = 0.0;
            double sumX2 = 0.0;
            double sumY2 = 0.0;
            
            for (int i = 0; i < n; i++) {
                double xDiff = xValues.get(i) - xMean;
                double yDiff = yValues.get(i) - yMean;
                
                sumXY += xDiff * yDiff;
                sumX2 += xDiff * xDiff;
                sumY2 += yDiff * yDiff;
            }
            
            // Calculate correlation (Pearson's r)
            if (sumX2 > 0 && sumY2 > 0) {
                return sumXY / (Math.sqrt(sumX2) * Math.sqrt(sumY2));
            } else {
                return 0.0; // No variation in at least one of the variables
            }
        } catch (Exception e) {
            logger.error("Error calculating correlation: " + e.getMessage(), e);
            return 0.0;
        }
    }
    
    /**
     * Calculates the percentile of a list of doubles
     * 
     * @param values the list of values
     * @param percentile the percentile to calculate (0-100)
     * @return the percentile value
     */
    public static double calculatePercentile(List<Double> values, double percentile) {
        if (values == null || values.isEmpty()) {
            return 0.0;
        }
        
        // Make a copy of the list and sort it
        List<Double> sortedValues = new java.util.ArrayList<>(values);
        java.util.Collections.sort(sortedValues);
        
        // Calculate the index
        double index = percentile * (sortedValues.size() - 1) / 100.0;
        int lowerIndex = (int) Math.floor(index);
        int upperIndex = (int) Math.ceil(index);
        
        if (lowerIndex == upperIndex) {
            return sortedValues.get(lowerIndex);
        } else {
            // Interpolate between the two values
            double weight = index - lowerIndex;
            return (1 - weight) * sortedValues.get(lowerIndex) + weight * sortedValues.get(upperIndex);
        }
    }
    
    /**
     * Calculates the median of a list of doubles
     * 
     * @param values the list of values
     * @return the median value
     */
    public static double calculateMedian(List<Double> values) {
        return calculatePercentile(values, 50.0);
    }
}


package com.cssmart.framework.ai;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;

import com.cssmart.framework.config.CSSmartConfigManager;
import com.cssmart.framework.logging.CSSmartLogger;
import com.cssmart.framework.reporting.CSSmartReport;
import com.cssmart.framework.utils.CSSmartCryptoUtils;
import com.cssmart.framework.utils.CSSmartStatisticsUtil;

/**
 * Implements a machine learning based test path analyzer that learns from test
 * executions and suggests optimal test execution paths
 */
public class CSSmartTestPathAnalyzer {
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartTestPathAnalyzer.class);
    private static final CSSmartReport report = CSSmartReport.getInstance();
    private static CSSmartTestPathAnalyzer instance;
    
    // Configuration
    private final boolean enabled;
    private final String dataStoragePath;
    private final int minimumDataPoints;
    
    // Test execution history
    private final Map<String, TestExecutionData> testHistory;
    
    // Path analysis cache
    private final Map<String, PathAnalysisResult> analysisCache;
    
    // Feature weights - will be adjusted through learning
    private final Map<String, Double> featureWeights;
    
    // Current test session data
    private final Map<String, List<TestStepData>> currentSession;
    
    // Last training time
    private Instant lastModelTrainingTime;
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private CSSmartTestPathAnalyzer() {
        CSSmartConfigManager config = CSSmartConfigManager.getInstance();
        
        // Initialize configuration
        this.enabled = config.getBooleanProperty("testpath.analyzer.enabled", true);
        this.dataStoragePath = config.getProperty("testpath.analyzer.data.path", 
                                                  System.getProperty("user.home") + File.separator + 
                                                  ".cssmart" + File.separator + "testdata");
        this.minimumDataPoints = config.getIntProperty("testpath.analyzer.min.datapoints", 5);
                
        // Initialize data structures
        this.testHistory = new ConcurrentHashMap<>();
        this.analysisCache = new ConcurrentHashMap<>();
        this.featureWeights = initializeFeatureWeights();
        this.currentSession = new ConcurrentHashMap<>();
        
        // Create storage directory if needed
        createDataStorageDirectory();
        
        // Load historical data
        loadTestExecutionHistory();
        
        logger.info("Test Path Analyzer initialized. Enabled: " + enabled);
    }
    
    /**
     * Gets the singleton instance of CSSmartTestPathAnalyzer
     */
    public static synchronized CSSmartTestPathAnalyzer getInstance() {
        if (instance == null) {
            instance = new CSSmartTestPathAnalyzer();
        }
        return instance;
    }
    
    /**
     * Initializes feature weights with default values
     */
    private Map<String, Double> initializeFeatureWeights() {
        Map<String, Double> weights = new HashMap<>();
        
        // Default weights based on importance of different features
        weights.put("executionTime", 1.0);      // Execution time is a primary factor
        weights.put("passRate", 1.5);           // Pass rate is highly important
        weights.put("complexity", 0.8);         // Test complexity matters but less than pass rate
        weights.put("dataDependency", 0.6);     // Data dependencies between tests
        weights.put("resourceUsage", 0.4);      // Resource usage is less important initially
        weights.put("coverageGain", 1.2);       // Coverage gain is important
        weights.put("flakiness", 1.3);          // Flakiness is very important to consider
        weights.put("lastExecutionStatus", 0.7); // Recent failures might need prioritization
        weights.put("age", 0.3);                // How recently the test was created/modified
        weights.put("userPriority", 1.1);       // User-defined priority can override algorithms
        
        return weights;
    }
    
    /**
     * Creates data storage directory if it doesn't exist
     */
    private void createDataStorageDirectory() {
        try {
            Path directory = Paths.get(dataStoragePath);
            if (!Files.exists(directory)) {
                Files.createDirectories(directory);
                logger.info("Created test path analyzer data directory: " + dataStoragePath);
            }
        } catch (IOException e) {
            logger.error("Failed to create data directory: " + e.getMessage(), e);
        }
    }
    
    /**
     * Loads historical test execution data from files
     */
    private void loadTestExecutionHistory() {
        if (!enabled) return;
        
        try {
            loadHistoryFromFiles();
            
            int historySize = testHistory.size();
            logger.info("Loaded " + historySize + " test execution records");
            
            // Pre-calculate analysis results for common test suites
            if (historySize >= minimumDataPoints) {
                updateModel();
            }
        } catch (Exception e) {
            logger.error("Error loading test execution history: " + e.getMessage(), e);
        }
    }
    
    /**
     * Loads test history from file storage
     */
    private void loadHistoryFromFiles() throws Exception {
        Path historyDir = Paths.get(dataStoragePath);
        if (!Files.exists(historyDir)) {
            return;
        }
        
        // Iterate through all JSON files in the directory
        Files.list(historyDir)
            .filter(path -> path.toString().endsWith(".json"))
            .forEach(path -> {
                try {
                    String content = new String(Files.readAllBytes(path));
                    TestExecutionData data = parseTestExecutionData(content);
                    if (data != null && data.getTestId() != null) {
                        testHistory.put(data.getTestId(), data);
                    }
                } catch (Exception e) {
                    logger.debug("Error loading test history file: " + path, e);
                }
            });
    }
    
    /**
     * Parses test execution data from JSON string
     */
    private TestExecutionData parseTestExecutionData(String json) {
        try {
            // Simple JSON parsing without external libraries
            TestExecutionData data = new TestExecutionData();
            
            // Extract testId
            String testIdPattern = "\"testId\"\\s*:\\s*\"([^\"]+)\"";
            java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(testIdPattern);
            java.util.regex.Matcher matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setTestId(matcher.group(1));
            }
            
            // Extract execution time
            String executionTimePattern = "\"executionTime\"\\s*:\\s*(\\d+)";
            pattern = java.util.regex.Pattern.compile(executionTimePattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setExecutionTime(Long.parseLong(matcher.group(1)));
            }
            
            // Extract result
            String resultPattern = "\"result\"\\s*:\\s*\"([^\"]+)\"";
            pattern = java.util.regex.Pattern.compile(resultPattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setResult(matcher.group(1));
            }
            
            // Extract duration
            String durationPattern = "\"duration\"\\s*:\\s*(\\d+)";
            pattern = java.util.regex.Pattern.compile(durationPattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setDuration(Long.parseLong(matcher.group(1)));
            }
            
            // Extract resource usage
            String resourceUsagePattern = "\"resourceUsage\"\\s*:\\s*([\\d.]+)";
            pattern = java.util.regex.Pattern.compile(resourceUsagePattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setResourceUsage(Double.parseDouble(matcher.group(1)));
            }
            
            // Extract complexity score
            String complexityPattern = "\"complexityScore\"\\s*:\\s*([\\d.]+)";
            pattern = java.util.regex.Pattern.compile(complexityPattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setComplexityScore(Double.parseDouble(matcher.group(1)));
            }
            
            // Extract flakiness
            String flakinessPattern = "\"flakiness\"\\s*:\\s*([\\d.]+)";
            pattern = java.util.regex.Pattern.compile(flakinessPattern);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                data.setFlakiness(Double.parseDouble(matcher.group(1)));
            }
            
            // Extract dependencies
            String dependenciesPattern = "\"dependencies\"\\s*:\\s*(\\[.*?\\])";
            pattern = java.util.regex.Pattern.compile(dependenciesPattern, java.util.regex.Pattern.DOTALL);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                String dependenciesJson = matcher.group(1);
                data.setDependencies(parseStringList(dependenciesJson));
            }
            
            // Extract coverage
            String coveragePattern = "\"coverage\"\\s*:\\s*(\\{.*?\\})";
            pattern = java.util.regex.Pattern.compile(coveragePattern, java.util.regex.Pattern.DOTALL);
            matcher = pattern.matcher(json);
            if (matcher.find()) {
                String coverageJson = matcher.group(1);
                data.setCoverage(parseMap(coverageJson));
            }
            
            return data;
        } catch (Exception e) {
            logger.debug("Error parsing test execution data: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a JSON string list into a List<String>
     */
    private List<String> parseStringList(String json) {
        List<String> result = new ArrayList<>();
        try {
            // Basic JSON array parsing
            if (json.startsWith("[") && json.endsWith("]")) {
                String content = json.substring(1, json.length() - 1);
                String[] items = content.split(",");
                
                for (String item : items) {
                    // Remove quotes and trim
                    item = item.trim();
                    if (item.startsWith("\"") && item.endsWith("\"")) {
                        item = item.substring(1, item.length() - 1);
                    }
                    result.add(item);
                }
            }
        } catch (Exception e) {
            logger.debug("Error parsing string list: " + e.getMessage());
        }
        return result;
    }
    
    /**
     * Parses a JSON map into a Map<String, Double>
     */
    private Map<String, Double> parseMap(String json) {
        Map<String, Double> result = new HashMap<>();
        try {
            // Basic JSON object parsing
            if (json.startsWith("{") && json.endsWith("}")) {
                String content = json.substring(1, json.length() - 1);
                String[] pairs = content.split(",");
                
                for (String pair : pairs) {
                    String[] keyValue = pair.split(":");
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim();
                        String value = keyValue[1].trim();
                        
                        // Remove quotes from key
                        if (key.startsWith("\"") && key.endsWith("\"")) {
                            key = key.substring(1, key.length() - 1);
                        }
                        
                        result.put(key, Double.parseDouble(value));
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Error parsing map: " + e.getMessage());
        }
        return result;
    }
    
    /**
     * Records the start of a test execution
     */
    public void recordTestStart(String testId, String testName, Map<String, String> metadata) {
        if (!enabled) return;
        
        try {
            // Create or retrieve test step list for this test
            List<TestStepData> steps = currentSession.computeIfAbsent(testId, k -> new ArrayList<>());
            
            // Create test step data for the test start
            TestStepData startStep = new TestStepData();
            startStep.setTestId(testId);
            startStep.setTestName(testName);
            startStep.setStepType("START");
            startStep.setTimestamp(System.currentTimeMillis());
            startStep.setMetadata(metadata != null ? new HashMap<>(metadata) : new HashMap<>());
            
            // Add to the steps list
            steps.add(startStep);
            
            logger.debug("Recorded test start: " + testId);
        } catch (Exception e) {
            logger.debug("Error recording test start: " + e.getMessage());
        }
    }
    
    /**
     * Records a test step execution
     */
    public void recordTestStep(String testId, String stepName, String stepType, 
                              boolean stepPassed, long durationMs, Map<String, String> metadata) {
        if (!enabled) return;
        
        try {
            // Create or retrieve test step list for this test
            List<TestStepData> steps = currentSession.computeIfAbsent(testId, k -> new ArrayList<>());
            
            // Create test step data
            TestStepData stepData = new TestStepData();
            stepData.setTestId(testId);
            stepData.setStepName(stepName);
            stepData.setStepType(stepType);
            stepData.setPassed(stepPassed);
            stepData.setDuration(durationMs);
            stepData.setTimestamp(System.currentTimeMillis());
            stepData.setMetadata(metadata != null ? new HashMap<>(metadata) : new HashMap<>());
            
            // Add to the steps list
            steps.add(stepData);
            
            logger.debug("Recorded test step: " + testId + " / " + stepName);
        } catch (Exception e) {
            logger.debug("Error recording test step: " + e.getMessage());
        }
    }
    
    /**
     * Records the end of a test execution
     */
    public void recordTestEnd(String testId, boolean passed, long durationMs, 
                             Map<String, Double> coverage, Map<String, String> metadata) {
        if (!enabled) return;
        
        try {
            // Create test execution data
            TestExecutionData execData = new TestExecutionData();
            execData.setTestId(testId);
            execData.setExecutionTime(System.currentTimeMillis());
            execData.setResult(passed ? "PASS" : "FAIL");
            execData.setDuration(durationMs);
            
            // Get steps for this test
            List<TestStepData> steps = currentSession.get(testId);
            if (steps != null) {
                // Calculate complexity based on steps
                execData.setComplexityScore(calculateComplexity(steps));
                
                // Calculate resource usage
                execData.setResourceUsage(calculateResourceUsage(steps));
                
                // Extract dependencies
                execData.setDependencies(extractDependencies(steps));
            }
            
            // Set coverage data
            if (coverage != null) {
                execData.setCoverage(new HashMap<>(coverage));
            }
            
            // Set flakiness score based on history
            execData.setFlakiness(calculateFlakiness(testId, passed));
            
            // Store execution data
            storeTestExecutionData(execData);
            
            // Update in-memory history
            testHistory.put(testId, execData);
            
            // Clean up session data
            currentSession.remove(testId);
            
            // Log to report
            report.logInfo("Test completed: " + testId + ", passed: " + passed + ", duration: " + durationMs + "ms");
            logger.info("Recorded test end: " + testId + ", passed: " + passed + ", duration: " + durationMs + "ms");
            
            // Check if we need to update model
            checkAndUpdateModel();
        } catch (Exception e) {
            logger.error("Error recording test end: " + e.getMessage(), e);
        }
    }
    
    /**
     * Stores test execution data to a file
     */
    private void storeTestExecutionData(TestExecutionData data) throws Exception {
        storeToFile(data);
    }
    
    /**
     * Stores test execution data to file
     */
    private void storeToFile(TestExecutionData data) throws Exception {
        // Create filename based on test ID and timestamp
        String filename = CSSmartCryptoUtils.sha256Hash(data.getTestId()) + "_" + 
                          data.getExecutionTime() + ".json";
        
        Path filePath = Paths.get(dataStoragePath, filename);
        
        // Convert data to JSON
        String json = convertToJson(data);
        
        // Write to file
        Files.write(filePath, json.getBytes());
    }
    
    /**
     * Converts test execution data to JSON string
     */
    private String convertToJson(TestExecutionData data) {
        StringBuilder json = new StringBuilder();
        json.append("{");
        
        json.append("\"testId\":\"").append(data.getTestId()).append("\",");
        json.append("\"executionTime\":").append(data.getExecutionTime()).append(",");
        json.append("\"result\":\"").append(data.getResult()).append("\",");
        json.append("\"duration\":").append(data.getDuration()).append(",");
        json.append("\"resourceUsage\":").append(data.getResourceUsage()).append(",");
        json.append("\"complexityScore\":").append(data.getComplexityScore()).append(",");
        
        // Add dependencies
        json.append("\"dependencies\":").append(convertListToJson(data.getDependencies())).append(",");
        
        // Add coverage
        json.append("\"coverage\":").append(convertMapToJson(data.getCoverage())).append(",");
        
        json.append("\"flakiness\":").append(data.getFlakiness());
        
        json.append("}");
        return json.toString();
    }
    
    /**
     * Converts a list to JSON array
     */
    private String convertListToJson(List<String> list) {
        if (list == null || list.isEmpty()) {
            return "[]";
        }
        
        StringBuilder json = new StringBuilder();
        json.append("[");
        
        boolean first = true;
        for (String item : list) {
            if (!first) {
                json.append(",");
            }
            json.append("\"").append(item).append("\"");
            first = false;
        }
        
        json.append("]");
        return json.toString();
    }
    
    /**
     * Converts a map to JSON object
     */
    private String convertMapToJson(Map<String, Double> map) {
        if (map == null || map.isEmpty()) {
            return "{}";
        }
        
        StringBuilder json = new StringBuilder();
        json.append("{");
        
        boolean first = true;
        for (Map.Entry<String, Double> entry : map.entrySet()) {
            if (!first) {
                json.append(",");
            }
            json.append("\"").append(entry.getKey()).append("\":")
                .append(entry.getValue());
            first = false;
        }
        
        json.append("}");
        return json.toString();
    }
    
    /**
     * Calculates test complexity score based on test steps
     */
    private double calculateComplexity(List<TestStepData> steps) {
        if (steps == null || steps.isEmpty()) {
            return 0.0;
        }
        
        // Count different types of actions
        int validationCount = 0;
        int interactionCount = 0;
        int navigationCount = 0;
        int dataOperationCount = 0;
        
        for (TestStepData step : steps) {
            String type = step.getStepType();
            if (type == null) continue;
            
            switch (type.toUpperCase()) {
                case "ASSERT":
                case "VERIFY":
                case "VALIDATE":
                    validationCount++;
                    break;
                case "CLICK":
                case "TYPE":
                case "SELECT":
                case "DRAG":
                    interactionCount++;
                    break;
                case "NAVIGATE":
                case "REDIRECT":
                    navigationCount++;
                    break;
                case "DATA":
                case "API":
                case "DB":
                    dataOperationCount++;
                    break;
            }
        }
        
        // Calculate complexity score
        // More interactive steps and validations = higher complexity
        double baseComplexity = 0.1 * steps.size();
        double interactionComplexity = 0.2 * interactionCount;
        double validationComplexity = 0.3 * validationCount;
        double navigationComplexity = 0.2 * navigationCount;
        double dataComplexity = 0.4 * dataOperationCount;
        
        return baseComplexity + interactionComplexity + validationComplexity + 
               navigationComplexity + dataComplexity;
    }
    
    /**
     * Calculates resource usage based on test steps
     */
    private double calculateResourceUsage(List<TestStepData> steps) {
        if (steps == null || steps.isEmpty()) {
            return 0.0;
        }
        
        // Sum up durations and check for resource-intensive operations
        long totalDuration = 0;
        int resourceIntensiveOps = 0;
        
        for (TestStepData step : steps) {
            totalDuration += step.getDuration();
            
            // Check for resource-intensive operations in metadata
            Map<String, String> metadata = step.getMetadata();
            if (metadata != null) {
                if ("true".equalsIgnoreCase(metadata.get("memoryIntensive")) ||
                    "true".equalsIgnoreCase(metadata.get("cpuIntensive")) ||
                    "true".equalsIgnoreCase(metadata.get("ioIntensive"))) {
                    resourceIntensiveOps++;
                }
            }
        }
        
        // Calculate resource usage score
        double durationFactor = Math.min(1.0, totalDuration / 10000.0); // Normalize to 0-1
        double intensiveOpsFactor = Math.min(1.0, resourceIntensiveOps / 5.0); // Normalize to 0-1
        
        return (durationFactor * 0.7) + (intensiveOpsFactor * 0.3);
    }
    
    /**
     * Extracts test dependencies from test steps
     */
    private List<String> extractDependencies(List<TestStepData> steps) {
        Set<String> dependencies = new HashSet<>();
        
        if (steps != null) {
            for (TestStepData step : steps) {
                Map<String, String> metadata = step.getMetadata();
                if (metadata != null) {
                    String deps = metadata.get("dependencies");
                    if (deps != null && !deps.isEmpty()) {
                        // Split comma-separated dependencies
                        String[] depsArray = deps.split(",");
                        for (String dep : depsArray) {
                            dependencies.add(dep.trim());
                        }
                    }
                }
            }
        }
        
        return new ArrayList<>(dependencies);
    }
    
    /**
     * Calculates flakiness score based on test history
     */
    private double calculateFlakiness(String testId, boolean currentPassed) {
        TestExecutionData previousData = testHistory.get(testId);
        if (previousData == null) {
            // No history, baseline flakiness
            return 0.1;
        }
        
        // Get previous 10 executions if available
        List<TestExecutionData> recentExecutions = getRecentExecutions(testId, 10);
        
        // If we have multiple executions
        if (recentExecutions.size() > 1) {
            int passCount = 0;
            int totalCount = recentExecutions.size();
            
            for (TestExecutionData exec : recentExecutions) {
                if ("PASS".equals(exec.getResult())) {
                    passCount++;
                }
            }
            
            // Calculate pass rate
            double passRate = (double) passCount / totalCount;
            
            // Flakiness is higher when the pass rate is closer to 0.5
            // (most unpredictable) and lower when it's close to 0 or 1
            double flakiness = 1.0 - (Math.abs(passRate - 0.5) * 2.0);
            
            // Adjust based on current result vs previous result
            if (previousData != null) {
                boolean previousPassed = "PASS".equals(previousData.getResult());
                if (previousPassed != currentPassed) {
                    // Outcome changed, increase flakiness
                    flakiness += 0.2;
                }
            }
            
            return Math.min(1.0, Math.max(0.0, flakiness));
        } else {
            // Not enough history
            return 0.1;
        }
    }
    
    /**
     * Gets recent test executions
     */
    private List<TestExecutionData> getRecentExecutions(String testId, int limit) {
        // First check in-memory history
        TestExecutionData data = testHistory.get(testId);
        List<TestExecutionData> result = new ArrayList<>();
        
        if (data != null) {
            result.add(data);
        }
        
        // Search for files
        try {
            Path historyDir = Paths.get(dataStoragePath);
            if (Files.exists(historyDir)) {
                // Find files for this test
                String testIdHash = CSSmartCryptoUtils.sha256Hash(testId);
                
                List<Path> matchingFiles = Files.list(historyDir)
                    .filter(path -> path.toString().contains(testIdHash))
                    .sorted((p1, p2) -> p2.toString().compareTo(p1.toString())) // Sort desc
                    .limit(limit - result.size())
                    .collect(Collectors.toList());
                
                for (Path path : matchingFiles) {
                    String content = new String(Files.readAllBytes(path));
                    TestExecutionData execData = parseTestExecutionData(content);
                    if (execData != null) {
                        result.add(execData);
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Error getting recent executions from files", e);
        }
        
        return result;
    }
    
    /**
     * Checks if model update is needed and triggers update if so
     */
    private void checkAndUpdateModel() {
        // Check if enough time has passed since last update
        if (lastModelTrainingTime == null ||
            Duration.between(lastModelTrainingTime, Instant.now()).toHours() >= 24) {
            
            // Check if we have enough data
            if (testHistory.size() >= minimumDataPoints) {
                updateModel();
            }
        }
    }
    
    /**
     * Updates the machine learning model based on historical data
     */
    private void updateModel() {
        try {
            logger.info("Updating test path analyzer model...");
            
            // Record start time
            long startTime = System.currentTimeMillis();
            
            // Optimize feature weights based on historical data
            optimizeFeatureWeights();
            
            // Clear analysis cache since weights changed
            analysisCache.clear();
            
            // Update last training time
            lastModelTrainingTime = Instant.now();
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("Model update completed in " + duration + "ms");
            
            // Log updated weights
            logger.info("Updated feature weights: " + featureWeights);
        } catch (Exception e) {
            logger.error("Error updating model: " + e.getMessage(), e);
        }
    }
    
    /**
     * Optimizes feature weights based on historical performance data
     */
    private void optimizeFeatureWeights() {
        // This is a simplified weight optimization algorithm
        // In a real implementation, this would use more sophisticated ML techniques
        
        if (testHistory.size() < minimumDataPoints) {
            return;
        }
        
        // Calculate success metrics for each feature
        Map<String, Double> featureCorrelations = new HashMap<>();
        
        // Initialize correlations
        for (String feature : featureWeights.keySet()) {
            featureCorrelations.put(feature, 0.0);
        }
        
        // Calculate feature correlations with test success
        calculateFeatureSuccessCorrelations(featureCorrelations);
        
        // Adjust weights based on correlations
        for (Map.Entry<String, Double> entry : featureCorrelations.entrySet()) {
            String feature = entry.getKey();
            double correlation = entry.getValue();
            
            // Get current weight
            double currentWeight = featureWeights.get(feature);
            
            // Calculate adjustment factor (positive correlation means increase weight)
            double adjustment = correlation * 0.1; // 10% maximum adjustment
            
            // Update weight
            double newWeight = Math.max(0.1, Math.min(2.0, currentWeight + adjustment));
            featureWeights.put(feature, newWeight);
        }
    }
    
    /**
     * Calculates correlations between features and test success
     */
    private void calculateFeatureSuccessCorrelations(Map<String, Double> correlations) {
        // Collect feature values and success indicators
        Map<String, List<Double>> featureValues = new HashMap<>();
        List<Double> successValues = new ArrayList<>();
        
        // Initialize feature lists
        for (String feature : featureWeights.keySet()) {
            featureValues.put(feature, new ArrayList<>());
        }
        
        // Collect data from history
        for (TestExecutionData data : testHistory.values()) {
            // Success is 1.0 for pass, 0.0 for fail
            double success = "PASS".equals(data.getResult()) ? 1.0 : 0.0;
            successValues.add(success);
            
            // Collect feature values
            featureValues.get("executionTime").add((double) data.getDuration());
            featureValues.get("passRate").add(getHistoricalPassRate(data.getTestId()));
            featureValues.get("complexity").add(data.getComplexityScore());
            featureValues.get("resourceUsage").add(data.getResourceUsage());
            featureValues.get("flakiness").add(data.getFlakiness());
            
            // Set dummy values for features we don't have direct data for
            featureValues.get("dataDependency").add((double) data.getDependencies().size());
            featureValues.get("coverageGain").add(getCoverageGainScore(data));
            featureValues.get("lastExecutionStatus").add(success); // Using current status as proxy
            featureValues.get("age").add(0.5); // Neutral value
            featureValues.get("userPriority").add(0.5); // Neutral value
        }
        
        // Calculate correlation for each feature
        for (String feature : featureWeights.keySet()) {
            List<Double> featureData = featureValues.get(feature);
            if (featureData.size() == successValues.size() && !featureData.isEmpty()) {
                double correlation = CSSmartStatisticsUtil.calculateCorrelation(
                    featureData, successValues);
                correlations.put(feature, correlation);
            }
        }
    }
    
    /**
     * Gets historical pass rate for a test
     */
    private double getHistoricalPassRate(String testId) {
        List<TestExecutionData> history = getRecentExecutions(testId, 10);
        
        if (history.isEmpty()) {
            return 0.5; // Neutral value if no history
        }
        
        int passCount = 0;
        for (TestExecutionData data : history) {
            if ("PASS".equals(data.getResult())) {
                passCount++;
            }
        }
        
        return (double) passCount / history.size();
    }
    
    /**
     * Calculates coverage gain score for a test
     */
    private double getCoverageGainScore(TestExecutionData data) {
        Map<String, Double> coverage = data.getCoverage();
        
        if (coverage == null || coverage.isEmpty()) {
            return 0.0;
        }
        
        // Calculate average coverage
        double sum = 0.0;
        for (Double value : coverage.values()) {
            sum += value;
        }
        
        return sum / coverage.size();
    }
    
    /**
     * Analyzes a test suite and suggests optimal execution order
     */
    public PathAnalysisResult analyzeTestPath(List<String> testIds) {
        if (!enabled || testIds == null || testIds.isEmpty()) {
            return new PathAnalysisResult(testIds, Collections.emptyMap());
        }
        
        // Generate cache key for this analysis
        String cacheKey = String.join(":", testIds);
        
        // Check if we have a cached result
        PathAnalysisResult cachedResult = analysisCache.get(cacheKey);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        try {
            logger.info("Analyzing optimal test path for " + testIds.size() + " tests");
            
            // Record start time
            long startTime = System.currentTimeMillis();
            
            // Calculate scores for each test
            Map<String, Double> testScores = calculateTestScores(testIds);
            
            // Sort tests by score (higher is better)
            List<String> optimizedOrder = testIds.stream()
                .sorted((t1, t2) -> Double.compare(testScores.getOrDefault(t2, 0.0), 
                                                  testScores.getOrDefault(t1, 0.0)))
                .collect(Collectors.toList());
            
            // Create result
            PathAnalysisResult result = new PathAnalysisResult(optimizedOrder, testScores);
            
            // Cache the result
            analysisCache.put(cacheKey, result);
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("Test path analysis completed in " + duration + "ms");
            
            return result;
        } catch (Exception e) {
            logger.error("Error analyzing test path: " + e.getMessage(), e);
            return new PathAnalysisResult(testIds, Collections.emptyMap());
        }
    }
    
    /**
     * Calculates scores for each test based on weighted features
     */
    private Map<String, Double> calculateTestScores(List<String> testIds) {
        Map<String, Double> scores = new HashMap<>();
        
        for (String testId : testIds) {
            double score = calculateTestScore(testId);
            scores.put(testId, score);
        }
        
        return scores;
    }
    
    /**
     * Calculates score for a single test based on weighted features
     */
    private double calculateTestScore(String testId) {
        TestExecutionData data = testHistory.get(testId);
        
        if (data == null) {
            // No history - neutral score
            return 0.5;
        }
        
        double score = 0.0;
        double totalWeight = 0.0;
        
        // Execution time (negative factor - shorter is better)
        double normalizedTime = Math.min(1.0, data.getDuration() / 30000.0); // Cap at 30 seconds
        double timeScore = 1.0 - normalizedTime;
        score += timeScore * featureWeights.get("executionTime");
        totalWeight += featureWeights.get("executionTime");
        
        // Pass rate
        double passRate = getHistoricalPassRate(testId);
        score += passRate * featureWeights.get("passRate");
        totalWeight += featureWeights.get("passRate");
        
        // Complexity
        double normalizedComplexity = Math.min(1.0, data.getComplexityScore() / 10.0); // Cap at 10
        score += (1.0 - normalizedComplexity) * featureWeights.get("complexity");
        totalWeight += featureWeights.get("complexity");
        
        // Resource usage (negative factor - lower is better)
        score += (1.0 - data.getResourceUsage()) * featureWeights.get("resourceUsage");
        totalWeight += featureWeights.get("resourceUsage");
        
        // Data dependency (negative factor - fewer dependencies is better)
        double dependencyScore = Math.max(0.0, 1.0 - (data.getDependencies().size() / 5.0));
        score += dependencyScore * featureWeights.get("dataDependency");
        totalWeight += featureWeights.get("dataDependency");
        
        // Coverage gain
        double coverageScore = getCoverageGainScore(data);
        score += coverageScore * featureWeights.get("coverageGain");
        totalWeight += featureWeights.get("coverageGain");
        
        // Flakiness (negative factor - lower is better)
        score += (1.0 - data.getFlakiness()) * featureWeights.get("flakiness");
        totalWeight += featureWeights.get("flakiness");
        
        // Last execution status
        double lastStatusScore = "PASS".equals(data.getResult()) ? 1.0 : 0.0;
        score += lastStatusScore * featureWeights.get("lastExecutionStatus");
        totalWeight += featureWeights.get("lastExecutionStatus");
        
        // Normalize final score
        return score / totalWeight;
    }
    
    /**
     * Gets feature weights
     */
    public Map<String, Double> getFeatureWeights() {
        return new HashMap<>(featureWeights);
    }
    
    /**
     * Gets test history size
     */
    public int getTestHistorySize() {
        return testHistory.size();
    }
    
    /**
     * Data class for test execution data
     */
    public static class TestExecutionData {
        private String testId;
        private long executionTime;
        private String result;
        private long duration;
        private double resourceUsage;
        private double complexityScore;
        private List<String> dependencies = new ArrayList<>();
        private Map<String, Double> coverage = new HashMap<>();
        private double flakiness;
        
        // Getters and setters
        public String getTestId() { return testId; }
        public void setTestId(String testId) { this.testId = testId; }
        
        public long getExecutionTime() { return executionTime; }
        public void setExecutionTime(long executionTime) { this.executionTime = executionTime; }
        
        public String getResult() { return result; }
        public void setResult(String result) { this.result = result; }
        
        public long getDuration() { return duration; }
        public void setDuration(long duration) { this.duration = duration; }
        
        public double getResourceUsage() { return resourceUsage; }
        public void setResourceUsage(double resourceUsage) { this.resourceUsage = resourceUsage; }
        
        public double getComplexityScore() { return complexityScore; }
        public void setComplexityScore(double complexityScore) { this.complexityScore = complexityScore; }
        
        public List<String> getDependencies() { return dependencies; }
        public void setDependencies(List<String> dependencies) { 
            this.dependencies = dependencies != null ? dependencies : new ArrayList<>(); 
        }
        
        public Map<String, Double> getCoverage() { return coverage; }
        public void setCoverage(Map<String, Double> coverage) { 
            this.coverage = coverage != null ? coverage : new HashMap<>(); 
        }
        
        public double getFlakiness() { return flakiness; }
        public void setFlakiness(double flakiness) { this.flakiness = flakiness; }
    }
    
    /**
     * Data class for test step data
     */
    public static class TestStepData {
        private String testId;
        private String testName;
        private String stepName;
        private String stepType;
        private boolean passed;
        private long duration;
        private long timestamp;
        private Map<String, String> metadata = new HashMap<>();
        
        // Getters and setters
        public String getTestId() { return testId; }
        public void setTestId(String testId) { this.testId = testId; }
        
        public String getTestName() { return testName; }
        public void setTestName(String testName) { this.testName = testName; }
        
        public String getStepName() { return stepName; }
        public void setStepName(String stepName) { this.stepName = stepName; }
        
        public String getStepType() { return stepType; }
        public void setStepType(String stepType) { this.stepType = stepType; }
        
        public boolean isPassed() { return passed; }
        public void setPassed(boolean passed) { this.passed = passed; }
        
        public long getDuration() { return duration; }
        public void setDuration(long duration) { this.duration = duration; }
        
        public long getTimestamp() { return timestamp; }
        public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
        
        public Map<String, String> getMetadata() { return metadata; }
        public void setMetadata(Map<String, String> metadata) { 
            this.metadata = metadata != null ? metadata : new HashMap<>(); 
        }
    }
    
    /**
     * Data class for path analysis result
     */
    public static class PathAnalysisResult {
        private final List<String> optimizedOrder;
        private final Map<String, Double> testScores;
        
        public PathAnalysisResult(List<String> optimizedOrder, Map<String, Double> testScores) {
            this.optimizedOrder = optimizedOrder;
            this.testScores = testScores;
        }
        
        public List<String> getOptimizedOrder() {
            return optimizedOrder;
        }
        
        public Map<String, Double> getTestScores() {
            return testScores;
        }
    }
}


/**
 * Registers a smart data provider for AI-generated test data
 * 
 * @param method the test method to associate with this data provider (can be null for class-level)
 * @param targetForm the form or UI element to generate test data for
 * @param coverage the desired test coverage level
 * @param constraints the constraints to apply to generated data
 */
public void registerSmartDataProvider(Method method, String targetForm, 
                                     Coverage coverage, Constraint[] constraints) {
    logger.info("Registering smart data provider for " + 
               (method != null ? "method: " + method.getName() : "class"));
    
    // Create a configuration object to store smart generation parameters
    Map<String, Object> config = new HashMap<>();
    config.put("targetForm", targetForm);
    config.put("coverage", coverage);
    config.put("constraints", constraints);
    
    // Store the configuration for this method or class
    String key = method != null ? method.getDeclaringClass().getName() + "." + method.getName() : 
                                "class-level";
    smartDataProviders.put(key, config);
    
    // Log registration details
    logger.debug("Smart data provider registered with target: " + targetForm + 
                ", coverage: " + coverage);
}
